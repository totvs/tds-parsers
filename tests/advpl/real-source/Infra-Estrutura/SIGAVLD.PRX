#INCLUDE "PROTHEUS.CH"
#INCLUDE "SIGAVLD.CH"

/*


Ŀ
Funo     SIGAVLD   Autor  Microsiga         	   Data  09/02/93   
Ĵ
Descrio  													              
Ĵ
Sintaxe            	    			                                      
Ĵ
Parametros 	                                                              
Ĵ
 Uso                                                                      
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.                 
Ĵ
Programador  Data       BOPS    Motivo da Alteracao                     
Ĵ
Bruno       17/06/2008	145908 Ajustada rotina para que o campos         
			   		  		   RE0_FUNASS,RE0_DESLIG,RE0_CODFUN e        
			   		  		   RE0_DESFUN  apresente as informacoes dos  
			   		  		   funcionarios nao importando de qual filial
			   		  		   ele(s) sejam ou se estao demitidos ou nao.
Leandro Dr  07/11/2008	149365 Ajustada rotina para que os dados do parti
			   		  		   cipante sejam atualizados preferencialment
			   		  		   de acordo com o funcionario mensalista em 
			   		  		   sobreposicao ao autonomo.                 
Leandro Dr  16/12/2008	008689 Ajuste na funcao Sx3Box2Arr para montar   
			   		  		   combobox somente se o campo possuir ativa.
Allyson M   08/08/2011	018945/Ajuste em EntUpdateRd0 p/ verificar se    
			   		  	  2011 for transferencia e o registro da RD0 ja  
			   		  	       existir, se atualiza ou cria novo item.	  
R.Berti     28/08/2012TFNVB1  Ajuste em EntUpdateRd0 p/ gravar RD0_SENHA
			   		  	       com RA_SENHA somente se RD0_SENHA vazia.  
Gustavo M.  20/02/2013TGMKHS  Retirada do ajuste anterior, RDO x SRA.   
			   		  		   Para que a atualizacao nao seja feita, bas
			   		  		   ta retirar o relacionamento do MSRELRDZ.  
ٱ

*/

/*/


Ŀ
Funo	  FA010IRF  Autor  Wagner Xavier 	     Data  09/02/93 
Ĵ
Descrio  Consiste percentual de IRRF, de acordo com a resposta 	  
			  de calculo ou nao 										  
Ĵ
Sintaxe	  FA010IRF()												  
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function FA010IRF()
	LOCAL lRet:=.t.

	IF m->ed_calcirf != "S" .and. m->ed_percirf > 0
		lRet:=.f.
	EndIF
	Return lRet

	/*/
	
	Ŀ
	Funo	 FA010calIRAutor   Wagner Xavier 	  	 Data  29/05/92 
	Ĵ
	Descrio  Verifica se natureza ira'calcular IRRF                     
	Ĵ
	Sintaxe	  FA010CalIR()												  
	Ĵ
	 Uso		  FINA010													  
	ٱ
	
	
	/*/
Function FA010CalIRF()
	LOCAL nEndereco,nEnd1,nEnd2,lRetorna := .T.,nTam,nDec,cMascara

	If !m->ed_calcirf $ "SN"
		lRetorna := .F.
	Else
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) = "ED_PERCIRF" } )
		IF m->ed_calcirf = "N" .and. nEndereco>0
			nEnd1 := Val(Subs(aGets[nEndereco],1,2))
			nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
			nTam	:= Len(aTela[nEnd1][nEnd2])
			m->ed_percirf := 0
			dbSelectArea("SX3")
			dbSetOrder(2)
			dbSeek("ED_PERCIRF")
			dbSetOrder(1)
			cMascara := Trim(X3_PICTURE)
			dbSelectArea("SED")
			aTela[nEnd1][nEnd2] := Transform(m->ed_percirf,cMascara)
			lRefresh := .T.
		EndIf
	EndIf
	Return lRetorna

	/*
	
	Ŀ
	Funo	 RetPessoa | Autor  Eduardo Motta 		 Data 08/08/2000
	Ĵ
	Descrio  Retorna o tipo da pessoa de acordo com o tamanho do cCgcCpf
	Ĵ
	Sintaxe	  ExpL1 := RetPessoa(cCgcCpf)                             	  
	Ĵ
	Parametros cCgcCpf - Codigo do CGC ou CPF                             
	Ĵ
	 Uso		  Generico 												  
	ٱ
	
	*/
Function RetPessoa(cCgcCpf)
	Local cRetPes := " "
	If Left(cCgcCPF,2) =='  '
		Return ' '
	EndIf
	if Len(Trim(cCgcCpf)) >= 14
		cRetPes := "J"
	else
		cRetPes := "F"
	endif
	Return cRetPes

	/*
	
	Ŀ
	Funo	 PicPes    | Autor  Eduardo Motta 		 Data 08/08/2000
	Ĵ
	Descrio  Retorna a picture do CGC ou CPF                            
	Ĵ
	Sintaxe	  ExpL1 := PicPes(cTipPes)                               	  
	Ĵ
	Parametros cTipPes - F-Fisica/J-Juridica                              
	Ĵ
	 Uso		  Generico 												  
	ٱ
	
	*/
Function PicPes(cTipPes)
	Local cPict := ""
	if cTipPes == "F"
		cPict := "@R 999.999.999-99"
	else
		cPict := "@R 99.999.999/9999-99"
	endif
	cPict := cPict + "%C"
	Return cPict


	/*
	
	
	Ŀ
	Funo     Tr030Depto	 Autor  Cristina Ogura     Data  13.11.97 
	Ĵ
	Descrio  Valida o campo QB_DEPTO da getdados                        
	Ĵ
	Sintaxe    Tr030Depto()                                            	  
	Ĵ
	Uso		  Trma030  												  
	ٱ
	
	*/
Function Tr030Depto()
	Local nPosDepto:=0, cVar:= &(ReadVar())
	Local nY

	nPosDepto := Ascan(aHeader,{ |x| x[2] = "QB_DEPTO"})

	For ny=1 To Len(aCols)
		If cVar == aCols[ny][nPosDepto] .And.;
				n # ny .And. !aCols[ny][Len(aCols[ny])]
			Help("",1,"A060JAEXISTE")						// Este codigo de departamento ja existe
			Return .F.											// para este grupo
			Exit
		EndIf
	Next ny
	Return .T.

	/*
	
	
	Ŀ
	Funo	 VldCgcCpf  Autor  Alessandro B. Freire   Data  05/02/96 
	Ĵ
	Descrio  Executa validacao do Campo VLDUSER do SX3.				  
	Ĵ
	 Uso		  Generico 												  
	ٱ
	
	
	*/
FUNCTION VldCgcCpf( cTipo,cCgcCpf )

	If cTipo == NIL .OR. Empty(cCgcCpf) .or. Empty(cTipo)
		Return(.T.)
	EndIf

	If cCgcCpf == Nil;Return .T.;Endif

		If Len( Trim(cCgcCpf ) ) != 14 .And. cTipo == "J"
			Help( " ",1,"NOLENCGC")
			Return( .F. )
		EndIf

		If Len( Trim(cCgcCpf ) ) != 11 .And. cTipo == "F"
			Help( " ",1,"NOLENCPF")
			Return( .F. )
		EndIf

		Return( .T. )

	Function VldUser(cCampo)
		Local nRec, nOrd, lRet, cValid,cAlias

		cAlias:=Alias()
		dbSelectArea("SX3")
		nRec := Recno()
		nOrd := IndexOrd()
		dbSetOrder(2)
		dbSeek(cCampo)
		dbSetOrder(nOrd)
		dbSelectArea(cAlias)

		cValid := IIf(!Empty(SX3->X3_VLDUSER),Alltrim(SX3->X3_VLDUSER),"")

		IF !Empty(cValid)
			Help := .t.
			lRet := &(cValid)
			Help := .f.
			IF lRet == .f.
				Help(" ",1,cCampo)
			Endif
		Else
			lRet := .t.
		Endif
		dbSelectArea("SX3")
		dbGoto(nRec)
		dbSelectArea(cAlias)

		Return lRet


		/*
		
		
		ͻ
		Programa  VldCodBar Autor  Claudio D. de Souza  Data   14/12/01   
		͹
		Desc.      Validar o codigo de barras ou a linha digitavel de titulos 
		           a pagar ou a receber                                       
		           Parametros: cCodBar - Codigo de barras ou linha digitavel  
		           Retorno   : .T. Codigo de barras ou linha digitavel validos
		                       .F. Caso contrario			                  
		͹
		Uso        AP6                                                        
		ͼ
		
		
		*/
	Function VldCodBar(cCodBar)
		Local lRet := .T.
		Local nX
		Local	cCampo

		cCodBar := Alltrim(cCodBar)
		// Completa o tamanho do codigo de barras se ele for menor que 44 por se tratar de uma
		// linha digitavel.
		If Len(cCodBar) < 44
			cCodBar := Left(cCodBar+Replicate("0", 48-Len(cCodBar)),47)
		Endif

		Do Case
		Case Len(cCodBar)==44 // Validacao do codigo de Barras
			// Se nao conseguir validar o DV do codigo de barras, tenta validar como
			// se fosse titulo de concessionaria.
			If Dv_BarCode(Left(cCodBar,4)+SubStr(cCodBar,6))!=SubStr(cCodBar,5,1)
				// Codigo de barras de concessionarias
				cCampo:=Left(cCodBar,3)+SubStr(cCodBar,5)
				If VldMod(cCampo,cCodBar)!=SubStr(cCodBar,4,1)
					Help(" ",1,"INVCDBAR",,"Codigo de Barras Invalido!!",1,0)
					lRet := .F. // Invalido
				Endif
			Endif
		Case Len(cCodBar)==47 // Validacao da linha digitavel
			// Elimina os digitos
			cCodSemDv	:= Left(cCodBar,9)+SubStr(cCodBar,11,10)+SubStr(cCodBar,22,10)
			cCodBar2		:= Left(cCodBar,4)+Substr(cCodBar,34)+Substr(cCodSemDv,5)
			// Calcula os digitos e os compara com os digitos informados
			For nX := 1 To 3
				cCampo := SubStr(cCodSemDv,If(nX==1,1,If(nX==2,10,20)),If(nX==1,9,10))
				If Mod10(cCampo) != SubStr(cCodBar,If(nX==1,10,If(nX==2,21,32)),1)
					Help(" ",1,"INVCDBAR",,"Codigo de Barras Invalido!!",1,0)
					lRet := .F.
					Exit
				Endif
			Next
			//Valido o digito verificador geral da linha digitada (pos. 33 da linha digitada)
			If lRet
				If Dv_BarCode(cCodBar2)!=SubStr(cCodBar,33,1)
					Help(" ",1,"INVCDBAR",,"Codigo de Barras Invalido!!",1,0)
					lRet := .F.
				Endif
			Endif
		OtherWise // Validacao da linha digitavel de concessionarias
			// Elimina os digitos
			cCodSemDv := Left(cCodBar,11)+SubStr(cCodBar,13,11)+SubStr(cCodBar,25,11)+SubStr(cCodBar,37,11)
			// Calcula os digitos e os compara com os digitos informados
			For nX := 1 To Len(cCodSemDv) Step 11
				cCampo := SubStr(cCodSemDv,nX,11)
				nPos :=  If(nX==1,12,If(nX==12,24,If(nX==23,36,48)))
				If VldMod(cCampo,cCodBar) != SubStr(cCodBar,nPos,1)
					Help(" ",1,"INVCDBAR",,"Codigo de Barras Invalido!!",1,0)
					lRet := .F.
					Exit
				Endif
			Next
		EndCase
		Return (lRet)

		/*
		
		
		ͻ
		Rotina    Dv_BarCodeAutor  Claudio D. de Souza  Data   14/12/01   
		͹
		Desc.     Calcula o digito verificador de um codigo de barras padrao  
		          Febraban.                                                   
		͹
		Uso        CodBarVl2                                                  
		ͼ
		
		
		*/
	Static Function DV_BarCode( cBarCode )
		Local cDig
		Local nPos
		Local nAux := 0

		For nPos := 1 To 43
			nAux += Val(SubStr(cBarCode,nPos,1)) * If( nPos<= 3, ( 5-nPos),     ;
				If( nPos<=11, (13-nPos),     ;
					If( nPos<=19, (21-nPos),     ;
						If( nPos<=27, (29-nPos),     ;
							If( nPos<=35, (37-nPos),     ;
								(45-nPos) )))))
						Next
						nAux := nAux % 11
						cDig := If( (11-nAux)>9, 1, (11-nAux) )

						Return Str(cDig,1)

						/*
						
						
						ͻ
						Rotina    Mod10     Autor  Claudio D. de Souza  Data   14/12/01   
						͹
						Desc.     Calcula o digito verificador de uma sequencia de numeros    
						          baseando-se no modulo 10. Utilizado para verificar o digito 
						          em linhas digitaveis e codigo de barras de concessionarias  
						          de servicos publicos                                        
						͹
						Uso        CodBarVl2                                                  
						ͼ
						
						
						*/
					Static Function Mod10( cNum )
						Local nFor    := 0
						Local nTot    := 0
						Local cNumAux

						// Verifico o numero de digitos e impar
						// Caso seja, adiciono um caracter
						If Len(cNum)%2 #0
							cNum := "0"+cNum
						EndIf

						For nFor := 1 To Len(cNum)
							If nFor%2 == 0
								cNumAux := StrZero(2 * Val(SubStr(cNum,nFor,1)), 2)
							Else
								cNumAux := StrZero(Val(SubStr(cNum,nFor,1))    , 2)
							Endif
							nTot += ( Val(LEFT(cNumAux,1)) + Val(Right(cNumAux,1)) )
						Next

						nTot := nTot % 10
						nTot := If( nTot#0, 10-nTot, nTot )

						Return Str(nTot,1)

						/*
						
						
						ͻ
						Rotina    Mod11     Autor  Adrianne Furtado     Data   28/08/09   
						͹
						Desc.     Calcula o digito verificador de uma sequencia de numeros    
						          baseando-se no modulo 10. Utilizado para verificar o digito 
						          em linhas digitaveis e codigo de barras de concessionarias  
						          de servicos publicos                                        
						͹
						Uso        CodBarVl2                                                  
						ͼ
						
						
						*/
					Static Function Mod11( cNum )
						Local nFor    := Len(cNum)
						Local nTot    := 0
						Local aNumAux := Array(Len(cNum),3) //array com o conteudo do cNum para ser multiplicado
						Local aLisMult:= {9,8,7,6,5,4,3,2} //Array/Lista de Multiplicadores
						Local nResto
						Local nDv
						Local nPos 	  := Len(aLisMult)

						For nFor := Len(cNum) To 1 Step -1
							aNumAux[nFor,1] := Val(SubStr(cNum,nFor,1))
							aNumAux[nFor,2] := aLisMult[nPos]
							nPos--
							If nPos == 0
								nPos := 8
							EndIf
							aNumAux[nFor,3] := aNumAux[nFor,2] * aNumAux[nFor,1]
							nTot += aNumAux[nFor,3]
						Next

						nResto := nTot % 11
						If nResto == 0 .or.	nResto == 1
							nDv := 0
						ElseIf nResto == 10
							nDv := 1
						Else
							nDv := 11-nResto
						EndIf

						Return Str(nDv,1)

						/*
						
						
						ͻ
						Rotina    VldMod    Autor  Adrianne Furtado     Data   28/08/09   
						͹
						Desc.     Calcula o digito verificador de uma sequencia de numeros    
						          verificando qual o modulo do padro FEBRABAN deve ser       
						          utilizado                                                   
						͹
						Uso        CodBarVl2                                                  
						ͼ
						
						
						*/
					Static Function VldMod( cNum , cCodBar)
						Local cCodSub3 := SubStr(cCodBar,3,1)
						Local cRet := ""
						If cCodSub3 == '6' .or. cCodSub3 == '7'
							cRet :=Mod10(cNum)
						ElseIf cCodSub3 == '8' .or. cCodSub3 == '9'
							cRet :=Mod11(cNum)
						EndIf
						Return cRet

						/*
						
						
						ͻ
						Rotina    DigCodBar Autor  Mauricio Pequim Jr.  Data   09/12/02   
						͹
						Desc.     Retorna o digito verificador de um codigo de barras ou linha
						          digitade de boletos. Utilizada na gerao do arquivo envio  
						          de Cnab para pagamento de documentos com codigo de barras   
						͹
						Uso       Generico                                                    
						ͼ
						
						
						*/
					Function DigCodBar()

						Local cCampo := ""

						If Len(Alltrim(SE2->E2_CODBAR)) == 44
							cCampo := Substr(SE2->E2_CODBAR,5,1)
						Else
							cCampo := Substr(SE2->E2_CODBAR,33,1)
						EndIf

						Return(cCampo)

						/*/
						
						
						Ŀ
						Funcao    IE         Autor Eduardo Riera           Data 10.12.2002
						Ĵ
						Descrio Rotina de validacao do digito verificador da IE             
						                                                                      
						Ĵ
						Retorno   ExpL: Indica se a Inscricao estadual eh valida              
						Ĵ
						ParametrosExpC1: Codigo da Inscricao estadual                         
						          ExpL2: Unidade Federativa                                   
						          ExpL3: Indica se o help devera ser demonstrado         (OPC)
						                                                                      
						Ĵ
						   DATA    Programador   Manutencao Efetuada                         
						Ĵ
						                                                                     
						ٱ
						
						
						/*/
						#DEFINE TCD_UF     01
						#DEFINE TCD_TAM    02
						#DEFINE TCD_FATF   03
						#DEFINE TCD_DVXROT 04
						#DEFINE TCD_DVXMD  05
						#DEFINE TCD_DVXTP  06
						#DEFINE TCD_DVYROT 07
						#DEFINE TCD_DVYMD  08
						#DEFINE TCD_DVYTP  09
						#DEFINE TCD_DIG14  10
						#DEFINE TCD_DIG13  11
						#DEFINE TCD_DIG12  12
						#DEFINE TCD_DIG11  13
						#DEFINE TCD_DIG10  14
						#DEFINE TCD_DIG09  15
						#DEFINE TCD_DIG08  16
						#DEFINE TCD_DIG07  17
						#DEFINE TCD_DIG06  18
						#DEFINE TCD_DIG05  19
						#DEFINE TCD_DIG04  20
						#DEFINE TCD_DIG03  21
						#DEFINE TCD_DIG02  22
						#DEFINE TCD_DIG01  23
						#DEFINE TCD_CRIT   24

					Function IE(cIE,cUF,lHelp)

						Local aPesos   := {}
						Local aDigitos := {}
						Local aCalculo := {}
						Local aMi      := {}
						Local nX       := 0
						Local nY       := 0
						Local nDVX     := 0
						Local nDVY     := 0
						Local nPUF     := 0
						Local nPPeso   := 0
						Local nSomaS   := 0
						Local cDigito  := ""
						Local cDVX     := ""
						Local cDVY     := ""
						Local lRetorno := .T.
						Local cIEOrig  := cIE

						DEFAULT lHelp := .T.
						//Ŀ
						//Ajusta o codigo da Inscricao Estadual                                   
						//
						cIE := AllTrim(cIE)
						cIE := StrTran(cIE,".","")
						cIE := StrTran(cIE,"/","")
						cIE := StrTran(cIE,"-","")
						//Ŀ
						//Montagem da Tabela de Calculo                                           
						//
						If !Empty(cIEOrig) .And. Empty(cIE) .And. !Empty(cUF)
							lRetorno := .F.
						EndIf
						If !Empty(cIE) .And. !"ISENT"$cIE .And. lRetorno
							aadd(aCalculo,{"AC",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=0","=1","09","09","09","09","09","09","DVX",{||Len(cIE)==09}})
							aadd(aCalculo,{"AC",13,00,"E ",11,"P02","E ",11,"P01","--","=0","=1","09","09","09","09","09","09","09","09","09","DVX","DVY",{||Len(cIE)==13}})
							aadd(aCalculo,{"AL",09,00,"BD",11,"P01","  ",00,"   ","--","--","--","--","--","=2","=4","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"AP",09,00,"CE",11,"P01","  ",00,"   ","--","--","--","--","--","=0","=3","09","09","09","09","09","09","DVX",{||cIE<="030170009"}})
							aadd(aCalculo,{"AP",09,01,"CE",11,"P01","  ",00,"   ","--","--","--","--","--","=0","=3","09","09","09","09","09","09","DVX",{||cIE>="030170010".And.cIE<="030190229"}})
							aadd(aCalculo,{"AP",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=0","=3","09","09","09","09","09","09","DVX",{||cIE>="030190230"}})
							aadd(aCalculo,{"AM",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=0","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"BA",08,00,"E ",10,"P02","E ",10,"P03","--","--","--","--","--","--","09","09","09","09","09","09","DVY","DVX",{||SubStr(cIE,1,1)$"0123458" .AND. Len( cIE )==8}})
							aadd(aCalculo,{"BA",08,00,"E ",11,"P02","E ",11,"P03","--","--","--","--","--","--","09","09","09","09","09","09","DVY","DVX",{||SubStr(cIE,1,1)$"679".AND. Len( cIE )==8}})
							aadd(aCalculo,{"BA",09,00,"E ",10,"P02","E ",10,"P03","--","--","--","--","--","09","09","09","09","09","09","09","DVY","DVX",{||SubStr(cIE,2,1)$"0123458" .AND. Len( cIE )==9}})
							aadd(aCalculo,{"BA",08,00,"E ",11,"P02","E ",11,"P03","--","--","--","--","--","09","09","09","09","09","09","09","DVY","DVX",{||SubStr(cIE,2,1)$"679".AND. Len( cIE )==9}})
							aadd(aCalculo,{"CE",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=0","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"DF",13,00,"E ",11,"P02","E ",11,"P01","--","=0","=7","=345","09","09","09","09","09","09","09","09","DVX","DVY",{|| Len(cIE)==12 .OR. (Len(cIE)==13 .AND. SubStr(cIE,3,1)  $ "345")}})
							aadd(aCalculo,{"DF",13,00,"E ",11,"P02","E ",11,"P01","--","=0","=7","09","09","09","09","09","09","09","09","09","DVX","DVY",{|| Len(cIE)==13 .AND. !SubStr(cIE,3,1)  $ "345"}})
							aadd(aCalculo,{"ES",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","09","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"GO",09,01,"F ",11,"P01","  ",00,"   ","--","--","--","--","--","=1","=015","09","09","09","09","09","09","DVX",{||cIE>="101031050".And.cIE<="101199979"}})
							aadd(aCalculo,{"GO",09,00,"F ",11,"P01","  ",00,"   ","--","--","--","--","--","=1","=015","09","09","09","09","09","09","DVX",{||!(cIE>="101031050".And.cIE<="101199979")}})
							aadd(aCalculo,{"MA",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=1","=2","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"MT",11,00,"E ",11,"P01","  ",00,"   ","--","--","--","09","09","09","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"MS",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=2","=8","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"MG",13,00,"AE",10,"P10","E ",11,"P11","--","09","09","09","09","09","09","09","09","09","09","09","DVX","DVY",{||SubStr(cIE,1,1)<>"P".And.Len(cIE)==13}})
							aadd(aCalculo,{"MG",09,00,"  ",00,"P09","  ",00,"   ","--","--","--","--","--","=P","=R","09","09","09","09","09","09","09",{||SubStr(cIE,1,1)=="P".And.Len(cIE)==9}})
							aadd(aCalculo,{"PA",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=1","=5","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"PB",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","09","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"PR",10,00,"E ",11,"P09","E ",11,"P08","--","--","--","--","09","09","09","09","09","09","09","09","DVX","DVY",{||.T.}})
							aadd(aCalculo,{"PE",14,01,"E ",11,"P07","  ",00,"   ","=1","=8","19","09","09","09","09","09","09","09","09","09","09","DVX",{||Len(cIE)==14}})
							aadd(aCalculo,{"PE",09,00,"E ",11,"P02","E ",11,"P01","--","--","--","--","--","09","09","09","09","09","09","09","DVX","DVY",{||Len(cIE)==9}})
							aadd(aCalculo,{"PI",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","=1","=9","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"RJ",08,00,"E ",11,"P08","  ",00,"   ","--","--","--","--","--","--","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"RN",09,00,"BD",11,"P01","  ",00,"   ","--","--","--","--","--","=2","=0","09","09","09","09","09","09","DVX",{||Len(cIE)==9}})
							aadd(aCalculo,{"RN",10,00,"BD",11,"P11","  ",00,"   ","--","--","--","--","=2","=0","09","09","09","09","09","09","09","DVX",{||Len(cIE)==10}})
							aadd(aCalculo,{"RS",10,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","09","09","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"RO",09,01,"E ",11,"P04","  ",00,"   ","--","--","--","--","--","19","09","09","09","09","09","09","09","DVX",{||Len(cIE)==9}})
							aadd(aCalculo,{"RO",14,01,"E ",11,"P01","  ",00,"   ","09","09","09","09","09","09","09","09","09","09","09","09","09","DVX",{||Len(cIE)==14}})
							aadd(aCalculo,{"RR",09,00,"D ",09,"P05","  ",00,"   ","--","--","--","--","--","=2","=4","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"SC",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","09","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"SP",12,00,"D ",11,"P12","D ",11,"P13","--","--","09","09","09","09","09","09","09","09","DVX","09","09","DVY",{||SubStr(cIE,1,1)<>"P"}})
							aadd(aCalculo,{"SP",13,00,"D ",11,"P12","  ",00,"   ","--","=P","09","09","09","09","09","09","09","09","DVX","09","09","09",{||SubStr(cIE,1,1)=="P"}})
							aadd(aCalculo,{"SE",09,00,"E ",11,"P01","  ",00,"   ","--","--","--","--","--","09","09","09","09","09","09","09","09","DVX",{||.T.}})
							aadd(aCalculo,{"TO",11,00,"E ",11,"P06","  ",00,"   ","--","--","--","=2","=9","09","=1239","09","09","09","09","09","09","DVX",{||.T.}})
							//Ŀ
							//Montagem da Tabela de Pesos                                             
							//
							aadd(aPesos,{06,05,04,03,02,09,08,07,06,05,04,03,02,00}) //01
							aadd(aPesos,{05,04,03,02,09,08,07,06,05,04,03,02,00,00}) //02
							aadd(aPesos,{06,05,04,03,02,09,08,07,06,05,04,03,00,02}) //03
							aadd(aPesos,{00,00,00,00,00,00,00,00,06,05,04,03,02,00}) //04
							aadd(aPesos,{00,00,00,00,00,01,02,03,04,05,06,07,08,00}) //05
							aadd(aPesos,{00,00,00,09,08,00,00,07,06,05,04,03,02,00}) //06
							aadd(aPesos,{05,04,03,02,01,09,08,07,06,05,04,03,02,00}) //07
							aadd(aPesos,{08,07,06,05,04,03,02,07,06,05,04,03,02,00}) //08
							aadd(aPesos,{07,06,05,04,03,02,07,06,05,04,03,02,00,00}) //09
							aadd(aPesos,{00,01,02,01,01,02,01,02,01,02,01,02,00,00}) //10
							aadd(aPesos,{00,03,02,11,10,09,08,07,06,05,04,03,02,00}) //11
							aadd(aPesos,{00,00,01,03,04,05,06,07,08,10,00,00,00,00}) //12
							aadd(aPesos,{00,00,03,02,10,09,08,07,06,05,04,03,02,00}) //13
							//Ŀ
							//Validacao dos digitos da inscricao estadual                             
							//
							nPUF := aScan(aCalculo,{|x| x[TCD_UF] == cUF .And. Eval(x[TCD_CRIT])})
							If nPUF <> 0
								//Ŀ
								//Validacao do Tamanho da inscricao estadual                              
								//
								Do Case
								Case aCalculo[nPUF][2] <> Len(cIE) .And. cUF == "TO"
									cIE := SubStr(cIe,1,2)+"01"+SubStr(cIe,3)
								EndCase
								nY := TCD_DIG01+1
								For nX := Len(cIE) To 1 STEP - 1
									cDigito := SubStr(cIE,nX,1)
									nY--
									Do Case
									Case SubStr(aCalculo[nPUF][nY],1,2)=="DV"
										If IsAlpha(cDigito) .Or. IsDigit(cDigito)
											If SubStr(aCalculo[nPUF][nY],1,3)=="DVX"
												cDVX := cDigito
											Else
												cDVY := cDigito
											EndIf
										Else
											lRetorno := .F.
										EndIf
									Case SubStr(aCalculo[nPUF][nY],1,2)=="--"
										lRetorno := .F.
										Exit
									Case SubStr(aCalculo[nPUF][nY],1,1)=="="
										If !cDigito $ SubStr(aCalculo[nPUF][nY],2)
											lRetorno := .F.
											Exit
										EndIf
									OtherWise
										If !(cDigito >= SubStr(aCalculo[nPUF][nY],1,1) .And. cDigito <= SubStr(aCalculo[nPUF][nY],2,1))
											lRetorno := .F.
											Exit
										EndIf
									EndCase
									aadd(aDigitos,cDigito)
								Next nX
							Else
								lRetorno := .F.
							EndIf
							//Ŀ
							//Calculo do digito verificador DVX                                       
							//
							If lRetorno
								nPPeso := Val(SubStr(aCalculo[nPUF][TCD_DVXTP],2))
								nSomaS := 0
								aMI    := {}
								For nX := 1 To Len(aDigitos)
									aadd(aMi,Val(aDigitos[nX])*aPesos[nPPeso][15-nX])
									nSomaS += Val(aDigitos[nX])*aPesos[nPPeso][15-nX]
								Next nX
								If "A"$aCalculo[nPUF][TCD_DVXROT]
									For nX := 1 To Len(aMi)
										nSomaS += Int(aMi[nX] / 10)
									Next nX
								EndIf
								If "B"$aCalculo[nPUF][TCD_DVXROT]
									nSomaS *= 10
								EndIf
								If "C"$aCalculo[nPUF][TCD_DVXROT]
									nSomaS += 5+4*aCalculo[nPUF][TCD_FATF]
								EndIf
								If "D"$aCalculo[nPUF][TCD_DVXROT]
									nDVX := Mod(nSomaS,aCalculo[nPUF][TCD_DVXMD])
								EndIf
								If "E"$aCalculo[nPUF][TCD_DVXROT]
									nDVX := aCalculo[nPUF][TCD_DVXMD]-Mod(nSomaS,aCalculo[nPUF][TCD_DVXMD])
								EndIf
								If "F"$aCalculo[nPUF][TCD_DVXROT]
									nDVX := aCalculo[nPUF][TCD_DVXMD]-Mod(nSomaS,aCalculo[nPUF][TCD_DVXMD])
									If nDVX == 11
										nDVX := 0
									EndIf
									If nDVX == 10
										nDVX := aCalculo[nPUF][TCD_FATF]
									EndIf
								EndIf
								If nDVX == 10
									nDVX := 0
								EndIf
								If nDVX == 11
									nDVX := aCalculo[nPUF][TCD_FATF]
								EndIf
								//Ŀ
								//Calculo do digito verificador DVY                                       
								//
								If !Empty(aCalculo[nPUF][TCD_DVYROT])
									nPPeso := Val(SubStr(aCalculo[nPUF][TCD_DVYTP],2))
									nSomaS := 0
									aMi    := {}
									For nX := 1 To Len(aDigitos)
										aadd(aMi,Val(aDigitos[nX])*aPesos[nPPeso][15-nX])
										nSomaS += Val(aDigitos[nX])*aPesos[nPPeso][15-nX]
									Next nX
									If "A"$aCalculo[nPUF][TCD_DVYROT]
										For nX := 1 To Len(aMi)
											nSomaS += Int(aMi[nX] / 10)
										Next nX
									EndIf
									If "B"$aCalculo[nPUF][TCD_DVYROT]
										nSomaS *= 10
									EndIf
									If "C"$aCalculo[nPUF][TCD_DVYROT]
										nSomaS *= 5+4*aCalculo[nPUF][TCD_FATF]
									EndIf
									If "D"$aCalculo[nPUF][TCD_DVYROT]
										nDVY := Mod(nSomaS,aCalculo[nPUF][TCD_DVYMD])
									EndIf
									If "E"$aCalculo[nPUF][TCD_DVYROT]
										nDVY := aCalculo[nPUF][TCD_DVYMD]-Mod(nSomaS,aCalculo[nPUF][TCD_DVYMD])
									EndIf
									If nDVY == 10
										nDVY := 0
									EndIf
									If nDVY == 11
										nDVY := aCalculo[nPUF][TCD_FATF]
									EndIf
								EndIf
								//Ŀ
								//Verificacao dos digitos calculados                                      
								//
								If Val(cDVX) <> nDVX .Or. Val(cDVY) <> nDVY
									lRetorno := .F.
								EndIf
							EndIf
						EndIf
						If !lRetorno .And. lHelp
							Help(" ",1,"IE")
						EndIf
						Return(lRetorno)

						/*
						
						
						Ŀ
						Funcao    VldChavUni Rev.  Rodrigo de A Sartorio   Data 13.08.2003
						Ĵ
						Descrio Validacao de chave unica para gravacao                      
						Ĵ
						ParametrosExpC1: Alias do arquivo a ser pesquisado                    
						          ExpC2: Campo origem da chave utilizada como pesquisa        
						                 Se for mais de um campo deve ser passado como NIL ou 
						                 branco                                               
						          ExpC3: Prefixo da pesquisa para verificar duplicidade (deve 
						           ser utilizado quando o campo principal no  o primeiro    
						           do indice utilizado para a pesquisa ).                     
						          ExpC4: Campo principal da chave (caso seja encontrada       
						           duplicidade  esse o valor que sera incrementado).         
						          ExpC5: Complemento da pesquisa para verificar duplicidade   
						           (deve ser utilizado quando o campo principal no  a unica 
						           informao do indice utilizado para a pesquisa ).          
						          ExpN1: Ordem de pesquisa                                    
						Ĵ
						Retorno    cChave := Conteudo atualizado do campo principal da Chave  
						Ĵ
						Uso       Generico                                                    
						ٱ
						
						
						*/
					Function VldChavUni(cAlias,cCampo,cPrefixo,cChave,cComplemento,nOrder)
						Local aAreaAnt			:= GetArea()
						Local aAreaAlias		:= {}
						Local cMay				:= cAlias+Alltrim(xFilial(cAlias))
						Local nTamanho			:= If(ValType(cCampo)=='C'.And.!Empty(cCampo),TamSx3(cCampo)[1],Len(cChave))
						DEFAULT nOrder  		:= 1
						DEFAULT cPrefixo		:= ''
						DEFAULT cComplemento	:= ''
						If ValType(cAlias)=='C' .And. !Empty(cAlias)
							dbSelectArea(cAlias)
							aAreaAlias:=GetArea()
							dbSetOrder(nOrder)
							While (DbSeek(xFilial(cAlias)+cPrefixo+cChave+cComplemento) .or. !MayIUseCode(cMay+cPrefixo+cChave+cComplemento))
								cChave := Soma1(cChave,nTamanho)
							EndDo
							RestArea(aAreaAlias)
						EndIf
						RestArea(aAreaAnt)
						RETURN cChave

						/*/
						
						
						Ŀ
						Funcao    fUpdateEntAutor  Eduardo Riera           Data 13.08.2003
						Ĵ
						Descrio Funcao de atualizacao da tabela de entidades                
						Ĵ
						ParametrosExpC1: Codigo da Pessoa                                     
						          ExpC2: Alias da Entidade                                    
						          ExpC3: Chave da Entidade                                    
						          ExpC4: Indice de pesquisa para entidade                     
						          ExpC5: Codigo da Empresa                                    
						          ExpC6: Codigo da Filial                                     
						Ĵ
						Retorno   ExpL1: lUpdateEnt                                           
						Ĵ
						Uso       Generico                                                    
						ٱ
						
						/*/
					Function fUpdateEnt( cPessoa , cEntidade , cChaveEntidade , nIndice , cEmp , cFil )

						Local nRDZOrder		:= RDZ->( IndexOrd() )
						Local lUpdateEnt	:= .T.

						Local cRDZFil
						Local cKeyAux
						Local lAddNew

						DEFAULT nIndice := GetRdzIndRel( cEntidade )
						DEFAULT cEmp	:= cEmpAnt
						DEFAULT cFil	:= cFilAnt

						cFil := xFilial( cEntidade , cFil )

						Begin Sequence

							/*
							Ŀ
							Verificacao a operacao e atualiza os dados                              
							*/
							RDZ->( dbSetOrder( RetOrdem( "RDZ" , "RDZ_FILIAL+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA+RDZ_CODENT+RDZ_CODRD0" ) ) )
							cRDZFil := xFilial( "RDZ" , cFil )
							IF RDZ->( MsSeek( cRDZFil + cEmp + cFil + cEntidade + cChaveEntidade , .F. ) )
								cKeyAux := AllTrim(cChaveEntidade)
								While RDZ->(;
										!Eof() 										.and.;
										( RDZ_FILIAL 			== cRDZFil 		)	.and.;
										( RDZ_EMPENT			== cEmp 		)	.and.;
										( RDZ_FILENT			== cFil			)	.and.;
										( RDZ_ENTIDA			== cEntidade	) 	.and.;
										( AllTrim(RDZ_CODENT)	== cKeyAux 		)		 ;
										)
									IF ( cPessoa <> RDZ->RDZ_CODRD0 )
										IF !( lUpdateEnt := UndoRelRdz( NIL , NIL , NIL , NIL , .F. ) )
											Break
										EndIF
									EndIF
									RDZ->( dbSkip() )
								End While
							EndIF

							IF !Empty( cPessoa )
								lAddNew := !( RDZ->( MsSeek( cRDZFil + cEmp + cFil + cEntidade + cChaveEntidade ) ) )
								RDZ->( RecLock( "RDZ" , lAddNew ) )
								RDZ->RDZ_FILIAL := cRDZFil
								RDZ->RDZ_EMPENT := cEmp
								RDZ->RDZ_FILENT := cFil
								RDZ->RDZ_ENTIDA := cEntidade
								RDZ->RDZ_CODENT := cChaveEntidade
								RDZ->RDZ_CODRD0 := cPessoa
								RDZ->RDZ_ENTIND := StrZero( nIndice , GetSx3Cache( "RDZ_ENTIND" , "X3_TAMANHO" ) )
								RDZ->( MsUnLock() )
							EndIF

						End Sequence

						RDZ->( dbSetOrder( nRDZOrder ) )

						Return( lUpdateEnt )

						/*/
						
						
						Ŀ
						Funcao    fUpdateRelAutor  Eduardo Riera      V.I  Data 13.08.2003
						                           Marinaldo de Jesus V.II Data 04/02/2004
						Ĵ
						Descrio Funcao de atualizacao da tabela de entidades                
						Ĵ
						Parametros<vide parametros formais>                                   
						Ĵ
						Retorno   ExpL1: .T.                                                  
						Ĵ
						Uso       Generico                                                    
						ٱ
						
						/*/
					Function fUpdateRel(	cPessoa 		,;	//01 -> RD0_CODIGO
						cEmp			,;	//02 -> Codigo da Empresa
						cFil			,;	//03 -> Codigo da Filial
						aBeforeUpd		,;	//04 -> Array com as Entidade para o Before Update
						aLaterUpd		,;	//05 -> Array com as Entidades  para o Later Update
						lUpdMemVar		,;	//06 -> Se ira atualizar variaveis de memoria
						cMemVarAlias 	,;	//07 -> Alias das variaveis de memoria
						aRelation		 ;	//08 -> Array com as Estruturas para o Update
						)

						Local aArea    		:= GetArea()
						Local aAreaRD0 		:= RD0->(GetArea())
						Local cSvEmpAnt  	:= cEmpAnt
						Local cSvFilAnt  	:= cFilAnt
						Local lOk			:= .F.
						Local nX       		:= 0

						Local cEmpEnt
						Local cFilEnt
						Local cFieldRd0
						Local cFieldEnt
						Local cLinha
						Local cEntidade
						Local cRDZFil
						Local cMemVar
						Local lOpenNew
						Local nOrder
						Local nSvOrder
						Local nY
						Local nZ

						DEFAULT cEmp			:= cEmpAnt
						DEFAULT cFil			:= cFilAnt
						DEFAULT aBeforeUpd		:= {}
						DEFAULT aLaterUpd		:= {}
						DEFAULT lUpdMemVar		:= .F.
						DEFAULT cMemVarAlias	:= "__cMemVarAlias__"
						DEFAULT aRelation		:= {}

						Begin Sequence

							/*
							Ŀ
							Obtem Informacoes para o Relacionamento                                 
							*/
							IF ( Empty( aRelation ) )
								IF !( lOk := BldArrRdZRel( @aRelation ) )
									Break
								EndIF
							EndIF

							cRDZFil := xFilial("RDZ")

							RDZ->( dbSetorder( RetOrdem( "RDZ" , "RDZ_FILIAL+RDZ_CODRD0+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA" ) ) )

							IF !( RDZ->( MsSeek( cRDZFil + cPessoa + cEmp ) ) )
								Break
							EndIF

							/*
							Ŀ
							Analisa as tabelas a serem atualizadas                                  
							*/
							While RDZ->(	!Eof()							.and. ;
									RDZ_FILIAL == cRDZFil			.and. ;
									RDZ_CODRD0 == cPessoa			.and. ;
									RDZ_EMPENT == cEmp					  ;
									)

								cEntidade	:= RDZ->RDZ_ENTIDA
								cEmpEnt 	:= RDZ->RDZ_EMPENT
								cFilEnt		:= RDZ->RDZ_FILENT

								IF ( lUpdMemVar )
									IF ( cEntidade <> cMemVarAlias )
										RDZ->( dbSkip() )
										Loop
									EndIF
								EndIF

								lOpenNew	:= .F.
								IF !( EqualFullName( cEntidade , cEmpEnt , cEmp ) )
									nSvOrder	:= ( cEntidade )->( IndexOrd() )
									nOrder 		:= Val( RDZ->RDZ_ENTIND )
									IF !( lOpenNew := EmpChangeTable( cEntidade , cEmpEnt , cEmp , nOrder ) )
										Break
									EndIF
								EndIF

								cFil	:= xFilial( cEntidade , cFilEnt )

								IF !( RDZ->( MsSeek( cRDZFil + cPessoa + cEmp + cFil + cEntidade ) ) )
									RDZ->( dbSkip() )
									Loop
								EndIF

								While RDZ->(	!Eof()							.and. ;
										RDZ_FILIAL == cRDZFil			.and. ;
										RDZ_CODRD0 == cPessoa			.and. ;
										RDZ_EMPENT == cEmp				.and. ;
										RDZ_FILENT == cFil				.and. ;
										RDZ_ENTIDA == cEntidade				  ;
										)

									cFilAnt := RDZ->RDZ_FILENT

									IF ( ( lUpdMemVar ) .or. ( cEntidade )->( MsSeek( RDZ->RDZ_CODENT , .F. ) ) ) //RDZ_CODENT devera ser formado pela Filial + Codigo

										nX := aScan( aRelation , { |x| ( x[ 01 ] == cEntidade ) } )

										IF ( nX > 0 )

											nZ := Len( aRelation[ nX , 02 ] )

											IF ( nZ > 0 )

												IF ( aScan( aBeforeUpd , { |x| ( Upper( AllTrim( x ) ) == cEntidade ) } ) > 0 )
													IF ( ValType( aRelation[ nX , 03 ] ) == "B" )
														Eval( aRelation[ nX , 03 ] , cEntidade , aRelation[ nX , 02 ] )
													EndIF
												EndIF

												IF !( lUpdMemVar )
													( cEntidade )->( RecLock( cEntidade , .F. ) )
												EndIF
												For nY := 1 To nZ
													cFieldEnt	:= aRelation[ nX , 02 , nY , 01 ]
													cFieldRd0	:= aRelation[ nX , 02 , nY , 02 ]
													aRelation[ nX , 02 , nY , 03 ]  := ( cEntidade )->( FieldGet( FieldPos( cFieldEnt ) ) )
													aRelation[ nX , 02 , nY , 04 ]	:= RD0->( FieldGet( FieldPos( cFieldRd0 ) ) )
													IF ( lUpdMemVar )
														cMemVar := ( "M->"+cFieldEnt )
														SetMemVar( cMemVar , aRelation[ nX , 02 , nY , 04 ] )
													Else
														( cEntidade )->( FieldPut( FieldPos( cFieldEnt ) , aRelation[ nX , 02 , nY , 04 ] ) )
													EndIF
												Next nY
												IF !( lUpdMemVar )
													( cEntidade )->( MsUnLock() )
												EndIF

												IF ( aScan( aLaterUpd , { |x| ( Upper( AllTrim( x ) ) == cEntidade ) } ) > 0 )
													IF ( ValType( aRelation[ nX , 04 ] ) == "B" )
														Eval( aRelation[ nX , 04 ] , cEntidade , aRelation[ nX , 02 ] )
													EndIF
												EndIF

											EndIF

										EndIF

									EndIF

									RDZ->( dbSkip() )

								End While

								IF ( lOpenNew )
									EmpChangeTable( cEntidade , cEmp , cEmpEnt , nSvOrder )
								EndIF

							End While

						End Sequence

						cEmpAnt := cSvEmpAnt
						cFilAnt := cSvFilAnt

						RestArea(aAreaRD0)
						RestArea(aArea)

						Return( lOk )

						/*
						
						
						Ŀ
						Funcao    EntUpdateRd0 Autor  Marinaldo de Jesus      Data 03/02/2004
						Ĵ
						Descrio Insert/Update das Entidades para o RD0                         
						Ĵ
						Parametros<vide parametros formais>                                      
						Ĵ
						Retorno   lOk                                                            
						Ĵ
						Uso       Generico                                                       
						ٱ
						
						/*/
					Function EntUpdateRd0(	cRd0Codigo		,;	//01 -> Codigo da Pessoa
						cEntidade		,;	//02 -> Entidade Relacionada
						cChaveEntidade	,;	//03 -> Chave da Entidade
						nOrderEnt		,;	//04 -> Ordem
						nRecnoEnt		,;	//05 -> Recno da Entidade
						cEmp			,;	//06 -> Codigo da Empresa
						cFil			,;	//07 -> Codigo da Filial
						cRd0Tipo		,;	//08 -> Conteudo para o RD0_TIPO "1"=Interno;"2"=Externo
						lUpdateRel		,;	//09 -> Se Atualiza as Entidades Relacionadas
						aBeforeUpd		,;	//10 -> Array com as Entidades para o Before Update
						aLaterUpd		,;	//11 -> Array com as Entidades para o Later Update
						aRelation		 ;	//12 -> Array com as Estruturas para o Update
						)

						Local aArea			:= GetArea()
						Local aAreaRD0		:= RD0->( GetArea() )
						Local cSvEmpAnt 	:= cEmpAnt
						Local cSvFilAnt 	:= cFilAnt
						Local cSvArqTab		:= cArqTab

						Local aGetRd0
						Local aAreaEnt
						Local cFieldEnt
						Local cFieldRd0
						Local cRd0Filial
						Local lOk
						Local lAddNew
						Local lEqualFullName
						Local lTransfEmp	:= ""
						Local nX
						Local nY
						Local nZ
						Local nRd0Order
						Local uConteudo

						DEFAULT cEmp 		:= cEmpAnt
						DEFAULT cFil 		:= cFilAnt
						DEFAULT nOrderEnt	:= GetRdzIndRel( cEntidade )

						Begin Sequence

							DEFAULT aRelation	:= {}
							IF ( Empty( aRelation ) )
								IF !( lOk := BldArrRdZRel( @aRelation ) )
									Break
								EndIF
							EndIF

							nX := aScan( aRelation , { |x| Upper( AllTrim( x[1] ) ) == Upper( AllTrim( cEntidade ) ) } )
							IF !( lOk := ( nX > 0 ) )
								Break
							EndIF

							IF !( lOk :=( ( nZ := Len( aRelation[ nX , 02 ] ) ) > 0 ) )
								Break
							EndIF

							IF !( lOk := !Empty( nOrderEnt ) )
								Break
							EndIF

							aAreaEnt := ( cEntidade )->( GetArea() )
							IF Empty( nRecnoEnt )
								( cEntidade )->( dbSetOrder( nOrderEnt ) )
								IF !( lOk := ( ( cEntidade )->( MsSeek( cChaveEntidade , .F. ) ) ) )
									Break
								EndIF
								nRecnoEnt := ( cEntidade )->( Recno() )
							EndIF

							lEqualFullName := EqualFullName( "RD0" , cEmp , cEmpAnt )

							EmpChangeTable( "RD0" , cEmp , cEmpAnt , 1 )
							EmpChangeTable( "RDZ" , cEmp , cEmpAnt , 1 )

							cEmpAnt := cEmp
							cFilAnt := cFil

							lTransfEmp	:= IsInCallStack("GPEA180") .And. cSvEmpAnt != cEmp

							If !lTransfEmp
								IF !( ExistePessoa( cEntidade , cChaveEntidade , cEmp , cFil , .T. ) )
									IF Empty( cRd0Codigo )
										IF ( lEqualFullName )
											aGetRd0 := GetRd0Codigo( cEmp , cFil , .F. )
											IF !( lOk := aGetRd0[1] )
												Break
											EndIF
											cRd0Codigo	:= aGetRd0[2]
										Else
											aGetRd0 := StartJob( "GetRD0Codigo" , GetEnvServer() , .T. , cEmp , cFil , .T. )
											IF !( lOk := aGetRd0[1] )
												Break
											EndIF
											cRd0Codigo	:= aGetRd0[2]
										EndIF
									EndIF
								Else
									IF Empty( cRd0Codigo )
										cRd0Codigo := fGetPessoa( cEntidade , cChaveEntidade , cEmp , cFil )
									EndIF
								EndIF
							EndIf

							nRd0Order := RetOrdem( "RD0" , "RD0_FILIAL+RD0_CODIGO" )
							RD0->( dbSetOrder( nRd0Order ) )

							cRd0Filial	:= xFilial("RD0")
							lAddNew 	:= !( RD0->( dbSeek( cRd0Filial + cRd0Codigo , .F. ) ) )
							If !lAddNew .And. lTransfEmp
								lAddNew := MsgNoYes( OemToAnsi(STR0002), OemToAnsi(STR0001) )//"Participante j existente. Clique em 'No' para atualizar o atual ou em 'Sim' para criar um novo participante"###"Ateno"
								If lAddNew
									IF ( lEqualFullName )
										aGetRd0 := GetRd0Codigo( cEmp , cFil , .F. )
										IF !( lOk := aGetRd0[1] )
											Break
										EndIF
										cRd0Codigo	:= aGetRd0[2]
									Else
										aGetRd0 := StartJob( "GetRD0Codigo" , GetEnvServer() , .T. , cEmp , cFil , .T. )
										IF !( lOk := aGetRd0[1] )
											Break
										EndIF
										cRd0Codigo	:= aGetRd0[2]
									EndIF
								EndIf
							EndIf
							RecLock( "RD0" , lAddNew )

							DEFAULT cRd0Tipo	:= "1"

							( cEntidade )->( MsGoto( nRecnoEnt ) )
							RD0->( FieldPut( FieldPos( "RD0_FILIAL" )	, cRd0Filial	) )
							RD0->( FieldPut( FieldPos( "RD0_CODIGO" )	, cRd0Codigo	) )
							RD0->( FieldPut( FieldPos( "RD0_TIPO"   )	, cRd0Tipo		) )
							For nY := 1 To nZ
								cFieldEnt	:= aRelation[ nX , 2 , nY , 1 ]
								uConteudo	:= ( cEntidade )->( FieldGet( FieldPos( cFieldEnt ) ) )
								If(cFieldEnt == "RA_EMAIL",uConteudo:=upper(uConteudo),)
									cFieldRd0	:= aRelation[ nX , 2 , nY , 2 ]
									If FunName() == "APDA020" .And. cEntidade == "SRA" .And. SRA->RA_CATFUNC == "A"
										If !Empty(uConteudo) .and. Empty( RD0->( FieldGet( FieldPos( cFieldRd0 ) ) ) )
											RD0->( FieldPut( FieldPos( cFieldRd0 ) , uConteudo ) )
										EndIf
									Else
										RD0->( FieldPut( FieldPos( cFieldRd0 ) , uConteudo ) )
									EndIf
								Next nY
								RD0->( MsUnLock() )

								//-- Posiciona no SRA para gravar o RDZ (Relacionamento)
								If cEntidade == "SRA"
									IF !GotoNextRecno( cEntidade , nRecnoEnt , nOrderEnt )
										Break
									EndIF
									cChaveEntidade		:= (cEntidade) -> ( &(GetRdzKeyRel( cEntidade )) )
								Endif

								IF !( fUpdateEnt( cRd0Codigo , cEntidade , cChaveEntidade , nOrderEnt , cEmp , cFil ) )
									Break
								EndIF

								DEFAULT lUpdateRel := .T.
								IF ( lUpdateRel )
									fUpdateRel(	cRd0Codigo 		,;	//01 -> RD0_CODIGO
									cEmp			,;	//02 -> Codigo da Empresa
									cFil			,;	//03 -> Codigo da Filial
									aBeforeUpd		,;	//04 -> Array com as Entidade para o Before Update
									aLaterUpd		,;	//05 -> Array com as Entidades  para o Later Update
									.F.				,;	//06 -> Se ira atualizar variaveis de memoria
									NIL			 	,;	//07 -> Alias das variaveis de memoria
									aRelation		 ;	//08 -> Array com as Estruturas para o Update
									)
								EndIF

							End Sequence

							EmpChangeTable( "RD0" , cSvEmpAnt , cEmpAnt , 1 )
							EmpChangeTable( "RDZ" , cSvEmpAnt , cEmpAnt , 1 )
							cEmpAnt := cSvEmpAnt
							cFilAnt := cSvFilAnt
							cArqTab	:= cSvArqTab

							IF !Empty( aAreaEnt )
								RestArea( aAreaEnt )
							EndIF
							RestArea( aAreaRD0 )
							RestArea( aArea )

							Return( lOk )

							/*
							
							
							Ŀ
							Funcao    GetRd0Codigo Autor  Marinaldo de Jesus      Data 16/02/2004
							Ĵ
							Descrio Obtem Codigo Exclusivo para o RD0                              
							Ĵ
							Parametros<vide parametros formais>                                      
							Ĵ
							Retorno   lOk                                                            
							Ĵ
							Uso       Generico                                                       
							ٱ
							
							/*/
						Function GetRd0Codigo( cEmp , cFil , lRpcSet )

							Local cRd0Codigo
							Local lOk
							Local nGetSX8Len

							DEFAULT lRpcSet	:= .F.

							IF ( lRpcSet )
								RpcSetType( 3 )
								RpcSetEnv( cEmp , cFil )
							EndIF

							nGetSX8Len	:= GetSX8Len()
							lOk			:= Rd0GetCodigo( @cRd0Codigo , .F. )

							While ( GetSX8Len() > nGetSX8Len )
								ConfirmSX8()
							End While

							Return( { lOk , cRd0Codigo } )

							/*/
							
							
							Ŀ
							Funcao    BldArrRdZRelAutorMarinaldo de Jesus      Data 04/02/2004
							Ĵ
							Descrio Monta Array com os Relacionamentos                          
							Ĵ
							Parametros                                                            
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function BldArrRdZRel( aRelation )

							Local cFile	:= GetIniRdzRel()

							Local aFileInfo
							Local cEntidade
							Local cFieldEnt
							Local cFieldRd0
							Local cFirstByte
							Local nX
							Local nY

							Local lOk

							Static __aLastRelation__
							Static __aLastFileInfo__

							Begin Sequence

								DEFAULT __aLastFileInfo__	:= Directory( cFile , "A" )

								IF !( lOk := !Empty( __aLastFileInfo__ ) )
									Break
								EndIF

								aFileInfo	:= Directory( cFile , "A" )

								IF !Empty( aFileInfo )
									IF !( fCompArray( __aLastFileInfo__ , aFileInfo ) )
										__aLastFileInfo__ := aClone( aFileInfo )
										__aLastRelation__ := {}
									EndIF
								EndIF

								DEFAULT __aLastRelation__ := {}
								IF !( lOk := !Empty( __aLastRelation__ ) )
									IF !( lOk := File( cFile ) )
										Break
									EndIF
								Else
									aRelation := aClone( __aLastRelation__ )
									Break
								EndIF

								nX := 0
								fT_fUse( cFile )
								fT_fGotop()
								While ( !fT_fEof() )
									IF Empty( cLinha := Upper( AllTrim( fT_fReadLn() ) ) )
										fT_fSkip()
										Loop
									EndIF
									cFirstByte := SubStr( cLinha , 1 , 1 )
									IF ( cFirstByte == "[" )	//Alias ( Entidade Relacionada )
										cEntidade := SubStr( cLinha , 2 , 3 )
										aAdd( __aLastRelation__ , { cEntidade , {} , NIL , NIL , NIL } )
										++nX
									ElseIF ( cFirstByte == "#" )	//bBeforeUpd
										IF ( SubStr( cLinha , 2 , 1 ) == "{" ) .and. ;
												( SubStr( cLinha , -1 ) == "}" )
											IF ( ( nY := At( "|" , cLinha ) ) > 0 )
												IF ( At( "|" , SubStr( cLinha , nY + 1 ) ) > 0 )
													__aLastRelation__[nX,3] := &( cLinha )
												EndIF
											EndIF
										EndIF
									ElseIF ( cFirstByte == "@" )	//bLaterUpd
										IF ( SubStr( cLinha , 2 , 1 ) == "{" ) .and. ;
												( SubStr( cLinha , -1 ) == "}" )
											IF ( ( nY := At( "|" , cLinha ) ) > 0 )
												IF ( At( "|" , SubStr( cLinha , nY + 1 ) ) > 0 )
													__aLastRelation__[ nX , 4 ] := &( cLinha )
												EndIF
											EndIF
										EndIF
									ElseIF ( cFirstByte == "!" )	//Chave de Relacionamento
										__aLastRelation__[ nX , 5 ] := SubStr( cLinha , 2 )
									Else									//Fields ( Campos Relacionados )
										IF ( ( nY := At( "=" , cLinha ) ) == 0 )
											fT_fSkip()
											Loop
										EndIF
										cFieldRd0 := SubStr( cLinha , nY+1 )
										IF ( RD0->( FieldPos( cFieldRd0 ) ) == 0 )
											fT_fSkip()
											Loop
										EndIF
										cFieldEnt := SubStr( cLinha , 1 , nY-1 )
										IF ( ( cEntidade )->( FieldPos( cFieldEnt ) ) == 0 )
											fT_fSkip()
											Loop
										EndIF
										aAdd( __aLastRelation__[ nX , 2 ] , { cFieldEnt , cFieldRd0 , NIL , NIL } )
									EndIF
									fT_fSkip()
								End While
								fT_fUse()

								aRelation := aClone( __aLastRelation__ )

								lOk := ( Len( aRelation ) > 0 )

							End Sequence

							Return( lOk )

							/*/
							
							
							Ŀ
							Funcao    GetRdzKeyRelAutorMarinaldo de Jesus      Data 16/08/2004
							Ĵ
							Descrio Retorna a Chave de Relacionamento das Entidades com o RDZ   
							Ĵ
							ParametroscEntidade -> Entidade Relacionada                           
							Ĵ
							Retorno   cGetRdZKeyRel                                               
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function GetRdzKeyRel( cEntidade )

							Local cGetRdzKeyRel	:= ""

							Local aRelation
							Local nEntidade

							IF ( BldArrRdZRel( @aRelation ) )
								cEntidade	:= Upper( AllTrim( cEntidade ) )
								nEntidade	:= aScan( aRelation , { |x| x[ 1 ] == cEntidade } )
								IF ( nEntidade > 0 )
									cGetRdzKeyRel := aRelation[ nEntidade , 5 ]
								EndIF
							EndIF

							Return( cGetRdzKeyRel )

							/*/
							
							
							Ŀ
							Funcao    GetRdzIndRelAutorMarinaldo de Jesus      Data 16/08/2004
							Ĵ
							Descrio Retorna o Numero da Ordem de Relacionamento das Entidades   
							Ĵ
							ParametroscEntidade -> Entidade Relacionada                           
							Ĵ
							Retorno   nOrder													  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function GetRdzIndRel( cEntidade )
							DEFAULT cEntidade := ""
							Return( RetOrdem( cEntidade , GetRdzKeyRel( cEntidade ) , .T. )  )

							/*/
							
							
							Ŀ
							Funcao    GetIniRdzRelAutorMarinaldo de Jesus      Data 03/02/2004
							Ĵ
							Descrio Retorna Arquivo valido para o Relacionamento entre o RD0   e
							          as Demais Entidades										  
							Ĵ
							Parametros                                                            
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function GetIniRdzRel()
							Return( "MSRELRDZ.INI" )

							/*/
							
							
							Ŀ
							Funcao    fGetPessoaAutor  Eduardo Riera           Data 28.11.2003
							Ĵ
							Descrio Funcao de recuperacao do codigo da pessoa amarrada a Entid. 
							Ĵ
							ParametrosExpC1: Codigo da Entidade                                   
							          ExpC2: Chave da Entidade                                    
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function fGetPessoa( cEntidade , cChaveEntidade , cEmp , cFil , lPosicione )

							Local cRd0Codigo
							Local nRd0SvOrd
							Local nRDZsvOrd

							DEFAULT cEmp 		:= cEmpAnt
							DEFAULT cFil 		:= cFilAnt
							DEFAULT lPosicione	:= .T.

							cFil := xFilial( cEntidade , cFil )

							nRDZsvOrd := RDZ->( IndexOrd() )
							RDZ->( dbSetOrder( RetOrdem( "RDZ" , "RDZ_FILIAL+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA+RDZ_CODENT+RDZ_CODRD0" ) ) )
							IF ( RDZ->( !MsSeek( xFilial( "RDZ" ) + cEmp + cFil + cEntidade + cChaveEntidade ) ) )
								RDZ->( MsGoto( 0 ) )
							EndIF
							RDZ->( dbSetOrder( nRDZsvOrd ) )

							cRd0Codigo := RDZ->RDZ_CODRD0

							IF ( lPosicione )
								nRd0SvOrd := RD0->( IndexOrd() )
								RD0->( dbSetOrder( RetOrdem( "RD0" , "RD0_FILIAL+RD0_CODIGO" ) ) )
								RD0->( MsSeek( xFilial( "RD0" , cFil ) + cRd0Codigo , .F. ) )
								RD0->( dbSetOrder( nRd0SvOrd ) )
							EndIF

							Return( cRd0Codigo )

							/*/
							
							
							Ŀ
							Funcao    ExistePessoa AutorMarinaldo de Jesus     Data 03/02/2004
							Ĵ
							Descrio Verifica se Existe Relacionamento                           
							Ĵ
							ParametrosExpC1: Codigo da Entidade                                   
							          ExpC2: Chave da Entidade                                    
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function ExistePessoa( cEntidade , cChaveEntidade , cEmp , cFil , lPosicione )
							Return( !Empty( fGetPessoa( cEntidade , cChaveEntidade , cEmp , cFil , lPosicione ) ) )

							/*/
							
							
							Ŀ
							Funcao    RdzExisteRel AutorMarinaldo de Jesus     Data 03/02/2004
							Ĵ
							Descrio Verifica se Existe Relacionamento                           
							Ĵ
							ParametrosExpC1: Codigo da Entidade                                   
							          ExpC2: Codigo do RD0                                        
							          ExpC3: Codigo da Empresa                                    
							          ExpC4: Codigo da Filial                                     
							          ExpL5: Se posiciona o Recno                                 
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function RdzExisteRel( cEntidade , cRd0Codigo , cEmp , cFil , lPosicione )

							Local nRd0SvOrd
							Local nRDZsvOrd
							Local nEntOrd
							Local nEntSvOrd
							Local lExisteRel
							Local lSeekRel		:= .F.
							Local aNoFilEnt		:= {}

							DEFAULT cEmp		:= cEmpAnt
							DEFAULT cFil		:= cFilAnt
							DEFAULT lPosicione	:= .T.

							cFil		:= xFilial( cEntidade , cFil )
							nRDZsvOrd	:= RDZ->( IndexOrd() )
							RDZ->( dbSetOrder( RetOrdem( "RDZ" , "RDZ_FILIAL+RDZ_CODRD0+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA" ) ) )

							aAdd( aNoFilEnt, "SRA" ) //Array com tabelas que utilizam pesquisa RDZ_FILIAL+RDZ_CODRD0+RDZ_EMPENT

							lSeekRel := ( aScan( aNoFilEnt, { |Ent| Ent == cEntidade } ) > 0 ) //Verifica se tabela usa pesquisa especifica

							IF ( lExisteRel := RetRDZSeek( cRd0Codigo, cEmp, cFil, cEntidade, lSeekRel ) )

								IF ( lPosicione )
									nRd0SvOrd := RD0->( IndexOrd() )
									RD0->( dbSetOrder( RetOrdem( "RD0" , "RD0_FILIAL+RD0_CODIGO" ) ) )
									RD0->( MsSeek( xFilial( "RD0" , cFil ) + cRd0Codigo , .F. ) )
									RD0->( dbSetOrder( nRd0SvOrd ) )
									nEntOrd := GetRdzIndRel( cEntidade )
									IF ( nEntOrd == 0 )
										nEntOrd := ( cEntidade )->( Val( RDZ->RDZ_ENTIND ) )
									EndIF
									( cEntidade)->( dbSetOrder( nEntOrd ) )
									( cEntidade )->( MsSeek( RDZ->RDZ_CODENT , .F. ) )
									( cEntidade)->( dbSetOrder( nEntSvOrd ) )
								EndIF
							EndIF
							RDZ->( dbSetOrder( nRDZsvOrd ) )

							Return( lExisteRel )

							/*/
							
							
							Ŀ
							Funcao    EntExisteRel AutorMarinaldo de Jesus     Data 04/02/2004
							Ĵ
							Descrio Verifica se Existe Relacionamento                           
							Ĵ
							ParametrosExpC1: Codigo da Entidade                                   
							          ExpC2: Chave da Entidade                                    
							          ExpC3: Codigo da Empresa                                    
							          ExpC4: Codigo da Filial                                     
							          ExpL5: Se posiciona o Recno                                 
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function EntExisteRel( cEntidade , cChaveEntidade , cEmp , cFil , lPosicione )

							Local cKeyRel
							Local nRd0SvOrd
							Local nRDZsvOrd

							Local lExisteRel

							DEFAULT cEmp		:= cEmpAnt
							DEFAULT cFil		:= cFilAnt
							DEFAULT lPosicione	:= .T.

							cFil		:= xFilial( cEntidade , cFil )
							nRDZsvOrd	:= RDZ->( IndexOrd() )
							RDZ->( dbSetOrder( RetOrdem( "RDZ" , "RDZ_FILIAL+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA+RDZ_CODENT+RDZ_CODRD0" ) ) )
							cKeyRel	:= ( xFilial("RDZ") + cEmp + cFil + cEntidade + cChaveEntidade )
							IF ( lExisteRel := RDZ->( MsSeek( cKeyRel , .F. ) ) )
								IF ( lPosicione )
									nRd0SvOrd := RD0->( IndexOrd() )
									RD0->( dbSetOrder( RetOrdem( "RD0" , "RD0_FILIAL+RD0_CODIGO" ) ) )
									RD0->( MsSeek( xFilial( "RD0" , cFil ) + RDZ->RDZ_CODRD0 , .F. ) )
									RD0->( dbSetOrder( nRd0SvOrd ) )
								EndIF
							EndIF
							RDZ->( dbSetOrder( nRDZsvOrd ) )

							Return( lExisteRel )

							/*/
							
							
							Ŀ
							Funcao    UndoRelRdz   AutorMarinaldo de Jesus     Data 03/02/2004
							Ĵ
							Descrio Desfaz Relacionamento no RDZ                                
							Ĵ
							ParametrosExpC1: Codigo da Entidade                                   
							          ExpC2: Codigo do RD0                                        
							          ExpC3: Codigo da Empresa                                    
							          ExpC4: Codigo da Filial                                     
							          ExpL5: Posicionar ou Nao                                    
							          ExpC6: Mensagem de Erro                                     
							Ĵ
							Retorno   ExpL1: lUnDoOk                                              
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function UndoRelRdz( cEntidade , cRd0Codigo , cEmp , cFil , lPosicione , cMsgErr )

							Local lUnDoOk		:= .T.

							DEFAULT cEmp		:= cEmpAnt
							DEFAULT cFil		:= cFilAnt
							DEFAULT lPosicione	:= .T.

							Begin Sequence

								cFil := xFilial( cEntidade , cFil )

								IF ( lPosicione )
									IF !( lUnDoOk := RdzExisteRel( cEntidade , cRd0Codigo , cEmp , cFil , .T. ) )
										Break
									EndIF
								EndIF

								IF !( lUnDoOk := ( RDZ->( RecLock( "RDZ" , .F. ) ) ) )
									Break
								EndIF

								IF !( lUnDoOk := RDZ->( FkDelete( @cMsgErr ) ) )
									RDZ->( RollBackDelTran( cMsgErr ) )
								EndIF

								RDZ->( MsUnLock() )

							End Sequence

							Return( lUnDoOk )

							/*/
							
							
							Ŀ
							Funcao    EntGetInfo   AutorMarinaldo de Jesus     Data 11/08/2004
							Ĵ
							Descrio Obtem Informacoes de campos de Entidade Relacionadas com   o
							          RD0 atraves do RDZ										  
							Ĵ
							ParametrosExpC1: Codigo da Entidade                                   
							          ExpC2: Nome do Campo                                        
							          ExpC3: Codigo do RD0                                        
							          ExpC4: Codigo da Empresa                                    
							          ExpC5: Codigo da Filial                                     
							Ĵ
							Retorno   ExpU1: Conteudo do Campo conforme ExpC2                     
							Ĵ
							Uso       Generico                                                    
							ٱ
							/*/
						Function EntGetInfo( cEntidade , uCpoGetInfo , cRd0Codigo , cEmp , cFil )

							Local cSx3Tipo
							Local cCpoGetInfo
							Local lCpoIsArray
							Local nEntOrder
							Local nEntSvOrder
							Local nField
							Local nFields
							Local nFieldPos
							Local uReturn

							DEFAULT uCpoGetInfo	:= StrToArray( GetRdzKeyRel( cEntidade ) , "+" )
							DEFAULT cRd0Codigo	:= RD0->RD0_CODIGO
							DEFAULT cEmp		:= cEmpAnt
							DEFAULT cFil		:= cFilAnt

							IF ( lCpoIsArray := ( ValType( uCpoGetInfo ) == "A" ) )
								uReturn := Array( ( nFields := Len( uCpoGetInfo ) ) )
							Else
								cCpoGetInfo := uCpoGetInfo
							EndIF

							IF RdzExisteRel( cEntidade , cRd0Codigo , cEmp , cFil , .T. )
								nEntSvOrder	:= ( cEntidade )->( IndexOrd() )
								nEntOrder	:= GetRdzIndRel( cEntidade )
								IF ( nEntOrder == 0 )
									nEntOrder := ( cEntidade )->( Val( RDZ->RDZ_ENTIND ) )
								EndIF
								( cEntidade )->( dbSetOrder( nEntOrder ) )
								IF ( cEntidade )->( MsSeek( RDZ->RDZ_CODENT , .F. ) )
									IF !( lCpoIsArray )
										cSx3Tipo := GetSx3Cache( Upper( AllTrim( cCpoGetInfo ) ) , "X3_TIPO" )
										IF ( cSx3Tipo <> NIL )
											IF ( ( nFieldPos := ( cEntidade )->( FieldPos( cCpoGetInfo ) ) ) > 0 )
												uReturn := ( cEntidade )->( FieldGet( nFieldPos ) )
											Else
												uReturn := CriaVar( cCpoGetInfo , .T. , NIL , .F. )
											EndIF
										EndIF
									Else
										For nField := 1 To nFields
											cCpoGetInfo		 := uCpoGetInfo[ nField ]
											cSx3Tipo		 := GetSx3Cache( Upper( AllTrim( cCpoGetInfo ) ) , "X3_TIPO" )
											IF ( cSx3Tipo <> NIL )
												IF ( ( nFieldPos := ( cEntidade )->( FieldPos( cCpoGetInfo ) ) ) > 0 )
													uReturn[ nField ] := ( cEntidade )->( FieldGet( nFieldPos ) )
												Else
													uReturn[ nField ] := CriaVar( cCpoGetInfo , .T. , NIL , .F. )
												EndIF
											EndIF
										Next nField
									EndIF
								EndIF
								( cEntidade )->( dbSetOrder( nEntSvOrder ) )
							Else
								IF !( lCpoIsArray )
									cSx3Tipo := GetSx3Cache( Upper( AllTrim( cCpoGetInfo ) ) , "X3_TIPO" )
									IF ( cSx3Tipo <> NIL )
										uReturn	 := CriaVar( cCpoGetInfo , .F. , NIL , .F. )
									EndIF
								Else
									For nField := 1 To nFields
										cCpoGetInfo		 := uCpoGetInfo[ nField ]
										cSx3Tipo		 := GetSx3Cache( Upper( AllTrim( cCpoGetInfo ) ) , "X3_TIPO" )
										IF ( cSx3Tipo <> NIL )
											uReturn[ nField ] := CriaVar( cCpoGetInfo , .F. , NIL , .F. )
										EndIF
									Next nField
								EndIF
							EndIF

							Return( uReturn )

							/*/
							
							
							Ŀ
							Funcao    EqualFullNameAutorMarinaldo de Jesus     Data 06/02/2004
							Ĵ
							Descrio Verifica se a Tabela e Compartilhada entre empresas         
							Ĵ
							Parametros                                                            
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function EqualFullName( cAlias , c1aEmp , c2aEmp )
							Return( ( RetFullName( cAlias , c1aEmp ) == RetFullName( cAlias , c2aEmp ) ) )

							/*/
							
							
							Ŀ
							Funcao    EmpChangeTableAutorMarinaldo de Jesus    Data 06/02/2004
							Ĵ
							Descrio Abre Tabelas de Outra empresa com o Mesmo alias             
							Ĵ
							Parametros                                                            
							Ĵ
							Retorno   ExpL1: .T.                                                  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function EmpChangeTable( cAlias , cNewEmp , cAtuEmp , nOrder )

							Local lChange	:= .T.

							Local cModo
							Local nAT

							Begin Sequence

								IF !( lChange := !( EqualFullName( cAlias , cNewEmp , cAtuEmp ) ) )
									Break
								EndIF

								IF ( lChange := ( cNewEmp == cAtuEmp ) )
									Break
								EndIF

								IF !( lChange := EmpOpenFile( cAlias , cAlias , nOrder , .T. , cNewEmp , @cModo ) )
									Break
								EndIF

								nAT := AT( cAlias , cArqTab )
								IF ( nAT > 0 )
									cArqTab := ( SubStr( cArqTab , 1 , nAT+2 ) + cModo + SubStr( cArqTab , nAT + 4 ) )
								Else
									cArqTab += ( cAlias+cModo+"/" )
								EndIF

							End Sequence

							Return( lChange )

							/*/
							
							
							Ŀ
							Funcao    Sx3Box2Arr	AutorMarinaldo de Jesus    Data 18/08/2004
							Ĵ
							Descrio Retorna Array com as Opcoes do X3_CBOX					  
							Ĵ
							Parametros                                                            
							Ĵ
							Retorno   Array com as Opcoes do X3_CBOX					    	  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function Sx3Box2Arr( cCpo , aX3cBox )

							Local aSx3BoxArr	:= {}

							Local aSx3Info
							Local nLoop
							Local nLoops

							aSx3Info := PosAlias( "SX3" , cCpo , NIL , { "X3cBox()" , "X3_TAMANHO" } , 2 , .F. )

							IF !Empty( aSx3Info[1] )
								aX3cBox := RetSx3Box( aSx3Info[1] , NIL , NIL , aSx3Info[2] )
							Else
								aX3cBox := {}
							EndIF

							nLoops		:= Len( aX3cBox )
							aSx3BoxArr	:= Array( nLoops )
							For nLoop := 1 To nLoops
								aSx3BoxArr[ nLoop ] := aX3cBox[ nLoop , 1 ]
							Next nLoop

							Return( aSx3BoxArr )

							/*/
							
							
							Ŀ
							Funcao    RetRDZSeek	AutorBruno / Janotas       Data 17/06/2008
							Ĵ
							Descrio Verifica se existe relacao,caso exista verifica as entidades
							Ĵ
							Parametros                                                            
							Ĵ
							Retorno   Registro relacionado								    	  
							Ĵ
							Uso       Generico                                                    
							ٱ
							
							/*/
						Function RetRDZSeek( cRd0Codigo, cEmp, cFil, cEntidade, lSeekRel )

							Local lRetSeek		:= .F.

							DEFAULT lSeekRel	:= .F.

							//Chave de pesquisa padrao
							cKeyRel	:= ( xFilial("RDZ") + cRd0Codigo + cEmp + cFil + cEntidade )

							If lSeekRel

								cKeyRel	:= ( xFilial("RDZ") + cRd0Codigo + cEmp )
								RDZ->( MsSeek( cKeyRel , .F. ) )

								While !RDZ->(Eof()) .And. RDZ->(RDZ_FILIAL+RDZ_CODRD0+RDZ_EMPENT) == cKeyRel

									If cEntidade == RDZ->RDZ_ENTIDA
										lRetSeek := .T.
										Exit
									EndIf

									RDZ->(dbSkip())
								EndDo
							Else

								If RDZ->( MsSeek( cKeyRel , .F. ) )
									lRetSeek := .T.
								EndIf
							EndIf

							Return(lRetSeek)


							/*
							
							
							ͻ
							Rotina    Modulo10  Autor  Mauricio Pequim Jr   Data   18/02/13   
							͹
							Desc.     Calcula o digito verificador de uma sequencia de numeros    
							          baseando-se no modulo 10. Utilizado para verificar o digito 
							          em linhas digitaveis e codigo de barras de concessionarias  
							          de servicos publicos                                        
							͹
							Uso        CodBarVl2                                                  
							ͼ
							
							
							*/
						Function Modulo10( cNum )

							Local cRet := ""

							cRet :=Mod10(cNum)

							Return cRet