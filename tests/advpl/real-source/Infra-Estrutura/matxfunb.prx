#include "protheus.ch"
#include "matxfunb.ch"

Static aFormBatch:={}
Static __cFileLog
Static __aErrAuto	:= {}
Static __CtbFilVld		// Filial para validacao CTB
Static __aCache := {}
Static __aLayCNAB	:= {}
Static __aCTBConta 	:= {}
Static __aCTBCusto 	:= {}
Static __aCTBItem 	:= {}
Static __aCTBClVlr 	:= {}
Static __lUMSMM
Static __lNewJuros
Static __lFJURCST
Static __lFJURREC
Static __lFILEMOT
Static __lGEMJUROS
Static __lE1_NCONTR
Static __aMotRead
Static __lFJURREC
Static __lProcFIN001
Static __lCacheIs

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ DATA   ³ BOPS ³Prograd.³ALTERACAO							  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³16.12.98³XXXXXX³Andreia ³Inclusao da Funcao TEMBXCANC()				  ³±±
±±³04.01.99³XXXXXX³Pilar   ³Acerto do nome da variavel cPicture- TmContab ³±±
±±³06.01.99³19274A³Andreia ³Acerto na funcao FA070JUROS() quando juros	  ³±±
±±³		  ³	   ³		   ³composto.									  ³±±
±±³14.01.99³xxxxxx³RODRIGO ³Incluida funcao A207Um()					  ³±±
±±³22/01/99³META  ³Rodrigo ³Incluida funcao AvalQtdPre					  ³±±
±±³22.01.99³xxxxxA³Pilar   ³Travamento CNAB II							  ³±±
±±³26.01.99³META  ³Rodrigo ³Incluidas funcoes para OPs/SCs Firme/Prevista ³±±
±±³19.02.99³******³Julio   ³Transf. Funcao ConaOk() do ConxFun.prx		  ³±±
±±³19.02.99³XXXXXX³Fernando³Incl.fun‡”es QA_ULTRV, QA_VERNUM, QA_NUMDEC   ³±±
±±³  	     ³	   ³		   ³QA_GRCOD e QA_SEQU do QAXFUN.PRW		  ³±±
±±³20.02.99³XXXXXX³Fernando³Incl.fun‡„o A200SKTE do QIEA200.PRW			  ³±±
±±³20.02.99³XXXXXX³Fernando³Incl.fun‡„o READMOTBX do FINXFUN.PRX. 		  ³±±
±±³15.03.99³xxxxxx³Pilar   ³Estava pulando linha indevida no CNAB2		  ³±±
±±³18.03.99³xxxxxx³Marcelo ³Inclus„o da fun‡„o QA_CHOICE.				  ³±±
±±³22.03.99³META  ³Julio   ³Acrescentar col. Cheque na Tab. Mot.Baixa.	  ³±±
±±³08.04.99³xxxxxx³Vera    ³Exclusao das funcoes do Siga Quality		  ³±±
±±³19.04.99³PROTH.³Julio   ³Melhoria da fun‡„o fa070juros() sem usar 	  ³±±
±±³		  ³	   ³		   ³ErrorBlock(). 								  ³±±
±±³17.07.99³xxxxxx³Wag/Kota³Substituicao da Serial.dll					  ³±±
±±³21.07.99³22934A³CesarVal³Alterar fun‡ao E_FIELD - SIGAEIC p/ 2.06/4.06 ³±±
±±³28.07.99³xxxxxx³Fabio FP³Alterada fun‡ao E_FIELD						  ³±±
±±³12.08.99³xxxxxx³Joly    ³Na MSROTAUTO nao mudar o Indice do SX3 s/ness.³±±
±±³25.08.99³XXXXXX³Mauricio³Reposicionar alias de entrada na TEMBXCANC()  ³±±
±±³25.08.99³23454A³Aline CV³Acerto na funcao Condicao nos Tipo 6 e Tipo 3 ³±±
±±³17.09.99³XXXXXX³Julio W ³Acerto na chave da Funcao TemBxCanc()         ³±±
±±³09.11.99³23514A³Kotaki  ³Inclusao de um PE. para MARLOCK               ³±±
±±³23.11.99³XXXXXX³Fabio R ³VerIficar se existe o Sigaloja.???            ³±±
±±³20.12.99³XXXXXX³Julio W ³Implementa‡„o na Leitura do CNAB II -> Le uma ³±±
±±³        ³      ³        ³linha inteira (at‚ encontrar Chr(13)+Chr(10)) ³±±
±±³22.12.99³226744³Lucas   ³Considerar Remitso SCM/SCN na xCalcEst().     ³±±
±±³26.01.00³XXXXXX³Stiefano³Acerto na xProcedure - AS400                  ³±±
±±³03.02.00³XXXXXX³Mauricio³Acerto na TemBxCan() - Vicente                ³±±
±±³04.02.00³XXXXXX³Sandro  ³Acerto na MSRotAuto,MSVldGAuto,MSVldACAuto    ³±±
±±³04.02.00³XXXXXX³Sandro  ³Inclusao da funcao MSExecAuto()				  ³±±
±±³11.02.00³25504A³Julio W ³Acerto no pulo de Segmento no CNAB II         ³±±
±±³02.03.00³xxxxxx³Sandro  ³Implementaco na funcao condicao para funcionar³±±
±±³        ³      ³        ³sem o cadastro SE4                            ³±±
±±³11.05.00³xxxxxx³Bruno   ³Acertar a CalcEst para entradas e saidas de   ³±±
±±³        ³      ³        ³ localizacoes.                                ³±±
±±³13.07.00³      ³Sandro  ³Inclusao de funcao para mostrar o autoerro.log³±±
±±³        ³      ³        ³na tela                                       ³±±
±±³01.12.00³6931  ³Iuspa   ³ASC2SLD() Obedecendo decimais do X3 (C2_QUANT)³±±
±±³07.02.01³      ³F Garbin³Alteracao da funcao MostraErro, p/ utilizacao ³±±
±±³        ³      ³        ³em caso de JOBs                               ³±±
±±³02.03.01³xxxxxx³Naldo   ³Passagem de Novo Paramentro para fDesc()  para³±±
±±³        ³      ³        ³o tratamento de Filiais.                      ³±±
±±³28.08.01³xxxxxx³Naldo   ³Alterada fDesc() para quando nao for  localiza³±±
±±³        ³      ³        ³da a Chave retornar com Space de nBytes.      ³±±
±±³21.05.02³xxxxxx³Naldo   ³Alterada MsMm() para Destravar os    Registros³±±
±±³        ³      ³        ³travados com RecLock() quando Exclusao de Memo³±±
±±³27.06.02³xxxxxx³Naldo   ³Alterada fDesc() para utilizar MsSeek() ao  in³±±
±±³        ³      ³        ³ves de dbSeek() e passagem de novo   parametro³±±
±±³        ³      ³        ³p/ a Selecao de Ordem						  ³±±
±±³03.09.02³xxxxxx³Naldo   ³Retirada do Teste da Variavel Inclui em fDesc ³±±
±±³08.09.02³xxxxxx³Bruno   ³Desconsiderar Remitso SCM/SCN na xCalcEst().  ³±±
±±³23.12.02³xxxxxx³Naldo   ³Exclusao da Variavel Local lNovo em fDesc().  ³±±
±±³03.04.03³Melhor³Naldo   ³fDesc() podera retornar o conteudo de Qualquer³±±
±±³        ³      ³        ³Campo independente do Tipo.					  ³±±
±±³        ³      ³        ³fDesc() nao precisara mais restaurar a Area de³±±
±±³        ³      ³        ³entrada uma vez que a pesquisa e feita por  re³±±
±±³        ³      ³        ³ferencia de Alias ( cAlias )->( Exp. )		  ³±±
±±³17.10.03³Melhor³Naldo   ³Alterada MsMm para Utilizar Soma1() para obter³±±
±±³        ³      ³        ³a sequencia a  sergravada, utilizar FieldPos()³±±
±±³        ³      ³        ³para verificar a Existencia dos campos,  utili³±±
±±³        ³      ³        ³lizacao de Begin/End Sequence para  padronizar³±±
±±³        ³      ³        ³o retorno, e otimizacao do processo de  verifi³±±
±±³        ³      ³        ³cacao da filial evitando chamada desnecessaria³±±
±±³        ³      ³        ³a xFilial() ( A macro cFilial foi  substituida³±±
±±³        ³      ³        ³por uma variavel que chama a xFilial() uma uni³±±
±±³        ³      ³        ³ca vez), gravar a chave do Memo somente apos a³±±
±±³        ³      ³        ³gravacao de todas as Linhas					  ³±±
±±³17.10.03³Acerto³Naldo   ³Alterada MsMm para Utilizar Soma1() para  veri³±±
±±³        ³      ³        ³ficar corretamente a Linha conforme nLin	  ³±±
±±³20.03.04³Melhor³Naldo   ³Verificar xFilial() em fDesc() apenas para  ar³±±
±±³        ³      ³        ³quivos que possuam _FILIAL                 	  ³±±
±±³26.03.04³Acerto³Naldo   ³Garantir o posicionamento no SX3 na fDesc     ³±±
±±³04.05.07³122616³Norbert ³Incluido tratamento de desconto no calculo de ³±±
±±³        ³      ³        ³juros do titulo na rotina FA070Juros().       ³±±
±±³15.10.12³TFTRE0³Luis    ³Ajuste para verificar se sera gerada (ou nao) ³±±
±±³        ³024091³Artuso  ³linha em branco no arquivo magnetico (CNAB2)  ³±±
±±³        ³  2012³        ³de liquidos.                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Array 	 ³  aProcedure ³ Autor ³ Vicente Sementilli ³ Data ³ 27.07.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ O array aProcedure foi criado para armazenar os nomes de   ³±±
±±³			 ³ procedures para evitar a checagem constante de sua existen-³±±
±±³			 ³ cia no Banco de Dados                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static aProcedures := {}

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³A330GRAVASB6³ Autor ³ Marcos Bregantim    ³ Data ³ 07/07/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Custo do Poder de Terceiros                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A330GRAVASB6(xPar1,xPar2)                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330GRAVASB6(cAlias,aCusto,aCustoFF,lCusFIfO,lCstPart,aRegraCP,aRetPartes,lCusRep,aCMRep)
    Local lEof
    Local cMoedaCM := SuperGetMv('MV_MOEDACM',.F.,"2345")

    lCusFIfO := IIf(lCusFIfO==Nil,.F.,lCusFIfO)

    DEFAULT lCstPart := .F.
    DEFAULT lCusRep  := .F.
    DEFAULT aCMRep   := {0,0,0,0,0}

    If cAlias == "SD1"
        DbSelectArea("SB6")
        DbSetOrder(3)
        DbSeek ( xFilial() + SD1->D1_IDENTB6 + SD1->D1_COD + "R")
        lEof := .t.
        While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD1->D1_IDENTB6 + SD1->D1_COD
            If SB6->B6_TIPO == "D"
                lEof := .f.
                Exit
            EndIf
            DbSkip()
        End
        If !lEof
            Reclock("SB6",.F.)
            SB6->B6_QUANT		:= SD1->D1_QUANT
            If lCusFIfO
                SB6->B6_CUSFF1 := aCusto[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCusto[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        Else
            Reclock("SB6",.T.)
            SB6->B6_QUANT	:= SD1->D1_QUANT
            SB6->B6_FILIAL := xFIlial("SB6")
            SB6->B6_PRODUTO:= SD1->D1_COD
            SB6->B6_CLIfOR := SD1->D1_FORNECE
            SB6->B6_LOJA	:= SD1->D1_LOJA
            SB6->B6_IDENT := SD1->D1_IDENTB6
            SB6->B6_TPCF := Iif(SD1->D1_TIPO $"DB","C","F")
            SB6->B6_TIPO := "D"
            If lCusFIfO
                SB6->B6_CUSFF1 := aCusto[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCusto[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        EndIf
    Else
        DbSelectArea("SB6")
        DbSetOrder(3)
        DbSeek ( xFilial() + SD2->D2_IDENTB6 + SD2->D2_COD + "R" )
        lEof := .t.
        While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD2->D2_IDENTB6 + SD2->D2_COD
            If SB6->B6_TIPO == "E"
                lEof := .f.
                Exit
            EndIf
            DbSkip()
        End
        If !lEof
            Reclock("SB6",.F.)
            SB6->B6_QUANT		:= SD2->D2_QUANT
            If lCusFIfO
                SB6->B6_CUSFF1 := aCustoFF[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCustoFF[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCustoFF[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCustoFF[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCustoFF[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        Else
            Reclock("SB6",.t.)
            SB6->B6_QUANT		:= SD2->D2_QUANT
            SB6->B6_FILIAL := xFIlial("SB6")
            SB6->B6_PRODUTO := SD2->D2_COD
            SB6->B6_CLIfOR := SD2->D2_CLIENTE
            SB6->B6_LOJA := SD2->D2_LOJA
            SB6->B6_IDENT := SD2->D2_IDENTB6
            SB6->B6_TPCF := Iif(SD2->D2_TIPO $"DB","F","C")
            SB6->B6_TIPO := "E"
            If lCusFIfO
                SB6->B6_CUSFF1 := aCustoFF[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCustoFF[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCustoFF[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCustoFF[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCustoFF[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        EndIf
    EndIf
    GravaCusCP(lCstPart,aRegraCP,aCusto,"SB6",SB6->B6_PRODUTO,aRetPartes,NIL,NIL,ACLONE(aCusto))
Return (aCusto)

	/*
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³CheckCols   ³ Autor ³ Juan Jose Pereira   ³ Data ³ 27/03/96 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³ VerIfica se linha do aCols foi preenchido 					  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Sintaxe	 ³lRet:=CheckCols(n,aCols) 											  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso		 ³LinOk																		  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function CheckCols(n,aCols)

    Local lRet:=.T.,lVazio:=.T.

    If n==Len(aCols)
        Aeval(aCols[n],{|x|If(lVazio,lVazio:=Empty(x),lVazio)})
        If lVazio
            lRet:=.F.
            Help(" ",1,"CHECKCOLS")
        EndIf
    EndIf

Return (lRet)

	/*
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³ EvalMacro	 ³Autor ³ Juan Jose Pereira	 ³Data³ 08/04/97 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³ Executa Macro															  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
FUNCTION EvalMacro(cMacro)
Return(If(Empty(cMacro),NIL,&(cMacro)))

    #ifdef TOP
Function MSFILTER(cFiltro)
    Local cExpress, nAt, cNewFilter := ""

    Set Filter To &(cFiltro)
    DbGoTop()
Return

#endif


	/*
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡„o	 ³ NumImp	³ Autor ³ Alessandro B. Freire  ³ Data ³ 19.05.97 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡„o ³ Retorna o numero correto de impressao							  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Sintaxe	 ³ Cabec(titulo,cabec1,cabec2,tamanho,NumImp()) 				  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Parametros³ 																			  ³±±
	±±³			 ³ 																			  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso		 ³ Generico 																  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function NumImp()
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Esta funcao somente deve ser usada como parametro de impressao da funcao	 ³
    //³ cabec.																							 ³
    //³ Retornos:																						 ³
    //³ 15 - Comprimido ( Cabec nao imprime o caractere 15, a funcao utiliza este  ³
    //³		numero apenas como referencia ao tipo de impressao )						 ³
    //³																									 ³
    //³ 18 - Normal ( O mesmo acima )															 ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Local nTipo := Iif( aReturn[4] == 1, 15, 18 )
Return( nTipo )

	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³AcessaPerg³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 19/08/97 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³Acessa a fun‡„o pergunte a partir de uma chave				  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso		 ³ Generico 																  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function AcessaPerg(cPergunta,lModo)
    lModo := Iif(lModo=Nil,.T.,lModo)
    pergunte(cPergunta,lModo)
Return (.T.)
	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³  MSMM 	³ Autor ³ Gilson Nascimento	  	³ Data ³ 09/07/96 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³ Pesquisa especial para campo MEMO da integracao SIGAEIC/Adv³±±
	±±³			 ³ (AVERAGE/MICROSIGA)										  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Sintaxe	 ³ MSMM(ExprC1,ExprN1,ExprN2,ExprC2,ExprN3)					  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Retorno	 ³ Retorna String pesquisada								  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Uso		 ³ SIGAEIC													  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function MSMM( cChave , nTam , nLin , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias, lSoInclui )
	Local nPos, nTexto
	Local cAliasOld := Alias() , cFilSYP
	Local uRet      := " "
	Local lUsaSx8   := (cChave == NIL .Or. Empty(cChave))
	Local cLine     := ""
	Local lField    := .F.
	Local nLen1
	Local nLen2
	Local cSeq
	Local lGrv := .F.
	Local nPos2
	Local nTamSeq
	Local cPrefixo
	Local nLenSYP

	Local nYP_TEXTO
	Local nYP_CHAVE
	Local nYP_FILIAL
	Local nYP_SEQ

	DEFAULT cChave := StrZero(0,6)
	DEFAULT	nLin := 0
	DEFAULT cString := ""
	DEFAULT nOpc := 3
	DEFAULT cRealAlias := "SYP"
	DEFAULT lSoInclui := .F.

	cPrefixo := PrefixoCpo(cRealAlias)
	cFilSYP := xFilial(cRealAlias)
	nTamSeq := TamSx3(cPrefixo+"_SEQ")[1]
	//Ponto de entrada exclusivo para uso interno do SSIM
	//NAO DIVULGAR PARA CLIENTE
    If VALTYPE(__lUMSMM) <> "L"
		__lUMSMM := FindFunction( "U_UMSMM" )
    EndIf

    If __lUMSMM .AND. ProcName(1) <> "U_UMSMM"		//Tratamento para caso não consiga resolver, poder executar a MSMM original de dentro do Ponto.
		///PONTO DE ENTRADA "UMSMM"
		uRet := U_UMSMM(cChave , nTam , nLin , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias, lSoInclui )
    Else

        Begin Sequence
            If nOpc == 3 // Ler Memo
                If nLin > 0 // Linha especficia
					uRet := MSMM( cChave , nTam , 0 , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias )

					// Atribui valores defaults
					nTabSize := IF(ValType(nTabSize)=="N",nTabSize,nil)
					lWrap := IF(ValType(lWrap)=="L",lWrap,nil)

					uRet := MemoLine(uRet,nTam,nLin,nTabSize,lWrap)

                    If !Empty(cAliasOld)
						dbSelectArea(cAliasOld)
                    EndIf
					Return uRet
                Endif
            Else
				//Se não Possuir Chave e String Vazia Abandona
                IF ( Empty( cChave ) .and. Empty( cString ) )
					Break
                EndIF
				//verifica se o campo existe na tabela
                If ( cCpoChave <> NIL )
					cCpoChave := Trim(cCpoChave)
                    IF !( lField := ( ( cAlias )->( FieldPos( cCpoChave  ) ) > 0.00 ) )
						Break
                    EndIF
                EndIf
            EndIf

			DbSelectArea(cRealAlias)
			DbSetOrder(1)
			DbSeek(cFilSYP + cChave, .T.)

			nYP_TEXTO := FieldPos(cPrefixo+"_TEXTO")
			nYP_CHAVE := FieldPos(cPrefixo+"_CHAVE")
			nYP_FILIAL := FieldPos(cPrefixo+"_FILIAL")
			nYP_SEQ := FieldPos(cPrefixo+"_SEQ")
			nLenSYP := Len(FieldGet(nYP_TEXTO))

			DEFAULT nTam    := nLenSYP

			// Ler campo MEMO
            If nOpc == 3
				//cSeqAux := Replicate( "9" , nTamSeq )
                While !Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilSYP == FieldGet(nYP_FILIAL) )
					/* contornado com a utilização da função MemoLine()
                    If nLin > 0
						nPos := At("\13\10",Subs(FieldGet(nYP_TEXTO),1,nTam+6))
                        If ( nPos == 0 )
							cLine := RTrim(Subs(FieldGet(nYP_TEXTO),1,nTam))
                            If ( nPos2 := At("\14\10", cLine) ) > 0
								cString += StrTran( cLine, "\14\10", Space(6) )
                            Else
								cString += cLine
                            EndIf
                        Else
							cString += Subs(FieldGet(nYP_TEXTO),1,nPos-1)
                        EndIf
						Exit
                    EndIf
					*/

                    nPos := At("\13\10",Subs(FieldGet(nYP_TEXTO),1,nTam+6))
                    If ( nPos == 0 )
                        cLine := RTrim(Subs(FieldGet(nYP_TEXTO),1,nTam))
                        If ( nPos2 := At("\14\10", cLine) ) > 0
                            cString += StrTran( cLine, "\14\10", Space(6) )
                        Else
                            cString += cLine
                        EndIf
                    Else
                        cString += Subs(FieldGet(nYP_TEXTO),1,nPos-1) + CRLF
                    EndIf
                    DbSkip()
                End While
                uRet := cString

            ElseIf nOpc == 2

                // Excluir campo MEMO
                uRet := .F.
                While !Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilSYP == FieldGet(nYP_FILIAL) )
                    RecLock(cRealAlias,.F.,.T.)
                    DbDelete()
                    MsUnLock()
                    uRet := .T.
                    DbSkip()
                End While

            Else

                // Incluir/Alterar campo MEMO
                If ( lUsaSx8 ) .and. ( nOpc == 1 )
                    cChave := GetSX8Num(cRealAlias,cPrefixo+"_CHAVE")
                EndIf

                if !lSoInclui  //default
                    cSeq 	:= Space( nTamSeq )
                else
                    dbseek(cFilSYP+cChave+'ZZZ',.T.)
                    dbSkip(-1) //Posiciono na última sequência
                    if ( cChave == FieldGet(nYP_CHAVE) .And.  cFilSYP == FieldGet(nYP_FILIAL) )
                        cSeq:=FieldGet(nYP_SEQ)
                    else
                        cSeq 	:= Space( nTamSeq )
                    endif
                endif

                cString	:= Trim(cString)
                If nTam >= nLenSYP .or. nTam > (nLenSYP - 6)
                    nTam := nLenSYP - 6
                EndIf

                While !Empty(cString)

                    nTexto := At(CRLF,cString)
                    If nTexto == nTam
                        cLine := Subs(cString,1,nTam+1)
                    Else
                        cLine := Subs(cString,1,nTam)
                    EndIf
                    nTexto := At(CRLF,cLine)

                    If nTexto > 0

                        cLine := Subs(cLine,1,nTexto-1)+"\13\10"
                        nTexto += 2

                    Else

                        If !Empty(cLine)

                            nTexto := nTam+1
                            nLen1 := Len(cLine)
                            nLen2 := Len(Trim(cLine))

                            //verifica se tem espaco no final da linha para colocar no inicio do proximo registro
                            If nLen1 <> nLen2
                                cLine := Trim(cLine)
                                nTexto -= (nLen1 - nLen2)
                            EndIf

                        Else

                            cLine := Subs( cLine, 1, nTam-6 ) + '\14\10'
                            nTexto += nTam + 1

                        EndIf

                    EndIf

                    cString := Subs(cString,nTexto)

                    cSeq := Soma1( cSeq , nTamSeq )

                    lGrv := .T.
                    GrvMemo( cFilSYP , cChave , cSeq , cLine , cCpoChave, cRealAlias )

                End While

                cSeq := IF( Empty( cSeq ) , Soma1( Space( nTamSeq ) , nTamSeq ) , cSeq )

                IF ( lGrv )
                    DbSelectArea(cAlias)
                    RecLock( cAlias , .F. )
                    Eval( FieldWBlock( cCpochave,Select(cAlias) ),cChave)
                    MsUnLock()
                    FkCommit()
                    DbSelectArea(cRealAlias)
                    DbSeek( cFilSYP + cChave + Soma1( cSeq , nTamSeq ) , .T. )
                Else
                    DbSeek( cFilSYP + cChave , .T. )
                Endif

                While !Eof() .and. ( FieldGet(nYP_FILIAL) == cFilSYP ) .and. ( FieldGet(nYP_CHAVE) == cChave )
                    RecLock( cRealAlias , .F. )
                    DbDelete()
                    MsUnlock()
                    DbSkip()
                End While

                uRet := cChave
                IF ( ( lUsaSx8 ) .and. ( nOpc == 1 ) )
                    ConfirmSX8()
                EndIF

            EndIF

        End Sequence
    EndIf
    dbSelectArea( cAliasOld )

Return( uRet )

Static Function GrvMemo( cFilSYP , cChave , cSeq , cLine , cCpoChave, cRealAlias )
    Local nYP_CAMPO
    Local cPrefixo := PrefixoCpo(cRealAlias)

    DbSelectArea(cRealAlias)
    RecLock( cRealAlias , !DbSeek( cFilSYP + cChave + cSeq ) )
    FieldPut(FieldPos(cPrefixo+"_FILIAL"),cFilSYP)
    FieldPut(FieldPos(cPrefixo+"_CHAVE"),cChave)
    FieldPut(FieldPos(cPrefixo+"_SEQ"),cSeq)
    FieldPut(FieldPos(cPrefixo+"_TEXTO"),cLine)
    IF (nYP_CAMPO := FieldPos(cPrefixo+"_CAMPO")) > 0
        FieldPut(nYP_CAMPO,cCpochave)
    EndIF
    MsUnlock()
    FkCommit()
Return( NIL )

	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡„o    ³E_MsMM    ³ Autor ³ AVERAGE/MJBARROS      ³ Data ³ 22.07.97 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡„o ³Inicializacao de campos memo para visualizacao              ³±±
	±±³          ³                                                            ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Sintaxe e ³                                                            ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Parametros³ idem parametros da MsMM                                    ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Uso       ³ SIGAEIC/SIGACOM                                            ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function E_MsMM(cChave,nTam,nLin,cString,nOpc,nTabSize,lWrap,cAlias,cCpochave)
Return If(Inclui,"",MsMM(cChave,nTam,If(GetStartMod1(),nLin,1),cString,nOpc,nTabSize,lWrap,cAlias,cCpochave))

	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡„o	 ³PrefixoCpo³ Autor ³ Gilson					  ³ Data ³ 08.10.97 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡„o ³Devolve prefixo do campo para o Alias Apontado				  ³±±
	±±³			 ³ 																			  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Parametros³ cAlias																	  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Uso		 ³ Generico 																  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function PrefixoCpo(cAlias)
    Local cRet
    If cAlias == Nil
        cAlias := Alias()
    EndIf
    If Subs(cAlias,1,1) != "S" .and. Len(cAlias) == 3
        cRet := Subs(cAlias,1,3)
    Else
        cRet := Subs(cAlias,2,2)
    EndIf
Return cRet

	/*
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡„o	 ³SomaIt 	³ Autor ³  Marcos Simidu	     ³ Data ³ 19/05/97³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡„o ³ Soma um no item											  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso		 ³ Generico 												  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function SomaIt(cItem)
Return(Soma1(cItem))

	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³DtMovFin	³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 06/11/97 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³Data limite para realiza‡„o de Movimento no Financeiro 	  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso		 ³ Generico 																  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function DtMovFin(dData,lHelp)

    Local FADTMOV := ExistBlock("FADTMOV")
    Local lRet := .T.

    lHelp := Iif(lHelp==NIL,.T.,lHelp)
    dData := Iif(dData==NIL,dDatabase,dData)
    If dData < GetMv("MV_DATAFIN") .And. !FADTMOV
        If lHelp
            Help ( " ", 1, "DTMOVFIN")
        EndIf
        lRet:=.F.
    EndIf
    // TRECHO RETIRADO A PEDIDOS DO VP WILSON
	/*If !empty(SM0->M0_DTVLD) .and. dData > SM0->M0_DTVLD .And. !FADTMOV
    IF lHelp
		F080Help() // função no fonte FINA080.PRX
		Help( " ", 1, "DTINVALSM0",, "",1,0 ) //"Data não pode ser maior do que a data limite autorizada no SIGAMAT utilizado.
    Endif
	lRet := .F.
Endif*/

/*Ponto de entrada para controlar datas diferentes para movimento bancario,
contas a pagar entre outras funcionalidades em que é aplicado a DtMovFin*/
If FADTMOV
	lRet :=	ExecBlock("FADTMOV",.F.,.F.,{dData})
EndIf

Return lRet


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³InverteSi1³ Autor ³ Alice Yaeko Yamamoto  ³ Data ³ 12/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Cria codigo invertido da Conta 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function InverteSi1(cCodigo)
    Local j
    Local cCodInv:=""
    Local nFator

    //ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ 0  - 9	³	 Exemplos de contas Invertidas			  ³
    //³ 1  - 8	³	 1 		- 8zzzzzzzzzzzzzz 				  ³
    //³ 2  - 7	³	 11		- 88zzzzzzzzzzzzz 				  ³
    //³ 3  - 6	³	 1110208 - 8889791zzzzzzzz 				  ³
    //³ 4  - 5	³														  ³
    //³ 5  - 4	³														  ³
    //³ 6  - 3	³														  ³
    //³ 7  - 2	³														  ³
    //³ 8  - 1	³														  ³
    //³ 9  - 0	³														  ³
    //³" " - z  ³                                           ³
    //ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    For j := 1 To 20
        If Subs(cCodigo,j,1) = " "
            cCodInv += "z"
        Else
            nFator  := 9-Int(Val(Subs(cCodigo,j,1)))
            cCodInv += Str(nFator,1)
        EndIf
    Next
Return cCodInv

	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡„o	 ³A460NumIt ³ Autor ³ Rosane Luciane Chene  ³ Data ³ 23.10.95 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡„o ³VerIfica conforme o numero de serie , qual a quantidade	  ³±±
	±±³			 ³de maxima de itens por nota fiscal								  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Uso		 ³ MATA460	e MATA100													  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function A460NumIt(cSerie, lEntrada)
    Local  cAlias :=Alias()
    Local  nItens :=0
    Local  cParam :=""

    DEFAULT lEntrada := .F.

    nItens:=GETMV("MV_NUMITEN")
    cParam := "MV_ITEM" + cSerie
    nItens:=GetNewPar(cParam,nItens)

    If lEntrada
        If ExistBlock("MTAITNFE")
            nItens := ExecBlock("MTAITNFE",.F.,.F.,{nItens,cSerie})
        EndIf
    Else
        If ExistBlock("MTAITNFS")
            nItens := ExecBlock("MTAITNFS",.F.,.F.,{nItens,cSerie})
        EndIf
    EndIf

    DbSelectArea(cAlias)
Return( nItens )

	/*
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³IsTriangul³ Autor ³ Ben-Hur M Castilho	  ³ Data ³ 15/01/98 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³VerIfica se utiliza operacao triangular.						  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function IsTriangular( lNewValue )

    Static lTriangular := .F.

    If ((PCount() == 1) .And. (ValType( lNewValue ) == "L"))
        lTriangular := lNewValue
    EndIf

Return( lTriangular )

	/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³ fC010Venc³ Autor ³ Vinicius S. Barreira  ³ Data ³ 31/10/94 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³ Retorna a data de vencimento. 									  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³ fC010Venc() 															  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Generico 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	/*/
Function fC010Venc()

    Local dData := dDataBase

    If DataValida(SE1->E1_VENCTO,.T.) <= dDataBase
        dData := SE1->E1_VENCTO
    Else
        dData := DataValida(SE1->E1_VENCTO,.t.)
    EndIf
Return dData

	/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³fa070juros³ Autor ³ Wagner Xavier 		  ³ Data ³ 06/05/92 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Calcula o juros de um determinado titulo.						  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³fa070juros(ExpN1)														  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ExpN1		: Moeda														  ³±±
    ±±³			 ³ExpN2		: Valor do Titulo a ser considerado Def.:E1_SALDO ³±±
    ±±³			 ³dBaixa 	: Data em que o juros sera pago. 					  ³±±
    ±±³			 ³nJuros 	: Valor do Juros do Titulo 							  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Observacao³Os parametros dBaixa e nJuros devem ser variaveis Privates  ³±±
    ±±³			 ³declaradas antes da chamada da funcao. E o titulo deve estar³±±
    ±±³			 ³posicionado. 															  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ FINA070																	  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	/*/
Function fa070Juros(nMoeda,nVlrTit,cAlias,dUltBaixa)
    Local nTxMoeda
    Local aArea    := GetArea()
    Local aAreaSE1 := SE1->(GetArea())
    Local aAreaSE5 := SE5->(GetArea())

    If cAlias == NIL
        cAlias := "SE1"
    Endif

    nMoeda := If(nMoeda==Nil,1,nMoeda)
    nVlrTit:= If(nVlrTit==Nil,(cAlias)->E1_SALDO,nVlrTit)
    dBaixa := If(Type("dBaixa")=="U",dDataBase,dBaixa)
    nTxMoeda := If(cPaisLoc=="BRA",(cAlias)->E1_TXMOEDA,0)

    DEFAULT dUltBaixa := (cAlias)->E1_BAIXA

    dbSelectArea("SE5")
    dbSetOrder(7)//E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
    If dbSeek(xFilial("SE5")+(cAlias)->E1_PREFIXO+(cAlias)->E1_NUM+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO)
        If SE5->E5_MOTBX $ "CMP" //Se o título tiver sofrido compensação, considero a data de vencimento original e não a data da última baixa
            dUltBaixa := StoD("")
        EndIf
    EndIf

    //Calculo de Juros e Multas: SIGALOJA x SIGAFIN
    nJuros := faJuros((cAlias)->E1_VALOR,nVlrTit,(cAlias)->E1_VENCTO,(cAlias)->E1_VALJUR,(cAlias)->E1_PORCJUR,(cAlias)->E1_MOEDA,(cAlias)->E1_EMISSAO,dBaixa,nTxMoeda,dUltBaixa,(cAlias)->E1_VENCREA ,cAlias, , , , )

    //Aplica desconto nos juros do titulo
    If (cAlias)->(FieldPos("E1_DESCJUR")) > 0
        If !Empty((cAlias)->E1_LIDESCF) .AND. (dBaixa <= (cAlias)->E1_LIDESCF)
            nJuros := nJuros - Round((((cAlias)->E1_DESCJUR / 100) * nJuros),2)
        EndIf
    EndIf

    // Converte o valor dos juros para moeda solicitada
    nJuros := xMoeda(nJuros,(cAlias)->E1_MOEDA,nMoeda,dDataBase,,nTxMoeda)

    //
    // Template GEM
    //
    // Executa os calculos das variaveis private:
    //		nCM1
    //		nProRata
    //		nMulta
    //		nJuros
    //
    //
    Default __lGEMJUROS  := ExistTemplate("GEMJUROS")
    Default __lE1_NCONTR := ((cAlias)->(FieldPos("E1_NCONTR")) > 0)
    If __lGEMJUROS .And. __lE1_NCONTR .And. !Empty((cAlias)->E1_NCONTR)
        ExecTemplate("GEMJUROS",.F.,.F.,{cAlias ,dBaixa ,dUltBaixa ,nVlrTit})
    EndIf

    RestArea(aAreaSE5)
    RestArea(aAreaSE1)
    RestArea(aArea)
Return(nJuros)

	/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³faJuros   ³ Autor ³Eduardo Riera  		³ Data ³31/12/1999³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Calcula o juros de um determinado titulo.	                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³FaJuros()         										  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ExpN1		: Valor do Titulo                                 ³±±
    ±±³			 ³ExpN2		: Saldo do Titulo a ser considerado Def.:E1_SALDO ³±±
    ±±³			 ³ExpD3  	: Data de vencimento do Titulo.  				  ³±±
    ±±³			 ³ExpN4  	: Valor do Juros do Titulo 						  ³±±
    ±±³			 ³ExpN5  	: Taxa de Permanencia.                            ³±±
    ±±³			 ³ExpN6  	: Moeda em que se encontra o Titulo         	  ³±±
    ±±³			 ³ExpD7  	: Data de Emissao.                                ³±±
    ±±³			 ³ExpD8  	: Data de Baixa.                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ FINA070													  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	/*/
Function faJuros(nVlrTit,nSaldo,dVencto,nValJur,nPerJur,nMoeda,dEmissao,dBaixa,nTxMoeda,dUltBaixa,dVencRea,cAliasSe1,cPrefixo,cNum,cParcela,cTipo)

    Local aAreaSE1	:= {}
    Local nAtraso 	:= 0
    Local nTxPer  	:= 0
    Local nJuros  	:= 0
    Local nAtrSimp	:= 0
    Local nSaldoC 	:= 0
    Local cMvJurTipo:= GetMv("MV_JURTIPO")
    Local nMVFINJRTP:= SuperGetMv("MV_FINJRTP",,1)
    Local nDiasAtraso:=0
    // calculo juros do loja se TipoJur = L
    Local lLojxRJur		:= FindFunction("LojxRJur")
    Local lSE1 			:= .F.
    Local lRestSE1 		:= .F.

    DEFAULT dUltBaixa 	:= dVencto
    DEFAULT	cNum        := ""
    DEFAULT	cPrefixo  	:= ""
    DEFAULT	cParcela  	:= ""
    DEFAULT	cTipo     	:= ""
    Default __lNewJuros := Existblock("NEWJUROS")
    Default __lFJURREC  := Existblock("FJURREC")

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Se função que chamar a faJuros tiver posicionada no SE1         ³
    //³ deverá passar apenas o ALIAS do SE1, caso contrário não         ³
    //³ passar o alias e apenas a Chave do SE1 para o faJuros posicionar  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    nTxMoeda := If(nTxMoeda == Nil, 0, nTxMoeda)
    dBaixa   := If(dBaixa==Nil,dDataBase,dBaixa)
    nVlrTit	:= If(nVlrTit==Nil,nSaldo,nVlrTit)
    dVencto := IIf(Day(dUltBaixa)== 0,dVencto,If(dUltBaixa > dVencto, dUltBaixa, dVencto))
    dVencRea := If(dVencRea==Nil,dVencto,dVencRea)

    If ( DataValida(dVencto,.T.) >= dBaixa )
        dVencto := DataValida(dVencto,.T.)
    EndIf

    nAtraso := dBaixa - dVencto

    //Se a data de pagamento for menor ou igual que o vencimento real nao calculo juros
    If dBaixa <= dVencRea
        nAtraso := 0
    EndIf

    If ( Dow(dVencto) == 1 .Or. Dow(dVencto) == 7 )
        If Dow(dBaixa) == 2 .and. nAtraso <= 2
            nAtraso := 0
        EndIf
    EndIf
    If __lNewJuros
        nAtraso := Execblock("NEWJUROS",.f.,.f.,{dBaixa,dVencto,nAtraso})
    Endif

    nAtraso:=Iif(nAtraso<0,0,nAtraso)
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Compara dias de atraso com o parametro tolerancia de atraso  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If nAtraso <= GetMv("MV_TOLER")
        nAtraso := 0
    EndIf

    //Ponto de entrada para cálculo de juros
    Default __lFJURCST := Existblock("FJURCST")
    If !__lFJURCST
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Quando nÆo houver percentual de juros no t¡tulo deve-se cal- ³
        //³ cular pela taxa de permanencia. Quando ha percentual ou ele  ³
        //³ se refere a taxa de permanencia ou ele foi informado manual- ³
        //³ mente na inclusao do titulo a receber.							  ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If ( nAtraso != 0 .And. (!Empty(nValJur) .Or. !Empty(nPerJur)) )
            If !Empty( nValJur ) .and. nMVFINJRTP == 1 		//  MV_FINJRTP = 1.Tx Perm
                nJuros := nValJur * nAtraso
            Else //MV_FINJRTP = 2.Juros ou 3.Ambos
                nTxPer := nPerJur
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³ Calcula os juros compostos caso o parƒmetro seja "C";     ³
                //³ Calcula os juros simples caso o parametro seja "S"  ;     ³
                //³ Calcula os juros mistos  caso o parametro seja "M".       ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                If cMvJurTipo == "M" .Or. cMvJurTipo == "S"
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³ Calcula os juros simples											  ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    If ( cMvJurTipo == "M")
                        nAtrSimp := If( nAtraso > 30 , 30 , nAtraso )
                    Else
                        nAtrSimp := nAtraso
                    EndIf
                    nJuros := nSaldo*(1+(nAtrSimp*(nTxPer/100)))
                    nDiasAtraso := nAtraso
                    nAtraso := Iif(cMvJurTipo == "M", nAtraso-30, nAtraso )
                EndIf
                If ( cMvJurTipo=="M" .And. nAtraso > 0 ) .Or. cMvJurTipo=="C"
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³ Calcula os juros compostos										  ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    If cMvJurTipo == "C"
                        nSaldoC := nSaldo
                    Else
                        nSaldoC := nJuros
                    EndIf
                    nJuros := nSaldoC *( (1+( nTxPer/100 ) ) ** nAtraso )
                EndIf
                nJuros := nJuros - nSaldo
                If nMVFINJRTP == 3 .and. !Empty( nValJur )  // MV_FINJRTP = 3.Ambos
                    nJuros := nJuros + (nValJur * nDiasAtraso)
                EndIf
            EndIf
        EndIf

        //Calculo de Juros e Multas: SIGALOJA x SIGAFIN - Inicio
        If cMvJurTipo == "L"      //Calculo de Juros e dias de atraso, segundo o controle de Lojas

            nJuros := 0

            If cAliasSE1 == NIL .and. !Empty(cPrefixo+cNum+cParcela+cTipo)

                cAliasSE1 := "SE1"
                aAreaSE1 := GetArea(cAliasSE1)
                lRestSE1 := .T.
                (cAliasSE1)->(dbSetOrder(1))   // E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
                If !Empty(cPrefixo+cNum+cParcela+cTipo)
                    lSE1 := (cAliasSE1)->(DbSeek(xFilial(cAliasSe1)+cPrefixo+cNum+cParcela+cTipo))
                Endif
            Else
                lSE1 := !Empty(cAliasSE1)
            EndIf

            If lSE1
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //|  calcula o Juros Função: LojxRJur - Lojxrec         ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                If lLojxRJur
                    nJuros := LojxRJur(, , , ,  (cAliasSe1)->E1_SALDO,;
                        (cAliasSe1)->E1_ACRESC  , cAliasSe1, ,   (cAliasSe1)->E1_MOEDA, dBaixa,(cAliasSE1)->E1_VENCREA, ,(cAliasSE1)->E1_JUROS)

                EndIf
            EndIf

            If lRestSE1
                RestArea(aAreaSE1)
            EndIf

        EndIf
        //Calculo de Juros e Multas: SIGALOJA x SIGAFIN  - Final
    Else
        nJuros := Execblock("FJURCST",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur})
    EndIf

    // Ponto de entrada para recalculo do Juros
    If __lFJURREC
        nJuros := Execblock("FJURREC",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur,nJuros})
    Endif

Return(nJuros)


	/*
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o	 ³ CalcEst	   ³ Autor ³ Vicente Sementilli ³ Data ³ 27.07.98 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³ A Rotina padrao foi renomeada para xCalcEst(), para os ca- ³±±
	±±³			 ³ sos que utilizam banco de dados disparem uma Stored Proce- ³±±
	±±³			 ³ dure CalcEst.SQL. Se a procedure nao existir a rotina pa-  ³±±
	±±³			 ³ drao xCalcEst() sera executada.							  ³±±
	±±³			 ³ Motivo basico da alteracao e a Otimizacao e Performance	  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Sintaxe	 ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Parametros³ ExpA1 = Array com o Saldo Inicial para o Produto/Local.	  ³±±
	±±³			 ³ ExpC1 = Codigo do Produto								  ³±±
	±±³			 ³ ExpC2 = Local (AlmoxarIfado)								  ³±±
	±±³			 ³ ExpD1 = Data para obter o Saldo Inicial.					  ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso		 ³ SIGACUS													  ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	*/
Function CalcEst(cCod,cLocal,dData,cFilAux,lConsTesTerc,lCusRep)

    #ifdef TOP
        Local cxFilial       := ""
        Local cProcNam       := IIF(FindFunction("GetSPName"), GetSPName("MAT006","14"), "MAT006")
        Local lD3Servico     := GetMV('MV_D3SERVI', .F., 'N')=='S'
        Default lConsTesTerc := .F.
        Default dData        := dDataBase
        dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)
        If ExistProc( cProcNam, VerIDProc())  .and. ( TcSrvType() <> "AS/400" )
            aResult := {}
            aResult := TCSPExec( xProcedures(cProcNam),	cCod,;											// 01. Codigo do Produto
            cLocal,;										// 02. Codigo do Armazem
            DTOS(dData),;									// 03. Data de Processamento
            If(cFilAux=nil,Subst("-@@-",2,2),cFilAux),;  	// 04. Colocado os tracos antes e depois do @@ para nao ocorrer erro no geracao de ch
                GetMv("MV_LOCPROC"),;							// 05. Armazem de Processo
                cFilAnt,;										// 06. Codigo da Filial
                If(lD3Servico,'1','0'),;						// 07. Considera o parametro MV_D3SERVI
                    If(IntDL(cCod),'1','0'),;						// 08. Verifica a integracao com WMS
                        GetMv("MV_CQ"))									// 09. Armazem de CQ
                        If aResult == Nil
                            Final(STR0091) //"RE-INSTALAR AS STORED PROCEDURES"
                        EndIf
                        Return (aResult)
                    Elseif ExistProc( cProcNam, VerIDProc()) .and. ( TcSrvType() == "AS/400" )
                        cxFilial := BuildStrFil("SD1,SD2,SD3,SF4,SB9,SF5")
                        aResult  := {}
                        aResult  := TCSPExec( xProcedures(cProcNam), cxFilial, cCod, cLocal,;
                            DTOS(dData), If(cFilAux=nil,"@@",cFilAux),;
                            GetMv("MV_LOCPROC"), cFilAnt,;
                            Substr(cUsuario,7,15), DTOS(dDataBase))
                        Return (aResult)
                    Else
                        Return xCalcEst(@cCod,@cLocal,@dData,@cFilAux,lConsTesTerc,lCusRep)
                    EndIf

					/*/
                    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
                    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
                    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
                    ±±³Fun‡…o    ³ xCalcEst ³ Autor ³ Wilson Junior         ³ Data ³ 28.03.94 ³±±
                    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
                    ±±³Descri‡…o ³ Retorna o Saldo inicial por Produto/Local do arquivo SB9 - ³±±
                    ±±³          ³ Saldos Iniciais.                                           ³±±
                    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
                    ±±³Sintaxe   ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1)                        ³±±
                    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
                    ±±³Parametros³ ExpA1 = Array com o Saldo Inicial para o Produto/Local.    ³±±
                    ±±³          ³ ExpC1 = Codigo do Produto                                  ³±±
                    ±±³          ³ ExpC2 = Local (AlmoxarIfado)                               ³±±
                    ±±³          ³ ExpD1 = Data para obter o Saldo Inicial.                   ³±±
                    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
                    ±±³ Uso      ³ SIGACUS                                                    ³±±
                    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
                    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
                    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
					/*/
Function xCalcEst(cCod,cLocal,dData,cFilAux,lConsTesTerc,lCusRep)
#endif

#define F_SB9  1
#define F_SD1  2
#define F_SD2  3
#define F_SD3  4
#define F_SF4  5
#define F_SF5  6

Local nReg,nReg1,nOrd,nOrd1,dDtVai

#ifdef TOP
    Local lHasRec := .F.
#endif

Local aSaldo     := { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
Local cLocProc   := GETMV("MV_LOCPROC")
Local cArq       := Alias()
Local nCnt01     := 0

Local aFilial  := { xFilial( "SB9" ),;
    xFilial( "SD1" ),;
    xFilial( "SD2" ),;
    xFilial( "SD3" ),;
    xFilial( "SF4" ),;
    xFilial( "SF5" ) }

Local lRemInt  := SuperGetMv("MV_REMINT",.F.,.F.)
Local nSizeFil := 2
Local cFiltroSF5 :=	SF5->(DbFilter())

DEFAULT lConsTesTerc := .F.
DEFAULT lCusRep      := .F.
DEFAULT dData        := dDataBase
SF5->(DBClearFilter())

dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)

If !(cFilAux == NIL)
    If FindFunction("FWSizeFilial")
        nSizeFil := FWSizeFilial()
    EndIf
    For nCnt01 := 1 To Len( aFilial )
        If !(aFilial[ nCnt01 ] == Space(nSizeFil))
            aFilial[ nCnt01 ] := cFilAux
        EndIf
    Next
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de partida para compor o saldo inicial.        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SB9" )

#ifndef TOP
    DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
#else
    If TCSrvType() == "AS/400"
        DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
    Else
        DbSeek(aFilial[ F_SB9 ]+cCod+cLocal)
        lHasRec := .f.
        While !Eof() .and. (aFilial[ F_SB9 ]+cCod+cLocal == B9_FILIAL + B9_COD+B9_Local)
            If B9_DATA >= dData .and. lHasRec
                Exit
            Else
                lHasRec := .t.
            EndIf
            DbSkip()
        End
        If lHasRec
            DbSkip(-1)
        EndIf
    End
#endif

If ((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
        (SB9->B9_DATA < dData))

    aSaldo[01] := SB9->B9_QINI
    aSaldo[02] := SB9->B9_VINI1
    aSaldo[03] := SB9->B9_VINI2
    aSaldo[04] := SB9->B9_VINI3
    aSaldo[05] := SB9->B9_VINI4
    aSaldo[06] := SB9->B9_VINI5
    aSaldo[07] := SB9->B9_QISEGUM
    If SB9->(FieldPos("B9_CM1")) <> 0 .And. SB9->(FieldPos("B9_CM2")) <> 0 .And. ;
            SB9->(FieldPos("B9_CM3")) <> 0 .And. SB9->(FieldPos("B9_CM4")) <> 0 .And. ;
            SB9->(FieldPos("B9_CM5")) <> 0
        aSaldo[08] := SB9->B9_CM1
        aSaldo[09] := SB9->B9_CM2
        aSaldo[10] := SB9->B9_CM3
        aSaldo[11] := SB9->B9_CM4
        aSaldo[12] := SB9->B9_CM5
    EndIf
    If lCusRep
        aSaldo[13] := SB9->B9_CMRP1
        aSaldo[14] := SB9->B9_CMRP2
        aSaldo[15] := SB9->B9_CMRP3
        aSaldo[16] := SB9->B9_CMRP4
        aSaldo[17] := SB9->B9_CMRP5
        aSaldo[18] := SB9->B9_VINIRP1
        aSaldo[19] := SB9->B9_VINIRP2
        aSaldo[20] := SB9->B9_VINIRP3
        aSaldo[21] := SB9->B9_VINIRP4
        aSaldo[22] := SB9->B9_VINIRP5
    EndIf
    dDtVai    := SB9->B9_DATA+1
Else
    dDtVai    := Ctod( "01/01/80","ddmmyy" )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Correr SD1, SD2 e SD3 para  obter o saldo na Data desejada. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SF4" )
nReg1 := Recno()
nOrd1 := Indexord()

DbSelectArea( "SD1" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD1 ]+cCod+cLocal+Dtos(dDtVai),.T. )

While (!Eof() .And. ;
        (aFilial[ F_SD1 ]+cCod+cLocal) == (SD1->D1_FILIAL+SD1->D1_COD+SD1->D1_Local) .And.;
        (SD1->D1_DTDIGIT < dData))

    #ifdef SHELL
        If SD1->D1_CANCEL == "S"
            SD1->(DbSkip())
            Loop
        EndIf
    #endif

    If cPaisLoc != "BRA"
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Desconsiderar notas de remito e notas geradas pelo EIC       ³
        //| com excecao da nota de FOB.									 |
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If !Empty(SD1->D1_REMITO) .Or. SD1->D1_TIPO_NF $ '6789AB'
            SD1->(DbSkip())
            Loop
        EndIf

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Desconsiderar notas de entrada tipo 10 quando o cliente uti_ |
        //| lizar o conceito de remito interno com importacao (SIGAEIC)  |
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If lRemInt
            If !Empty(SD1->D1_CONHEC) .And. SD1->D1_TIPO_NF $ '5' .And. SD1->D1_TIPODOC $ '10'
                SD1->(DbSkip())
                Loop
            EndIf
        EndIf

    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Somente Notas Fiscais Nao Lancadas No Modulo do Livro Fiscal ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !(SD1->D1_ORIGLAN == "LF")
        DbSelectArea( "SF4" )
        //		If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD1->D1_TES ) .Or. ;
            //			DbSeek( aFilial[ F_SF4 ]+SD1->D1_TES,.F. ))
        If (iif (FWModeAccess("SF4") == "E",(SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD1->D1_TES ), ;
                (SF4->F4_FILIAL+SF4->F4_CODIGO == substr(aFilial[ 4 ],1,len(SF4->F4_FILIAL)-len(FWFilial("SF4")))+FWFilial("SF4")+SD1->D1_TES)).Or. ;
                DbSeek( aFilial[ F_SF4 ]+SD1->D1_TES,.F. ))
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Somente TES Que Movimenta Estoque Deve Ser Considerada ³
            //³ ou TES de poder de terceiros com parametro ligado      ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
                aSaldo[1] += SD1->D1_QUANT
                aSaldo[2] += SD1->D1_CUSTO
                aSaldo[3] += SD1->D1_CUSTO2
                aSaldo[4] += SD1->D1_CUSTO3
                aSaldo[5] += SD1->D1_CUSTO4
                aSaldo[6] += SD1->D1_CUSTO5
                aSaldo[7] += SD1->D1_QTSEGUM
                If lCusRep
                    aSaldo[18] += SD1->D1_CUSRP1
                    aSaldo[19] += SD1->D1_CUSRP2
                    aSaldo[20] += SD1->D1_CUSRP3
                    aSaldo[21] += SD1->D1_CUSRP4
                    aSaldo[22] += SD1->D1_CUSRP5
                EndIf
            EndIf
        EndIf
        DbSelectArea( "SD1" )
    EndIf
    DbSkip(1)
End

DbSetOrder( nOrd ) ; DbGoTo( nReg )

DbSelectArea( "SD2" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 6 )

DbSeek( aFilial[ F_SD2 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
        (aFilial[ F_SD2 ]+cCod+cLocal == SD2->D2_FILIAL+SD2->D2_COD+SD2->D2_Local) .And. ;
        (SD2->D2_EMISSAO < dData))

    #ifdef SHELL
        If SD2->D2_CANCEL == "S"
            SD2->(DbSkip())]
            Loop
        EndIf
    #endif

    If !Empty(SD2->D2_REMITO) .And. !(SD2->D2_TPDCENV $ "A1")
        SD2->(DbSkip())
        Loop
    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Despreza Notas Fiscais Lancadas Pelo Modulo do Livro Fiscal  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !(SD2->D2_ORIGLAN == "LF")
        DbSelectArea("SF4")
        If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD2->D2_TES ) .Or. ;
                DbSeek( aFilial[ F_SF4 ]+SD2->D2_TES,.F. ))
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Somente TES Que Movimenta Estoque Deve Ser Considerada ³
            //³ ou TES de poder de terceiros com parametro ligado      ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
                aSaldo[1] -= SD2->D2_QUANT
                aSaldo[2] -= SD2->D2_CUSTO1
                aSaldo[3] -= SD2->D2_CUSTO2
                aSaldo[4] -= SD2->D2_CUSTO3
                aSaldo[5] -= SD2->D2_CUSTO4
                aSaldo[6] -= SD2->D2_CUSTO5
                aSaldo[7] -= SD2->D2_QTSEGUM
                If lCusRep
                    aSaldo[18] -= SD2->D2_CUSRP1
                    aSaldo[19] -= SD2->D2_CUSRP2
                    aSaldo[20] -= SD2->D2_CUSRP3
                    aSaldo[21] -= SD2->D2_CUSRP4
                    aSaldo[22] -= SD2->D2_CUSRP5
                EndIf
            EndIf
        EndIf
        DbSelectArea( "SD2" )
    EndIf
    DbSkip(1)
End

DbSetOrder( nOrd ) ; DbGoTo( nReg )


DbSetOrder( nOrd ) ; DbGoTo( nReg )

DbSelectArea( "SF4" )
DbSetOrder( nOrd1 ) ; DbGoTo( nReg1 )

DbSelectArea( "SF5" )
nReg1 := Recno()
nOrd1 := IndexOrd()

DbSelectArea( "SD3" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD3 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
        (aFilial[ F_SD3 ]+cCod+cLocal == SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_Local) .And. ;
        (SD3->D3_EMISSAO < dData))
    If !D3Valido()
        DbSkip()
        Loop
    EndIf
    DbSelectArea( "SF5" )
    If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
            (SD3->D3_TM == "499") .Or. ;
            (SD3->D3_TM == "999") .Or. ;
            DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))
        If SD3->D3_TM >"500"
            aSaldo[1] -= SD3->D3_QUANT
            aSaldo[2] -= SD3->D3_CUSTO1
            aSaldo[3] -= SD3->D3_CUSTO2
            aSaldo[4] -= SD3->D3_CUSTO3
            aSaldo[5] -= SD3->D3_CUSTO4
            aSaldo[6] -= SD3->D3_CUSTO5
            aSaldo[7] -= SD3->D3_QTSEGUM
            If lCusRep
                aSaldo[18] -= SD3->D3_CUSRP1
                aSaldo[19] -= SD3->D3_CUSRP2
                aSaldo[20] -= SD3->D3_CUSRP3
                aSaldo[21] -= SD3->D3_CUSRP4
                aSaldo[22] -= SD3->D3_CUSRP5
            EndIf
        Else
            aSaldo[1] += SD3->D3_QUANT
            aSaldo[2] += SD3->D3_CUSTO1
            aSaldo[3] += SD3->D3_CUSTO2
            aSaldo[4] += SD3->D3_CUSTO3
            aSaldo[5] += SD3->D3_CUSTO4
            aSaldo[6] += SD3->D3_CUSTO5
            aSaldo[7] += SD3->D3_QTSEGUM
            If lCusRep
                aSaldo[18] += SD3->D3_CUSRP1
                aSaldo[19] += SD3->D3_CUSRP2
                aSaldo[20] += SD3->D3_CUSRP3
                aSaldo[21] += SD3->D3_CUSRP4
                aSaldo[22] += SD3->D3_CUSRP5
            EndIf
        EndIf
    EndIf
    DbSelectArea( "SD3" ) ; DbSkip(1)
End

If AllTrim(cLocal) == AllTrim(cLocProc)

    DbSetOrder( 7 )

    DbSeek( aFilial[ F_SD3 ]+cCod,.T. )

    While (!Eof() .And. ;
            (aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD))

        If SD3->D3_EMISSAO >= dData
            SD3->(dbSkip())
            Loop
        EndIf

        While (!Eof() .And. ;
                (aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD) .And. ;
                (SD3->D3_EMISSAO < dData))

            If ((SD3->D3_EMISSAO <  dData)      .And. ;
                    (SD3->D3_EMISSAO >= dDtVai)     .And. ;
                    (SubS( SD3->D3_CF,2 ) == "E3")  .And. ;
                    !(alltrim(SD3->D3_Local) == alltrim(cLocProc)))

                If !D3Valido()
                    DbSkip()
                    Loop
                EndIf

                DbSelectArea( "SF5" )
                If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
                        (SD3->D3_TM == "499") .Or. ;
                        (SD3->D3_TM == "999") .Or. ;
                        DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))

                    If SD3->D3_CF = "RE3"

                        aSaldo[1] += SD3->D3_QUANT
                        aSaldo[2] += SD3->D3_CUSTO1
                        aSaldo[3] += SD3->D3_CUSTO2
                        aSaldo[4] += SD3->D3_CUSTO3
                        aSaldo[5] += SD3->D3_CUSTO4
                        aSaldo[6] += SD3->D3_CUSTO5
                        aSaldo[7] += SD3->D3_QTSEGUM
                        If lCusRep
                            aSaldo[18] += SD3->D3_CUSRP1
                            aSaldo[19] += SD3->D3_CUSRP2
                            aSaldo[20] += SD3->D3_CUSRP3
                            aSaldo[21] += SD3->D3_CUSRP4
                            aSaldo[22] += SD3->D3_CUSRP5
                        EndIf
                    ElseIf SD3->D3_CF = "DE3"
                        aSaldo[1] -= SD3->D3_QUANT
                        aSaldo[2] -= SD3->D3_CUSTO1
                        aSaldo[3] -= SD3->D3_CUSTO2
                        aSaldo[4] -= SD3->D3_CUSTO3
                        aSaldo[5] -= SD3->D3_CUSTO4
                        aSaldo[6] -= SD3->D3_CUSTO5
                        aSaldo[7] -= SD3->D3_QTSEGUM
                        If lCusRep
                            aSaldo[18] -= SD3->D3_CUSRP1
                            aSaldo[19] -= SD3->D3_CUSRP2
                            aSaldo[20] -= SD3->D3_CUSRP3
                            aSaldo[21] -= SD3->D3_CUSRP4
                            aSaldo[22] -= SD3->D3_CUSRP5
                        EndIf
                    EndIf
                EndIf
            EndIf

            DbSelectArea("SD3")
            DbSkip()
        End
    End
EndIf

DbSetOrder( nOrd ) ; DbGoTo( nReg )


DbSelectArea("SF5")
DbSetOrder( nOrd1 ) ; DbGoTo( nReg1 )
If !Empty (cFiltroSF5)
    dbSetFilter({||&cFiltroSF5},cFiltroSF5)
EndIf

DbSelectArea( cArq )

Return( aSaldo )

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³CalcEstFF ³ Autor ³ Ben-Hur M. Castilho   ³ Data ³ 03.03.98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Retorna o Saldo Inicial por Produto/Local do arquivo SB9 - ³±±
				±±³			 ³ Saldos Iniciais. (Custo FIfO) 							  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ExpA1 = Array com o Saldo Inicial para o Produto/Local.	  ³±±
				±±³			 ³ ExpC1 = Codigo do Produto								  ³±±
				±±³			 ³ ExpC2 = Local (AlmoxarIfado)								  ³±±
				±±³			 ³ ExpD1 = Data para obter o Saldo Inicial.					  ³±±
				±±³          ³ ExpC3 = Lote FIFO                                          ³±±
				±±³          ³ ExpL1 = Forca uso do saldo inicial padrao                  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ SIGACUS													  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function CalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFiFO,lForcaSB9)

    #ifdef F_SB9
        #undef F_SB9
    #endif

    #define F_SB9	1
    #define F_SD8	2

    #ifdef TOP
        Local lHasRec
    #endif

    Local aSaldo  := { 0,0,0,0,0,0,0 }
    Local cArq    := Alias()
    Local nOrdD8  := 0
    Local nCnt01  := 0
    Local dDtVai  := NIL

    Local aFilial	 := { xFilial( "SB9" ), xFilial( "SD8" ) }
    Local nMultiplic := 1
    Local lSaldoIni  :=.T.
    Local nSizeFil   := 2

    Default cLoteFIFO    := CriaVar('D8_SEQ', .F.)
    Default lConsTesTerc := .F.
    Default lForcaSB9    := .F.

    If AliasInDic("SCC")
        dbSelectArea("SCC")
    Endif
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Verifica a NAO utilizacao da tabela SCC referente ao fechamento Fifo ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !(Findfunction("IsFechFifo") .And. IsFechFifo()) .Or. lForcaSB9

        If !(cFilAux == NIL)
            If FindFunction("FWSizeFilial")
                nSizeFil := FWSizeFilial()
            EndIf
            For nCnt01 := 1 To Len( aFilial )
                If !(aFilial[ nCnt01 ] == Space(nSizeFil))
                    aFilial[ nCnt01 ] := cFilAux
                EndIf
            Next
        EndIf

        If Empty(cLoteFIFO)
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Ponto de partida para compor o saldo inicial.        ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            DbSelectArea( "SB9" )
            #ifndef TOP
                DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
            #else
                If TCSrvType() == "AS/400"
                    DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
                Else
                    DbSeek( aFilial[ F_SB9 ]+cCod+cLocal,.F. )
                    lHasRec := .F.
                    While !Eof() .And. (aFilial[ F_SB9 ]+cCod+cLocal == B9_FILIAL+B9_COD+B9_LOCAL)
                        If (B9_DATA >= dData) .And. lHasRec
                            Exit
                        Else
                            lHasRec := .T.
                        EndIf
                        DbSkip()
                    End
                    If lHasRec
                        DbSkip(-1)
                    EndIf
                End
            #endif
        EndIf

        If Empty(cLoteFIFO) .And. ;
                ((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
                (SB9->B9_DATA < dData))

            If Empty(SB9->B9_DATA)
                lSaldoIni := .F.
            Else
                aSaldo[1] := SB9->B9_QINI
                aSaldo[2] := SB9->B9_VINIfF1
                aSaldo[3] := SB9->B9_VINIfF2
                aSaldo[4] := SB9->B9_VINIfF3
                aSaldo[5] := SB9->B9_VINIfF4
                aSaldo[6] := SB9->B9_VINIfF5
                aSaldo[7] := SB9->B9_QISEGUM
                dDtVai	  := SB9->B9_DATA+1
            EndIf
        Else
            lSaldoIni := .F.
            dDtVai	 := Ctod( "01/01/80","ddmmyy" )
        EndIf

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Correr SD8 para	obter o saldo na Data desejada.  ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        DbSelectArea( "SD8" )
        nRecSD8:= Recno()
        nOrdD8 := IndexOrd()
        DbSetOrder( 4 )
        DbSeek( aFilial[ F_SD8 ]+cCod+cLocal)
        Do While (!Eof() .And.	(aFilial[ F_SD8 ]+cCod+cLocal) == (SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL))
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Filtra movimentos com data anterior a saldo inicial³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If lSaldoIni .And. SD8->D8_DATA < dDtVai .Or. ;
                    (!Empty(cLoteFIFO) .And. !(SD8->(D8_SEQ)==cLoteFIFO))
                DbSkip()
                Loop
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Filtra movimentos com data posterior a data solicitada³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If SD8->D8_DATA < dData .And. (SD8->D8_TIPONF # "E" .Or. (SD8->D8_TIPONF == "E" .And. !lSaldoIni))
                If SD8->D8_TM > "500"
                    nMultiplic:= -1
                Else
                    nMultiplic:= 1
                EndIf
                aSaldo[1] += (SD8->D8_QUANT  * nMultiplic)
                aSaldo[2] += (SD8->D8_CUSTO1 * nMultiplic)
                aSaldo[3] += (SD8->D8_CUSTO2 * nMultiplic)
                aSaldo[4] += (SD8->D8_CUSTO3 * nMultiplic)
                aSaldo[5] += (SD8->D8_CUSTO4 * nMultiplic)
                aSaldo[6] += (SD8->D8_CUSTO5 * nMultiplic)
                aSaldo[7] += (SD8->D8_QT2UM  * nMultiplic)
            EndIf
            DbSkip()
        End
        DbSetOrder( nOrdD8 )
        DbGoTo(nRecSD8)
        DbSelectArea( cArq )
    Else

        DbSelectArea( cArq )
        Return xCalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo)

    EndIf

Return( aSaldo )

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³xCalcEstFF ³ Autor ³ Marcos V. Ferreira   ³ Data ³ 22.11.06 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Retorna o Saldo Inicial por Produto/Local do arquivo SCC - ³±±
				±±³			 ³ Saldos Iniciais. (Custo FIfO) 							  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ExpC1 = Codigo do Produto								  ³±±
				±±³			 ³ ExpC2 = Local (AlmoxarIfado)								  ³±±
				±±³			 ³ ExpD1 = Data para obter o Saldo Inicial.					  ³±±
				±±³          ³ ExpC3 = Filial Auxiliar                                    ³±±
				±±³          ³ ExpL1 = Considera Tes Terceiros                            ³±±
				±±³          ³ ExpC4 = Lote FIFO                                          ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ SIGACUS													  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function xCalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo)

    #ifdef F_SCC
        #undef F_SCC
    #endif

    #define F_SCC	1
    #define F_SD8	2

    #ifdef TOP
        Local lHasRec
    #endif

    Local aSaldo  := { 0,0,0,0,0,0,0 }
    Local cArq    := Alias()
    Local nOrdD8  := 0
    Local nCnt01  := 0
    Local dDtVai  := Ctod( "01/01/80","ddmmyy" )
    Local dDtIni  := Nil

    Local aFilial	 := { xFilial( "SCC" ), xFilial( "SD8" ) }
    Local nMultiplic := 1
    Local lSemLtFifo := Empty(cLoteFifo)
    Local nSizeFil   := 2

    Default cLoteFIFO    := CriaVar('D8_SEQ', .F.)
    Default lConsTesTerc := .F.

    If !(cFilAux == NIL)
        If FindFunction("FWSizeFilial")
            nSizeFil := FWSizeFilial()
        EndIf
        For nCnt01 := 1 To Len( aFilial )
            If !(aFilial[ nCnt01 ] == Space(nSizeFil))
                aFilial[ nCnt01 ] := cFilAux
            EndIf
        Next
    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Ponto de partida para compor o saldo inicial.        ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    dbSelectArea( "SCC" )
    If lSemLtFifo
        dbSetOrder( 1 ) //-- CC_PRODUTO+CC_LOCAL+CC_DATA
    Else
        dbSetOrder( 2 ) //-- CC_PRODUTO+CC_LOCAL+CC_SEQ+CC_DATA
    EndIf

    #ifndef TOP
        DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DtoS( dData ),.T. ) ; DbSkip(-1)
    #else
        If TCSrvType() == "AS/400"
            DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DtoS( dData ),.T. ) ; DbSkip(-1)
        Else
            DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo),.F. )
            lHasRec := .F.
            While !Eof() .And. (aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo) == CC_FILIAL+CC_PRODUTO+CC_LOCAL+IIf(lSemLtFifo,"",SCC->CC_SEQ))
                If (CC_DATA >= dData) .And. lHasRec
                    Exit
                Else
                    lHasRec := .T.
                EndIf
                DbSkip()
            End
            If lHasRec
                DbSkip(-1)
            EndIf
        End
    #endif

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Busca Saldo Inicial                                ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    lHasRec:=.F. // Utiliza como sinalizador de leitura do SCC

    dDtIni := SCC->CC_DATA

    While !Bof() .And. DTOS(SCC->CC_DATA) <= DTOS(dData) .And. ;
            (aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DTOS(dDtIni) == ;
            SCC->CC_FILIAL+SCC->CC_PRODUTO+SCC->CC_LOCAL+IIf(lSemLtFifo,"",SCC->CC_SEQ)+DTOS(SCC->CC_DATA))
        lHasRec:=.T.
        aSaldo[1] += SCC->CC_QFIM
        aSaldo[2] += SCC->CC_VFIMFF1
        aSaldo[3] += SCC->CC_VFIMFF2
        aSaldo[4] += SCC->CC_VFIMFF3
        aSaldo[5] += SCC->CC_VFIMFF4
        aSaldo[6] += SCC->CC_VFIMFF5
        aSaldo[7] += SCC->CC_QFIM2UM
        dDtVai    := SCC->CC_DATA+1
        dbSkip(-1)
    End

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Se nao leu nenhum registro na tabela SCC forcar a composicao |
    //| do saldo inicial atraves da metodologia anterior             |
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !lHasRec
        aSaldo:=CalcEstFF(cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo,.T.)
    Else
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Correr SD8 para	obter o saldo na Data desejada.  ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        DbSelectArea( "SD8" )
        nRecSD8:= Recno()
        nOrdD8 := IndexOrd()
        DbSetOrder( 4 )
        DbSeek( aFilial[ F_SD8 ]+cCod+cLocal)
        Do While (!Eof() .And.	(aFilial[ F_SD8 ]+cCod+cLocal) == (SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL))
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Filtra movimentos com data anterior a saldo inicial ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If SD8->D8_DATA < dDtVai .Or. SD8->D8_TIPONF == "E"
                DbSkip()
                Loop
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Filtra movimentos que nao estao no lote informado   ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If !Empty(cLoteFIFO) .And. !(SD8->(D8_SEQ)==cLoteFIFO)
                DbSkip()
                Loop
            EndIf

            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Filtra movimentos com data posterior a data solicitada³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If SD8->D8_DATA < dData
                If SD8->D8_TM > "500"
                    nMultiplic:= -1
                Else
                    nMultiplic:= 1
                EndIf
                aSaldo[1] += (SD8->D8_QUANT  * nMultiplic)
                aSaldo[2] += (SD8->D8_CUSTO1 * nMultiplic)
                aSaldo[3] += (SD8->D8_CUSTO2 * nMultiplic)
                aSaldo[4] += (SD8->D8_CUSTO3 * nMultiplic)
                aSaldo[5] += (SD8->D8_CUSTO4 * nMultiplic)
                aSaldo[6] += (SD8->D8_CUSTO5 * nMultiplic)
                aSaldo[7] += (SD8->D8_QT2UM  * nMultiplic)
            EndIf
            DbSkip()
        End
        DbSetOrder( nOrdD8 )
        DbGoTo(nRecSD8)
    EndIf

    DbSelectArea( cArq )
Return( aSaldo )

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³BlqInvent ³ Autor ³ Marcelo Pimentel      ³ Data ³ 27/01/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Verifica se o produto esta sendo inventariado.			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ Generico 									              ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function BlqInvent(cCod,cLocal,dData,cLocaliz,nRecno)

    Local lBloq   := .F.
    Local aArea   := GetArea()
    Local aAreaSB2:= SB2->(GetArea())
    Local aAreaSBE:= SBE->(GetArea())
    Local aAreaSC9:= SC9->(GetArea())
    Local aAreaSDC:= SDC->(GetArea())
    Local nw      := 0
    Local aSDC    := {}
    Local cChave  := ""


    Local lAcd    := SuperGetMV("MV_INTACD",.F.,"0") == "1"


    DEFAULT dData   := dDataBase
    DEFAULT cLocal  := ""
    DEFAULT cLocaliz:= ""
    DEFAULT nRecno  := ""

    DbSelectArea("SB2")
    DbSetOrder(1)
    If MsSeek(xFilial("SB2")+cCod+cLocal)
        If !Empty(B2_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',(B2_DTINV <= dData .And. dData <= B2_DINVFIM),.T.)
            lBloq := .T.
        EndIf
    EndIf

    //--Efetua validacao integrado com ACD quando informa o endereco
    If lAcd .And. Localiza(cCod) .And. !Empty(cLocaliz)
        DbSelectArea("SBE")
        DbSetOrder(1)
        If DbSeek(xFilial("SBE")+cLocal+cLocaliz)
            If !Empty(BE_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',BE_DTINV <= dData,.T.)
                lBloq := .T.
            EndIf
        EndIf
    EndIf

    //--Efetua validacao integrado com ACD quando "NAO" informa o endereco(FATURAMENTO)
    If lAcd .And. Localiza(cCod) .And. !Empty(nRecno)
        dbSelectArea("SC9")
        dbSetOrder(1)
        MSGoto(nRecno)
        cChave:=(xFilial('SC9')+SC9->C9_PRODUTO+SC9->C9_LOCAL+"SC6"+SC9->C9_PEDIDO+SC9->C9_ITEM)
        DbSelectArea("SDC")
        dbSetOrder(1)
        If MSSeek(cChave)
            While cChave == SDC->DC_FILIAL+SDC->DC_PRODUTO+SDC->DC_LOCAL+SDC->DC_ORIGEM+SDC->DC_PEDIDO+SDC->DC_ITEM .And. !EoF()
                AADD(aSDC,SDC->DC_LOCALIZ)
                dbSkip()
            EndDo
            For nw:=1 to Len(aSDC)
                DbSelectArea("SBE")
                DbSetOrder(1)
                If DbSeek(xFilial("SBE")+SDC->DC_LOCAL+aSDC[nw])
                    If !Empty(BE_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',BE_DTINV <= dData,.T.)
                        lBloq := .T.
                        Help(" ",1,"BLQINVENT",,STR0106+aSDC[nw]+STR0107,1,5)
                    EndIf
                EndIf
            Next nw
        EndIf
    EndIf

    RestArea(aAreaSB2)
    RestArea(aAreaSBE)
    RestArea(aAreaSC9)
    RestArea(aAreaSDC)

    RestArea(aArea)
Return (lBloq)

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³ ASC2SLD	³ Autor ³ Edson Maricate	    ³ Data ³ 02.02.98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Efetua o calculo do Saldo Real da Ordem de Producao.		  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ ExpN1 = ASC2SLD(ExpC1)   								  ³±±
				±±³       	 ³ ExpN1 = Retorno do Saldo da OP                       	  ³±±
				±±³       	 ³ ExpC1 = Alias do arquivo da OP                       	  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ ASC2SLD()												  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
FUNCTION ASC2SLD(cAliasSQL)
    LOCAL nDecs := TamSX3("C2_QUANT")[2]
    LOCAL nSalop := NoRound(0, nDecs) // Forçar valor zero com casa decimais do SX3
    LOCAL lPerdInf := SuperGetMV("MV_PERDINF",.F.,.F.)
    DEFAULT cAliasSQL := "SC2"
    If (cAliasSQL)->C2_DATRF == CTOD("  /  /   ")
        nSalop := Max(0,NoRound((cAliasSQL)->C2_QUANT - (cAliasSQL)->C2_QUJE - If(lPerdInf,0,(cAliasSQL)->C2_PERDA), nDecs))
    EndIf
Return nSalop

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o    ³ InVerte  ³ Autor ³ Wilson                ³ Data ³ 17.02.98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Inverte qualquer campo.                                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe   ³ ExpC1 = Inverte(ExpC2,ExpN1,ExpN2)                         ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpC1 - Campo invertido (sempre caracter)                  ³±±
    ±±³          ³ ExpC2 - Campo a ser convertido                             ³±±
    ±±³          ³ ExpN1 - Tamanho do campo                                   ³±±
    ±±³          ³ ExpN2 - Numero de casas decimais                           ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Generico                                                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function Inverte(uCpo,nPos,nNumDec)
    Local cCpo	:= uCpo
    Local cRet	:= ""
    Local cByte	:= ""
    Local nAsc	:= 0
    Local nI		:= 0
    Local aChar	:= {}
    Local nDiv	:= 0

    nNumDec := IIF(nNumDec == Nil,0,nNumDec)

    Aadd(aChar,	{" ", "Z"})	// Asc(" ")=0  ->  Asc("Z")=90
    Aadd(aChar,	{"0", "Y"})
    Aadd(aChar,	{"1", "X"})
    Aadd(aChar,	{"2", "W"})
    Aadd(aChar,	{"3", "V"})
    Aadd(aChar,	{"4", "U"})
    Aadd(aChar,	{"5", "T"})
    Aadd(aChar,	{"6", "S"})
    Aadd(aChar,	{"7", "R"})
    Aadd(aChar,	{"8", "Q"})
    Aadd(aChar,	{"9", "P"})
    Aadd(aChar,	{"A", "O"})
    Aadd(aChar,	{"B", "N"})
    Aadd(aChar,	{"C", "M"})
    Aadd(aChar,	{"D", "L"})
    Aadd(aChar,	{"E", "K"})
    Aadd(aChar,	{"F", "J"})
    Aadd(aChar,	{"G", "I"})
    Aadd(aChar,	{"H", "H"})
    Aadd(aChar,	{"I", "G"})
    Aadd(aChar,	{"J", "F"})
    Aadd(aChar,	{"K", "E"})
    Aadd(aChar,	{"L", "D"})
    Aadd(aChar,	{"M", "C"})
    Aadd(aChar,	{"N", "B"})
    Aadd(aChar,	{"O", "A"})
    Aadd(aChar,	{"P", "9"})
    Aadd(aChar,	{"Q", "8"})
    Aadd(aChar,	{"R", "7"})
    Aadd(aChar,	{"S", "6"})
    Aadd(aChar,	{"T", "5"})
    Aadd(aChar,	{"U", "4"})
    Aadd(aChar,	{"V", "3"})
    Aadd(aChar,	{"W", "2"})
    Aadd(aChar,	{"X", "1"})
    Aadd(aChar,	{"Y", "0"})
    Aadd(aChar,	{"Z", "!"})	// Asc("Z")=90  ->  Asc("!")=33

    // Se for campo data, primeiro transforma em dtos
    If ValType(uCpo) == "D"
        cCpo := Dtos(uCpo)

    ElseIf ValType(uCpo) == "N"
        nPos := IIF(nPos == Nil,Len(uCpo),nPos)
        cCpo := StrZero(uCpo,nPos,nNumDec)
    EndIf

    nPos := IIF(nPos == Nil,Len(cCpo),nPos)

    For nI:= 1 to Len(cCpo)
        cByte := Upper(Subs(cCpo,nI,1))
        If (Asc(cByte) >= 48 .And. Asc(cByte) <= 57) .Or. ;	// 0 a 9
            (Asc(cByte) >= 65 .And. Asc(cByte) <= 90) .Or. ;	// A a Z
            Empty(cByte)	// " "
            nAsc	:= Ascan(aChar,{|x| x[1] == cByte})
            If nAsc > 0
                cRet := cRet + aChar[nAsc,2]	// Funcao Inverte e chamada pelo rdmake de conversao
            EndIf
        Else
            // Caracteres <> letras e numeros: mantem o caracter
            cRet := cRet + cByte
        EndIf
    Next
    If Len(cRet) > nPos
        cRet := Right(cRet,nPos)
    EndIf
Return(cRet)

				/*
				Obs.: Esta funcao perdeu a validade em 21/02/2000,
				por nao ser compativel com o ambiente Informix/Linux.
				As instalacoes com executaveis do Siga Quality
				a partir desta data, devem ser realizadas apos a
				execucao do conversor, para que os campos invertidos
				sejam regravados com a nova funcao, a partir do campo origem.

Function Inverte(uCpo,nPos)
				Local cCpo := uCpo, cRet := "", nByte , nDiv
    If ValType(uCpo) == "D"
					cCpo := Dtos(uCpo)
    ElseIf ValType(uCpo) == "N"
					nDiv := 1
					nByte := uCpo
        While nByte > 1
						nDiv++
						nByte := Round((nByte / 10),5)
        End
					cCpo := StrZero(uCpo,nDiv,0)
    EndIf
				nPos := Iif(nPos == Nil,Len(cCpo),nPos)
    For ni:= 1 to Len(cCpo)
					nByte := Asc(Subs(cCpo,ni,1))
        If  nByte > 0
						cRet += Chr(255-nByte)
        EndIf
    Next
    If Len(cRet) > nPos
					cRet := Right(cRet,nPos)
    EndIf
				Return cRet
				*/


				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³ SomaAbat ³ Autor ³ Eduardo Riera 		  ³ Data ³ 17.03.98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Soma todos os titulos de abatimento ate uma data limite	  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe e ³ SomaAbat()																  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ Prefixo,Numero,Parcela,Carteira,Moeda,Data,ClIfor,Loja	  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Generico 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function SomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat,dDataRef,cTipo)
    #ifdef TOP
        Local cProcedure := IIF(FindFunction("GetSPName"), GetSPName("FIN001","08"), "FIN001") //'SUMABAT'
        Local aResult
        Default cTipo:= ""

        Default __lProcFIN001 := ExistProc ( cProcedure, VerIDProc2() )
        nMoeda :=Iif( nMoeda==NIL,1,nMoeda )
        dData  :=Iif( dData==NIL,dDataBase,dData )
        cFilAbat:=Iif( cFilAbat==NIL, Iif(cCart=="R",xFilial("SE1"),xFilial("SE2")), cFilAbat)
        cFornCli := If(cFornCli = Nil, If( cCart=="R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cFornCli)
        cLoja    := If(cLoja		= Nil, If( cCart=="R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
        dDataRef := Iif( dDataRef==NIL,dDataBase,dDataRef )
        cTipo	:=If(cTipo		= Nil, If( cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO), cTipo)

        If Funname()!="FINR340" .And. __lProcFIN001 .and. !Empty(cNumero) .and. ( TcSrvType() <> "AS/400" )
            aResult := TCSPEXEC(xProcedures(cProcedure), cPrefixo,;
                cNumero, cParcela, cCart,nMoeda,DTOS(dData),cFornCli,cLoja,cFilAbat,;
                DTOS(dDataRef),cTipo,'')
            Return aResult[1]
        Else
            Return xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)
        EndIf
Static Function xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)
#endif
Local nTotAbat := 0
Local cAlias   := Alias()
Local nOrdem   := indexord()
Local lUniao := .F.             // Utilizada para considerar titulos antigos, onde cliente era UNIAO
//controle de abatimento pelo titpai
Local lTitpaiSE1 := (SE1->(FieldPos("E1_TITPAI")) > 0 )
Local nOrdTitPai:=0
Local bWhile := {|| !Eof() .And. &cArea._FILIAL==cFilAbat .And. &cArea._PREFIXO=cPrefixo .And. &cArea._NUM==cNumero .and. &cArea._PARCELA==cParcela }

Default cTipo:= ""

cArea    := Iif(cCart="R","E1","E2")
nMoeda   := Iif( nMoeda==NIL,1,nMoeda )
dData    := Iif( dData==NIL,dDataBase,dData )
cFilAbat := Iif( cFilAbat==NIL, Iif(cCart=="R",xFilial("SE1"),xFilial("SE2")), cFilAbat)
cFornCli := If(cFornCli = Nil, If( cCart=="R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cFornCli)
cLoja    := If(cLoja		= Nil, If( cCart=="R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
cTipo	:=If(cTipo		= Nil, If( cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO), cTipo)
dDataRef := Iif( dDataRef==NIL,dDataBase,dDataRef )

If cCart == "R"
    If Select("__SE1") == 0
        ChkFile("SE1",.F.,"__SE1")
    Else
        DbSelectArea("__SE1")
    EndIf
ElseIf Select("__SE2") == 0
    ChkFile("SE2",.F.,"__SE2")
Else
    DbSelectArea("__SE2")
EndIf
DbSetOrder(1)
DbSeek(cFilAbat+cPrefixo+cNumero+cParcela)

If lTitpaiSE1 .AND. cCart == "R"
    If FindFunction("OrdTitpai") .and. (nOrdTitPai:= OrdTitpai()) > 0
        DbSetOrder(nOrdTitPai)
        If	DbSeek(cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja)
            bWhile := {|| !Eof() .And. Alltrim(cFilAbat+&cArea._TITPAI) ==  cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja }
        Else
            DbSetOrder(1)
            DbSeek(cFilAbat+cPrefixo+cNumero+cParcela)
        Endif
    Endif
Endif

While Eval(bWhile)
    If ( cCart == "R" )
        If ( cFornCli != Nil  )
            If E1_CLIENTE == "UNIAO "          //antigos
                lUniao := .T.
            EndIf
            If ( E1_CLIENTE != cFornCli ) .and. !lUniao
                DbSkip()
                Loop
            ElseIf ( cLoja != Nil )
                If ( E1_LOJA != cLoja ) .and. !lUniao
                    DbSkip()
                    Loop
                Elseif lTitpaiSE1
                    If !Empty(SE1->E1_TITPAI) .and. !lUniao .AND. (Alltrim(E1_TITPAI)!= Alltrim(cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja))
                        DbSkip()
                        Loop
                    EndIf
                EndIf
            EndIf
        EndIf
    EndIf
    If ( cCart == "P" )
        If ( cFornCli != Nil )
            If ( E2_FORNECE!=cFornCli )
                DbSkip()
                Loop
            ElseIf ( cLoja != Nil )
                If ( E2_LOJA != cLoja )
                    DbSkip()
                    Loop
                EndIf
            EndIf
        EndIf
    EndIf
    If ( (&cArea._TIPO $ MVABATIM .OR. IIF(funname()=="FINR340" ,&cArea._TIPO $ MVIRF,.F.) ) .And. &cArea._EMISSAO <= dDataRef )
        //----------------------------------------------------------------------
        // Validacao inserida para o processo de baixa parcial da Ordem de Pago
        // evitando que o titulo de abatimento seja descontado mais de uma vez
        //----------------------------------------------------------------------
        If &cArea._SALDO > 0 .Or. !(IsInCallStack("FINA085A") .Or. IsInCallStack("FINA850"))
            nTotAbat+=xMoeda(&cArea._VALOR,&cArea._MOEDA,nMoeda,dData,,If(cPaisLoc=="BRA",&cArea._TXMOEDA,0))
        EndIf
    EndIf
    dbSkip()
End
DbSelectArea(cAlias)
DbSetOrder(nOrdem)
Return(nTotAbat)

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³ SaldoI4	³ Autor ³ Alessandro B. Freire  ³ Data ³ 26.03.98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Calcula o saldo atual de uma determinada conta at‚ um deter³±±
				±±³			 ³ minado periodo utilizando o SI4 ao inves do SI1 			  ³±±
				±±³			 ³ Obs.: Deve-se estar posicionado para utilizar esta funcao  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ CalcSaldo(ExpN1)														  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ Numero do Periodo, Moeda											  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function SaldoI4(nPer)

    Local nSaldo
    Local cAlias:= Alias()
    Local nOldSx3	:= Sx3->(recno())
    Local nOldOrd	:= Sx3->(indexord())
    Local nC

    DbSelectArea("SX3")
    DbSetOrder(2)

    DbSeek( "I4_SALANT" )
    nDecimais := X3_DECIMAL

    DbSetOrder(nOldOrd)
    DbGoTo(nOldSx3)

    DbSelectArea("SI4")
    DbSetOrder(1)

    nSaldo := I4_SALANT

    For nC=1 TO nPer

        cSuf	:= Strzero(nC,2)
        nSaldo:= nSaldo-I4_DEBM&cSuf+I4_CRDM&cSuf

    Next nC

    DbSelectArea(cAlias)
Return Round(nSaldo,nDecimais)

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡ao	 ³E_RetField³ Autor ³ AVERAGE/MJBARROS 	  ³ Data ³ 19.03.98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡ao ³Retorna a descricao de campos chave de cadastro. Funcao que ³±±
				±±³			 ³complementa a RetField do Siga a fim de economizar espaco e ³±±
				±±³			 ³caber no campo X3_Relacao											  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe e ³ .................... 												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ................................... 							  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ SIGAEIC-Somente para versao Windows - Importacao			  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				*/
Function E_Field(cChave,cCampoDesc,cOrigem,lChave,nOrder)

    Local nPos := At("_",cCampoDesc)
    Local cArea:= If(nPos>3,Left(cCampoDesc,3),"S"+Left(cCampoDesc,2))
    Local nRec := (cArea)->(RecNo())
    Local nOrd := (cArea)->(IndexOrd())
    Local bDesc:= FieldWBlock(cCampoDesc,Select(cArea))
    Local bVar, cAreaAux
    Local cRet := ""
    Local cChvLoja:= ""
    Begin Sequence

        nPos:=AT("_",cChave)
        cAreaAux:=If(nPos>3,Left(cChave,3),"S"+Left(cChave,2))

        nOrder:=Iif(nOrder==Nil,1,nOrder)
        lChave:=Iif(lChave==Nil,.F.,lChave)
        cOrigem:=Iif(cOrigem==Nil,"G",cOrigem)

        If bDesc = NIL
            MsgStop("Campo "+cCampoDesc+" nao encontrado para o arquivo "+cArea,"Atenção")
            Break
        EndIf

        If (nModulo == 17 .Or. nModulo == 29) .And. EicLoja() .And. AllTrim(cAreaAux) == "SA5"

            If cChave == "A5_FORNECE"
                cChvLoja:= "A5_LOJA"
            ElseIf cChave == "A5_FABR"
                cChvLoja:= "A5_FALOJA"
            EndIf

            If TYPE("M->"+cChave) == "U"
                cRet:= If(!INCLUI,Posicione("SA2",1,xFilial("SA2")+SA5->(&cChave+&cChvLoja),cCampoDesc)," ")
            Else
                cRet:= If(!INCLUI,Posicione("SA2",1,xFilial("SA2")+M->(&cChave+&cChvLoja),cCampoDesc)," ")
            EndIf


            Break
        EndIf

        If cOrigem = "G" // Gatilho/Enchoice  ou Browse se For U
            If TYPE("M->"+cChave) != "U"
                bVar := MemVarBlock(cChave)
                cChave:=Eval(bVar)
            Else
                cChave:= Eval(FieldWBlock(cChave,Select(cAreaAux)))
            EndIf
        Else
            // Browse
            cChave:=Eval(FieldWBlock(cChave,Select(cAreaAux)))
        EndIf

        If Empty(cChave)
            Break
        EndIf

        (cArea)->(DbSetOrder(nOrder))
        (cArea)->(DbSeek(xFilial()+cChave))
        cCampoDesc:=Eval(bDesc)

        If nRec > 0
            (cArea)->(DbGoTo(nRec))
            (cArea)->(DbSetOrder(nOrd))
        EndIf

        cRet := If(!lChave,cCampoDesc,cChave+" "+cCampoDesc)
    End Sequence

Return cRet

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³ EspOrder 	³ Autor ³ Ana Claudia		  ³ Data ³ 23/06/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Substitui a funcao DbSetOrder() devido a fusao dos Sistemas³±±
				±±³			 ³EspecIficos e Padrao, evitando problemas no acesso ao Sindex³±±
				±±³			 ³ - Esta funcao deve ser usada apenas nos programas proprios.³±±
				±±³			 ³ Para o padrao permanece os mesmos indices 					  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ EspOrder(ExpC1,ExpN2)												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ExpC1 = Alias a ser colocada a ordem							  ³±±
				±±³			 ³ ExpN2 = Ordem da Shell												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function EspOrder(cAlias,nOrdem)
    Local nIndice := 1, nAT
    Local cText

    If Len( __aCache ) == 0
        cText := ' *****  W a r n i n g  ***** ' + CRLF
        cText += ' Function ESPORDER' + CRLF
        cText += ' This function is accepted only for compatibility with old versions.' + CRLF
        cText += ' Please Change to Nickname in index.' + CRLF
        ConOut( cText )
    EndIf

    cAlias := If(cAlias==NIL,Alias(),cAlias)
    nOrdem := If(nOrdem==NIL,1,nOrdem)

    If ( nAt:= ASCAN(__aCache, { |x| x[1] == cAlias+StrZero(nOrdem,2,0) } ) ) > 0
        dbSetOrder(__aCache[nAT,2])
        Return .t.
    EndIf

    nAT:=1
    If SIX->(DbSeek(cAlias))
        While ! SIX->(Eof()) .and. SIX->INDICE == cAlias
            If SIX->PROPRI == "T"   // T serve de exemplo pq e maior que S
                // usado no SIX->PROPRI
                If nOrdem == nIndice
                    If Empty(Val(SIX->ORDEM))
                        (cAlias)->( DbSetOrder(Asc(SIX->ORDEM)-55))
                        nAT := Asc(SIX->ORDEM)-55
                    Else
                        (cAlias)->( DbSetOrder(Val(SIX->ORDEM)) )
                        nAT := Val(SIX->ORDEM)
                    EndIf
                    Exit
                EndIf
                nIndice ++
            EndIf
            SIX->(DbSkip())

        End
    EndIf
    AADD(__aCache,{cAlias+StrZero(nOrdem,2,0),nAT})
Return .T.

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³ BuildStrFil ³ Autor ³ Wilson Jr. 		  ³ Data ³ 08.07.98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Retorna a xFilial dos arquivos que serao usados na chamada ³±±
				±±³			 ³ da stored procedure													  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ BuildStrFil(cString) 												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ 																			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function BuildStrFil(cString)
    Local cRet,cStr,ni
    Local nSizeFil := 2

    If cString == Nil
        cString := Alias()
    EndIf
    cString := Upper(cString)
    cRet := ""
    cStr := ""

    If FindFunction("FWSizeFilial")
        nSizeFil := FWSizeFilial()
    EndIf

    For ni:= 1 to Len(cString)
        If Subs(cString,ni,1) == ","
            cRet += FWModeAccess(cStr,3)
            cStr := ""
        Else
            cStr += Subs(cString,ni,1)
        EndIf
    Next
    If !Empty(cStr)
        cRet += FWModeAccess(cStr,3)
    EndIf

Return cRet

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³ xProcedures ³ Autor ³ Vicente Sementilli ³ Data ³ 27.07.98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Para cada Empresa existira uma Stored Procedure. Portanto  ³±±
				±±³			 ³ esta rotina recebe o nome da Stored Procedure e concatena  ³±±
				±±³			 ³ a empresa corrente ao nome (<nome>+_+<empresa>))			  ³±±
				±±³			 ³ Ex. SP_01																  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ ExpA1 := xProcedures(ExpC1)										  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ExpA1 = String com o nome concatenado com a Empresa.		  ³±±
				±±³			 ³ ExpC1 = String com o nome da Procedure 						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function xProcedures (cProcedure)

    #IFDEF TOP
        Local cUnion := If( (TCSrvType() == "AS/400"),"F","_")
    #ELSE
        Local cUnion := "_"
    #ENDIF

    cProcedure := iif(cProcedure = nil, 'NENHUMA', Upper(cProcedure+cUnion+cEmpAnt) )

Return (cProcedure)

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³ Fun‡…o	  ³RetTitle  ³ Autor ³ Pilar Sanchez Albalade³ Data ³ 02/06/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Descri‡…o ³ Retorna o titulo do campo cadastrado no SX3.					³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Sintaxe   ³ RetTitle																	³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		  ³ SIGACON																	   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function RetTitle(cCampo,nTamanho,lRestSX3)
    Local cAlias	 := Alias()
    Local nSx3Order  := SX3->(IndexOrd())
    Local cTitulo	 := " "
    Local aArea		:=	SX3->(GetArea())
    DEFAULT lRestSX3	:=	.F.

    DbSelectArea("SX3")
    DbSetOrder(2)

    If ( MSSeek(cCampo) )
        cTitulo := X3Titulo()+Space(50)
    EndIf
    nTamanho := Iif(nTamanho == Nil,Len(X3Titulo()),nTamanho)
    cTitulo := Substr(cTitulo,1,nTamanho)
    If lRestSX3
        RestArea(aArea)
    Else
        DbSetOrder(nSX3Order)
    Endif
    DbSelectArea(cAlias)
    cTitulo := OemToAnsi(cTitulo)

Return cTitulo

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³ Fun‡…o			³ValorContab Autor ³ Pilar S. Albaladejo		 ³ Data ³ 23/09/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Descri‡…o ³ Imprime saldos contabeis com sinal de acordo com parametro ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Sintaxe   ³ ValorContab(nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal, 	³±±
    ±±³			  ³ lEstrang,cTipo,cConta) 												³±±
    ±±³			  ³ Onde:																		³±±
    ±±³			  ³ nSaldo	= Valor a ser impresso										³±±
    ±±³			  ³ nLin 	= Linha onde sera impresso 								³±±
    ±±³			  ³ nCol 	= Coluna onde sera impresso								³±±
    ±±³			  ³ nTamanho= Tamanho maximo disponivel para impressao				³±±
    ±±³			  ³ nDecimais = Numero de decimais a serem impressas				³±±
    ±±³			  ³ lSinal	= Valor sera impresso com sinal ou nao (Os sinais	³±±
    ±±³			  ³			  poderao ser D/C ou - ou ()								³±±
    ±±³			  ³ lEstrang= Considera ou nao picture de lingua estrangeira	³±±
    ±±³			  ³ cTipo	= Indica se o tipo de dado sera D/C (quando nao 	³±±
    ±±³			  ³			  existe registro para identIfica-lo=final de arqui³±±
    ±±³			  ³			  vo e impressao dos totais -> devera ser usado 	³±±
    ±±³			  ³			  somente com lSinal = .F. 																					 ³±±
    ±±³			  ³ cConta	= Indica o deve posicionar registro no SI1			³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso				³ SIGACON																																												 ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ValorContab( nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal,lEstrang,cTipo,cConta)

    Local cOldAlias := ALIAS()
    Local nReg
    Local nOrder := SI1->(IndexOrd())
    Local nCol1
    Local cPict

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ VerIfica se os tamanhos foram passados ou encontrados		  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If nTamanho == Nil
        nTamanho 		 := 14
        nDecimais		 := 2
    EndIf

    nSaldo			 := Iif(nSaldo == NIl, 0, nSaldo)
    lEstrang 					:= Iif(lEstrang == Nil, .F., lEstrang)
    cTipo 			 := Iif(cTipo==Nil, Space(1), cTipo)

    DbSelectArea("SI1")
    DbSetOrder(1)
    nReg := Recno()

    If !Empty(cConta)
        DbSeek(cFilial+cConta)
    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Tipo D -> Default (D/C)												  ³
    //³ Tipo S -> Imprime saldo com sinal									  ³
    //³ Tipo P -> Imprime saldo entre parenteses (qdo. negativo)	  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    cTipoSinal := GetMV("MV_TPVALOR")       // Assume valor default

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Retorna a picture. Caso nao exista espaco, retira os pontos  ³
    //³ separadores de dezenas, centenas e milhares 					  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    cPicture := TmContab(nSaldo,nTamanho,nDecimais)

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³* Alguns valores, apesar de  terem sinal devem ser impressos  ³
    //³ sem sinal (lSinal). Ex: valores de colunas Debito e Credito  ³
    //³* Se estiver com a opcao de lingua estrangeira (lEstrang) a   ³
    //³ picture sera invertida para exibir valores: 999,999,999.99   ³
    //³* O tipo de sinal "D" - default nao leva em consideracao a    ³
    //³ a natureza da conta. Dessa forma valores negativos serao	  ³
    //³ impressos sem sinal, e ao seu lado "D" (Devedor) e valores   ³
    //³ positivos terao um "C" (Credito) impresso ao seu lado.       ³
    //³* O tipo de Sinal "P" - Parenteses, imprimira valores de saldo³
    //³  invertidos da condicao normal da conta entre parenteses.	  ³
    //³* O tipo de Sinal "S" - Sinal, imprimira valores de saldo in- ³
    //³  vertidos da condicao normal da conta com sinal - 			  ³
    //³OBS: Se a conta for ANORMAL (I1_ESTOUR == "S"), os sinais se- ³
    //³rao invertidos.															  ³
    //³EXEMPLOS  -  EXEMPLOS  -  EXEMPLOS	-	EXEMPLOS  - EXEMPLOS   ³
    //³Cond Normal 			Saldo 			 Default 		  Sinal				Parenteses					  ³
    //³	  D			  -1000	  1000 D 		1000		1000				 ³
    //³	D				 1000 	1000 C		-1000 	(1000)			  ³
    //³	C				-1000 	1000 D		-1000 	(1000)			  ³
    //³	C				 1000 	1000 C		 1000 	 1000 			  ³
    //³CONTA "ANORMAL" ou "REDUTORA"                                 ³
    //³Cond Normal 	Saldo 	Default		Sinal 	Parenteses		  ³
    //³  D				-1000 		  1000 D 	  -1000	  (1000) 			 ³
    //³  D				 1000 	1000 C		 1000 	 1000 			  ³
    //³  C				-1000 	1000 D		 1000 	 1000 			  ³
    //³  C				 1000 	1000 C		-1000 	(1000)			  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Neste caso (Default), nao importa a natureza da conta! Saldos³
    //³ devedores serao impressos com "D" e credores com "C".        ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    // Neste caso, nao importa a natureza da conta!!
    If cTipoSinal == "D"                                    //      DC (Default)
        If !lEstrang
            cPict := "@E " + cPicture
        Else
            cPict		:= cPicture
        EndIf
        @ nLin, nCol pSay Abs(nSaldo) Picture cPict
        nCol1 := nCol + Len(cPicture) + 1
        If lSinal
            If nSaldo < 0
                @ nLin, nCol1 pSay "D"
            ElseIf nSaldo > 0
                @ nLin, nCol1 pSay "C"
            EndIf
        EndIf
    Else
        If SI1->I1_ESTOUR != "S"
            If cTipo == "D" .Or. SI1->I1_NORMAL == "D"                      // Conta Devedora
                If (cTipoSinal) == "S"                  //      Sinal
                    If lSinal
                        nSaldo := nSaldo * (-1)
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If lSinal
                        nSaldo := nSaldo * (-1) 		  // a Picture so exibe parenteses para numeros negativos
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            ElseIf cTipo == "C" .Or. SI1->I1_NORMAL == "C"          // Conta Credora
                If (cTipoSinal) == "S"                  //      Sinal
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            EndIf
        ElseIf SI1->I1_ESTOUR == "S"                    // CONTA REDUTORA
            If cTipo == "D" .Or. SI1->I1_NORMAL == "D"                      // Conta Devedora
                If (cTipoSinal) == "S"                  //      Sinal
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            ElseIf cTipo == "C" .Or. SI1->I1_NORMAL == "C"          // Conta Credora
                If (cTipoSinal) == "S"                  //      Sinal
                    If lSinal
                        nSaldo := nSaldo * (-1)
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If lSinal
                        nSaldo := nSaldo * (-1)
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            EndIf
        EndIf
    EndIf

    DbSelectArea("SI1")
    DbGoTo(nReg)
    DbSetOrder(nOrder)

    DbSelectArea( cOldAlias )

Return

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³ Fun‡…o	  ³TmContab  ³ Autor ³ Pilar S. Albaladejo	³ Data ³ 23/09/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Descri‡…o ³ Retorna a picture a ser impressa e corta pontos se nao ti- ³±±
    ±±³			  ³ ver espaco 																³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Sintaxe   ³ TmContab(cCampo,nTamanho,nDecimais)								³±±
    ±±³			  ³ Onde:																		³±±
    ±±³			  ³ cCampo	= Campo a ser impresso										³±±
    ±±³			  ³ nTamanho= Tamanho maximo disponivel para impressao			³±±
    ±±³			  ³ nDecimais = Numero de decimais a serem impressas				³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		  ³ SIGACON 																	³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function TMContab(cCampo,nTamanho,nDecimais)

    Local cCpo

    nDecimais:= Iif(nDecimais==Nil,GetMv("MV_CENT"),nDecimais)

    cDecimais:= Iif(nDecimais==0,"","."+Replicate("9",nDecimais))
    cPicture := Iif(GetMv("MV_MILHAR"),"999,999,999,999,999",;
        "999999999999999")+cDecimais
    cCpo	:= Transform(cCampo,cPicture)

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ VerIfica se ha tamanho suficiente para imprimir. Se nao 	  ³
    //³ existir tamanho suficiente, serao cortados pontos e virgulas ³
    //³ para caber.																  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    While  (Len(AllTrim(cCpo)) > nTamanho ) .And. ( AT(",",cPicture) > 0 )
        cPicture := Substr(cPicture,1,AT(",",cPicture)-1)+;
            Substr(cPicture,AT(",",cPicture)+1,20)
        cCpo	:= (Transform(cCampo,cPicture))
    End

    cPicture 		 :=		Right(cPicture,nTamanho)
    cPicture 		 :=		Iif(Substr(cPicture,1,1)=',',"9"+Substr(cPicture,2),cPicture)
    If Len(LTrim(cCpo)) > nTamanho
        cPicture 		 :=		"®"+Substr(cPicture,2,20)
    EndIf

Return cPicture

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³fDesc 	³ Autor ³Mauro(1a. Versao)	    ³ Data ³14/10/1998³±±
				±±³          ³      	³ Autor ³Marinaldo(2a.Versao)   ³ Data ³03/04/2003³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³Funcao para Trazer a Descricao/Conteudo de Campos			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³<Vide Parametros Formais >								  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³Gen‚rico 												  	  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDesc( cAlias , cChave , cCampoRet , nBytes , cFil , nOrder , lPosSx3 )

				Local cAliasfDesc	:= ""
				Local cFieldFil		:= ""
				Local cContextFil	:= ""
				Local lChkBytes		:= ( ValType( nBytes ) == "N" )
				Local lChkOrder		:= ( ValType( nOrder ) == "N" )
				Local lChkSX5		:= ( SubStr( cAlias , 1 , 1 ) == "X" )
				Local lIsChar		:= .F.
				Local lFound		:= .F.
				Local nSvOrder		:= 1
				Local nSx3Rec		:= 0
				Local uRet			:= NIL

				DEFAULT lPosSx3		:= .T.

    IF ( lChkSX5 )
					cAliasfDesc := "SX5"
    Else
					cAliasfDesc := cAlias
    EndIF

				cFieldFil	:= ( PrefixoCpo( cAliasfDesc ) + "_FILIAL" )
    IF ( lPosSx3 )
					nSx3Rec		:= SX3->( Recno() )
    EndIF
				cContextFil	:= GetSx3Cache( cFieldFil , "X3_CONTEXT" )
    IF ( lPosSx3 )
					SX3->( MsGoto( nSx3Rec ) )
    EndIF
    IF ( ( cContextFil <> NIL ) .and. !( cContextFil $ "Vv" ) )
					cFil := xFilial( cAliasfDesc , cFil )
    Else
					cFil := ""
    EndIF

    IF ( lChkOrder )
					nSvOrder := ( cAliasfDesc )->( IndexOrd() )
					( cAliasfDesc )->( dbSetOrder( nOrder ) )
    EndIF

				lFound	:= ( cAliasfDesc )->( MsSeek( cFil + cChave , .F. ) )
				uRet 	:= ( cAliasfDesc )->( &( cCampoRet ) )
				lIsChar	:= ( ValType( uRet ) == "C" )
    IF ( ( lChkBytes ) .and. ( lIsChar ) )
					uRet := SubStr( uRet , 1 , nBytes )
    ElseIF ( !( lFound ) .and. ( lIsChar ) )
					/*
					10        20
					12345678901234567890
					*/
        uRet := "                    "
    EndIF

    IF ( ( lChkOrder ) .and. !( nSvOrder == nOrder ) )
        ( cAliasfDesc )->( dbSetOrder( nSvOrder ) )
    EndIF

Return( uRet )

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³CriaCtaSup³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 23/03/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Gera a conta pai da conta atual									  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Generico 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function CriaCtaSup(cCodigo)

    Local cCod
    Local cAlias	 := Alias()
    Local nOrder	 := IndexOrd()
    Local nReg					:= Recno()
    Local nCont     := 0

    cCodigo						:= AllTrim(cCodigo)
    DbSelectArea("SI1")
    DbSetOrder(1)

    For nCont := 1 to Len(cCodigo)
        cCod	  := Substr(cCodigo,1,Len(cCodigo)-nCont)
        cCod	:= cCod + Space(20-Len(cCod))
        If DbSeek(xFilial()+cCod,.f.)
            Exit
        EndIf
    Next nCont

    DbSelectArea(cAlias)
    DbSetOrder(nOrder)
    DbGoTo(nReg)
Return cCod

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³HeadCnab2 ³ Autor ³ Eduardo Riera 		  ³		³ 16/04/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Cria o Arquivo padrao Cnab Modelo 2								  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³HeadCnab2 ( cArquivo, cLayOut )									  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametro ³ ExpC1 : Nome do arquivo a ser gerado							  ³±±
    ±±³			 ³ ExpC2 : Nome do arquivo de configuracao						  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno	 ³ Handle do arquivo gerado.											  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ GENERICO 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/

Function HeadCnab2(cArquivo,cLayOut)

    Local nHandle	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := ""
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHandle := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHandle,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,3,1) == "H" )
                        aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,30),;
                            SubStr(cBuffer,35,255)})
                    EndIf
                Else
                    If ( SubStr(cBuffer,3,1) == "H" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHandle)
    EndIf
    nHandle := FCreate(cArquivo)
    If nHandle > 0
        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(AllTrim(aLayOut[nCntFor,3]))
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
                    cBuffer := ""
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                        EndIf
                    Next nCntFor2
                    cBuffer += Chr(13)+Chr(10)
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                EndIf
            End Sequence
        Next nCntFor
        ErrorBlock(bBlock)
    Endif
Return(nHandle)

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³HeadLote2 ³ Autor ³ Claudio Donizete		  ³		³ 27/12/05 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Cria Header do lote de registro no arq Cnab Modelo 2		  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³HeadLote2 ( nHdlSaida, cLayOut )									  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametro ³ ExpN1 : Handle do arquivo de saida								  ³±±
    ±±³			 ³ ExpC2 : Nome do arquivo de configuracao						  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno	 ³ Handle do arquivo gerado.											  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ GENERICO 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/

Function HeadLote2(nHdlSaida,cLayOut)

    Local nHdlLay	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := ""
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,2,1)=="1" )
                        If ( SubStr(cBuffer,3,1) == "H" )
                            aadd(aLayOut, {SubStr(cBuffer,02,03), SubStr(cBuffer,05,30), SubStr(cBuffer,35,255) } )
                        EndIf
                    Endif
                Else
                    If ( SubStr(cBuffer,3,1) == "H" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    For nCntFor := 1 To Len(aLayOut)
        Begin Sequence
            lFormula := &(AllTrim(aLayOut[nCntFor,3]))
            If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
                cBuffer := ""
                For nCntFor2 := 1 To Len(aDetalhe)
                    If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                        xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
                        If ( Empty(xConteudo) )
                            xConteudo := ""
                        Else
                            xConteudo := &(AllTrim(xConteudo))
                        EndIf
                        nPosIni   := Val(aDetalhe[nCntFor2,3])
                        nPosFim   := Val(aDetalhe[nCntFor2,4])
                        nDecimal  := Val(aDetalhe[nCntFor2,5])
                        nTamanho  := nPosFim-nPosIni+1
                        Do Case
                        Case ValType(xConteudo) == "D"
                            xConteudo := GravaData(xConteudo,.F.)
                        Case ValType(xConteudo) == "N"
                            xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                        EndCase
                        xConteudo := SubStr(xConteudo,1,nTamanho)
                        xConteudo := PadR(xConteudo,nTamanho)
                        cBuffer += xConteudo
                    EndIf
                Next nCntFor2
                cBuffer += Chr(13)+Chr(10)
                Fwrite(nHdlSaida,cBuffer,Len(cBuffer))
            EndIf
        End Sequence
    Next nCntFor
    ErrorBlock(bBlock)
Return(nHdlSaida)

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³DetCnab2	³ Autor ³ Eduardo Riera 		  ³		³ 16/04/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Inseri as linhas de detalhe do CNAB Modelo 2. 				  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³DetCnab2( nHandle , cLayOut )										  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametro ³ ExpC1 : Handle do Arquivo Criado pela HeadCnab2 			  ³±±
    ±±³			 ³ ExpC2 : Nome do arquivo de configuracao						  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno	 ³ Void																		  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ GENERICO 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function DetCnab2(nHandle,cLayOut,lIdCnab,cAlias)

    Local nHdlLay	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := ""
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )
    Local aGetArea  := GetArea()
    Local cIdCnab
    Local aArea
    Local nOrdem

    DEFAULT cAlias 	:= ""
    DEFAULT lIdCnab 	:= .F.
    Private xConteudo := ""

    nQtdLinLote := If(Type("nQtdLinLote") != "N",0,nQtdLinLote)

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,3,1) == "D" )
                        aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,30),;
                            SubStr(cBuffer,35,255)})
                    EndIf
                Else
                    If ( SubStr(cBuffer,3,1) == "D" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    If nHandle > 0
        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(AllTrim(aLayOut[nCntFor,3]))
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="D" )
                    cBuffer := ""
                    // So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
                    If !Empty(cAlias) .And. lIdCnab .And. Empty((cAlias)->&(Right(cAlias,2)+"_IDCNAB"))
                        // Gera identificador do registro CNAB no titulo enviado
                        nOrdem := If(Alltrim(Upper(cAlias))=="SE1",16,11)
                        cIdCnab := GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
                        // Garante que o identificador gerado nao existe na base
                        dbSelectArea(cAlias)
                        aArea := (cAlias)->(GetArea())
                        dbSetOrder(nOrdem)
                        While (cAlias)->(MsSeek(xFilial(cAlias)+cIdCnab))
                            ConOut("Id CNAB " + cIdCnab + " já existe para o arquivo " + cAlias + ". Gerando novo número ")
                            If ( __lSx8 )
                                ConfirmSX8()
                            EndIf
                            cIdCnab := GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
                        EndDo
                        (cAlias)->(RestArea(aArea))
                        Reclock(cAlias)
                        (cAlias)->&(Right(cAlias,2)+"_IDCNAB") := cIdCnab
                        MsUnlock()
                        ConfirmSx8()
                        lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no
                        // titulo enviado
                    Endif
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := aDetalhe[nCntFor2,6]
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                        EndIf
                    Next nCntFor2
                    cBuffer += Chr(13)+Chr(10)
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                    nQtdLinLote++
                EndIf
            End Sequence
        Next nCntFor
        ErrorBlock(bBlock)
    Endif
    RestArea(aGetArea)
Return(.T.)

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³RodaCnab2 ³ Autor ³ Eduardo Riera 		  ³		³ 16/04/98³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Fecha o arquivo CNAB Modelo 2								  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³RodaCnab2( nHandle , cLayOut ) 							  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametro ³ ExpC1 : Handle do Arquivo Criado pela HeadCnab2 			  ³±±
    ±±³			 ³ ExpC2 : Nome do arquivo de configuracao					  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno	 ³ Void														  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ GENERICO 												  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function RodaCnab2(nHandle,cLayOut,lQuebra)

    Local nHdlLay	:= 0
    Local lContinua	:= .T.
    Local cBuffer	:= ""
    Local aLayOut	:= {}
    Local aDetalhe  := {}
    Local nCntFor	:= 0
    Local nCntFor2  := 0
    Local lFormula  := .F.
    Local nPosIni	:= 0
    Local nPosFim	:= 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	:= ErrorBlock()
    Local bErro 	:= ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    //-- Variaveis para tratamento de geracao de Chr(10) + Chr(13) para ultima linha gerada
    Local nLHead 	:= nCntFor
    Local nLDet		:= nCntFor2
    Local nLUltLin	:= nCntFor2

    //-- Determina se gera Chr(10) + Chr(13) para as linhas geradas
    DEFAULT	lQuebra	:= .T.

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,3,1) == "T" )
                        aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,30),;
                            SubStr(cBuffer,35,255)})

                    EndIf
                Else
                    If ( SubStr(cBuffer,3,1)=="T" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    aSort(aLayOut,,,{|x,y| x[1]>y[1]})
    If nHandle > 0

        //-- Obtem a ultima posicao da linha gerada no arquivo
        IF !lQuebra
            For nCntFor := 1 To Len(aLayOut)
                Begin Sequence
                    lFormula := &(aLayOut[nCntFor,3])
                    If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
                        cBuffer := ""
                        For nCntFor2 := 1 To Len(aDetalhe)
                            If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                                xConteudo := (aDetalhe[nCntFor2,6])
                                If ( Empty(xConteudo) )
                                    xConteudo := ""
                                Else
                                    xConteudo := &(AllTrim(xConteudo))
                                EndIf
                                nPosIni   := Val(aDetalhe[nCntFor2,3])
                                nPosFim   := Val(aDetalhe[nCntFor2,4])
                                nDecimal  := Val(aDetalhe[nCntFor2,5])
                                nTamanho  := nPosFim-nPosIni+1
                                Do Case
                                Case ValType(xConteudo) == "D"
                                    xConteudo := GravaData(xConteudo,.F.)
                                Case ValType(xConteudo) == "N"
                                    xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                                EndCase
                                xConteudo := SubStr(xConteudo,1,nTamanho)
                                xConteudo := PadR(xConteudo,nTamanho)
                                cBuffer += xConteudo
                                //- Obtem a ultima posicao da linha gerada no arquivo
                                nLDet	:= nCntFor2
                                nLHead 	:= nCntFor
                            EndIf
                        Next nCntFor2

                    EndIf
                End Sequence
            Next nCntFor
        Endif

        nLUltLin:= 0

        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(aLayOut[nCntFor,3])
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
                    cBuffer := ""
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := (aDetalhe[nCntFor2,6])
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                            nLUltLin:= nCntFor2
                        EndIf

                    Next nCntFor2

                    //-- Gera Chr(13)+Chr(10) para todas as linhas ou para as N-1 linhas
                    If ( lQuebra ) .OR. ( !lQuebra .AND. !( (nLUltLin == nLDet) .and. (nCntFor == nLHead)) )
                        cBuffer += Chr(13)+Chr(10)
                    EndIf
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                EndIf
            End Sequence
        Next nCntFor

        ErrorBlock(bBlock)
        FClose(nHandle)
    Endif
Return(.T.)

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³RodaLote2 ³ Autor ³ Claudio Donizete 	  ³		³ 27/12/05 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Gera Trailler de Lote CNAB Modelo 2								  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³RodaLote2( nHandle , cLayOut ) 									  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametro ³ ExpC1 : Handle do Arquivo Criado pela HeadCnab2 			  ³±±
    ±±³			 ³ ExpC2 : Nome do arquivo de configuracao						  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno	 ³ Void																		  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ GENERICO 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function RodaLote2(nHandle,cLayOut)

    Local nHdlLay	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := .F.
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,2,1) != "0" )		 //	If ( SubStr(cBuffer,2,1)=="1" )
                        If ( SubStr(cBuffer,3,1) == "T" )
                            aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                                SubStr(cBuffer,05,30),;
                                SubStr(cBuffer,35,255)})
                        EndIf
                    Endif
                Else
                    If ( SubStr(cBuffer,3,1)=="T" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    aSort(aLayOut,,,{|x,y| x[1]>y[1]})
    If nHandle > 0
        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(aLayOut[nCntFor,3])
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
                    cBuffer := ""
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := (aDetalhe[nCntFor2,6])
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                        EndIf
                    Next nCntFor2
                    cBuffer += Chr(13)+Chr(10)
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                EndIf
            End Sequence
        Next nCntFor
        ErrorBlock(bBlock)
    Endif
Return(.T.)

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o    ³ReadCnab2 ³ Autor ³ Eduardo Riera         ³      ³ 16/04/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Realiza a Leitura da configura‡ao CNAB Modelo 2             ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe   ³ReadCnab2( nHandle , cLayOut )                              ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametro ³ ExpC1 : Handle do Arquivo a ser lido                       ³±±
    ±±³          ³ ExpC2 : Nome do arquivo de configuracao                    ³±±
    ±±³          ³ ExpN3 : Tamanho maximo da linha                            ³±±
    ±±³          ³ ExpA4 : Atributos do arquivo de configuracao               ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³ Matriz                                                     ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ GENERICO                                                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ReadCnab2(nHandle,cLayOut,nMaxLn,aLayOut)

    Local nHdlLay   := 0
    Local lContinua := .T.
    Local cBuffer   := ""
    Local nCntFor   := 0
    Local nPosIni   := 0
    Local nPosFim   := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local nPosSeg   := 0
    Local aSegmento := {}
    Local aDetalhe  := {}
    Local cLinUlt   := ""
    Local cLinAtu   := ""
    Local nCntFor2  := 0
    Local cIdent    := ""
    Local xTITULO   := ""
    Local xTIPO     := ""
    Local xOCORRENCI:= ""
    Local xDATA     := "000000"
    Local xVALOR    := 0.00
    Local xDESPESA  := 0.00
    Local xDESCONTO := 0.00
    Local xABATIMENT:= 0.00
    Local xJUROS    := 0.00
    Local xMULTA    := 0.00
    Local xNOSSONUM := ""
    Local xRESERVADO:= ""
    Local xValIof   := 0.00
    Local xValCC    := 0.00
    Local xDataCred := "000000"
    Local xMotivo   := ""
    Local xBuffer   := ""
    Local nLeitura  := 0					// Numero de Leituras Efetuadas
    Local lSegValido:= .F.				// Controle de Leitura de segmentos validos
    Local nLidosBco := 0					// Numero de Bytes lidos do Arquivo de Retorno
    Local xAUTENTICA:= ""
    Local aBuffer 	 := {}
    Local xCGC 		 := ""
    Local cChave    := ""
    Local aDirtmp   := {}
    Local xBANCO	 := ""
    Local xAGENCIA  := ""
    Local xCONTA	 := ""
    Local aHeadL	 := Array(3,5)		//Array das posicoes de Banco, Agencia e Conta no Header para a baixa
    Local aBanco	 := Array(3)		//Dados bancarios para a baixa (coletados no header)
    Local lHeadL	 := ( AllTrim( Upper( FunName() ) ) != "FINR650" )
    Local xCGCH		 := ""
    Local xCODBAR	 := ""

    Default nMaxLn 	 := 1000
    Default aLayOut  := {}

    Private xConteudo  := ""

    If ( File(cLayOut) )

        If Len(aLayOut) == 0
            aDirTmp	:= Directory(cLayOut)
        ELse
            aDirTmp := AClone(aLayOut)
        EndIf

        // Inicializa flag que indica se possui dados bancarios para baixa - Header de Lote
        aHeadL[ 1, 5 ] := .F.
        aHeadL[ 2, 5 ] := .F.
        aHeadL[ 3, 5 ] := .F.

        cChave := aDirTmp[1][1]+str(aDirTmp[1][2])+DtoC(aDirTmp[1][3])+aDirTmp[1][4]

        If Empty(__aLayCNAB) .Or. cChave != __aLayCNAB[1]
            nHdlLay := FOpen(cLayOut,64)
            While ( lContinua )
                cBuffer := FreadStr(nHdlLay,502)
                If ( !Empty(cBuffer) )
                    If ( SubStr(cBuffer,1,1)=="1" )
                        If ( SubStr(cBuffer,3,1)=="D" )
                            aadd(aSegmento,{AllTrim(SubStr(cBuffer,02,03)),;
                                AllTrim(SubStr(cBuffer,35,255)),0,0})
                            aadd(aDetalhe,Array(20,4))
                        EndIf
                    Else
                        If ( SubStr(cBuffer,3,1)=="D" )
                            nPosIni  := Val(SubStr(cBuffer,20,03))
                            nPosFim  := Val(SubStr(cBuffer,23,03))
                            nDecimal := Val(SubStr(cBuffer,26,01))
                            nTamanho := nPosFim - nPosIni +1
                            xConteudo:= AllTrim(SubStr(cBuffer,27,255))
                            nPosSeg := AScan(aSegmento,{|x| x[1]==Alltrim(SubStr(cBuffer,02,03))})
                            If ( nPosSeg != 0 )
                                Do Case
                                Case xConteudo=="TITULO"
                                    aDetalhe[nPosSeg,1,1] := "TITULO"
                                    aDetalhe[nPosSeg,1,2] := nPosIni
                                    aDetalhe[nPosSeg,1,3] := nTamanho
                                    aDetalhe[nPosSeg,1,4] := nDecimal
                                Case  xConteudo=="ESPECIE"
                                    aDetalhe[nPosSeg,2,1] := "ESPECIE"
                                    aDetalhe[nPosSeg,2,2] := nPosIni
                                    aDetalhe[nPosSeg,2,3] := nTamanho
                                    aDetalhe[nPosSeg,2,4] := nDecimal
                                Case xConteudo=="OCORRENCIA"
                                    aDetalhe[nPosSeg,3,1] := "OCORRENCIA"
                                    aDetalhe[nPosSeg,3,2] := nPosIni
                                    aDetalhe[nPosSeg,3,3] := nTamanho
                                    aDetalhe[nPosSeg,3,4] := nDecimal
                                Case xConteudo=="DATA"
                                    aDetalhe[nPosSeg,4,1] := "DATA"
                                    aDetalhe[nPosSeg,4,2] := nPosIni
                                    aDetalhe[nPosSeg,4,3] := nTamanho
                                    aDetalhe[nPosSeg,4,4] := nDecimal
                                Case xConteudo=="VALOR"
                                    aDetalhe[nPosSeg,5,1] := "VALOR"
                                    aDetalhe[nPosSeg,5,2] := nPosIni
                                    aDetalhe[nPosSeg,5,3] := nTamanho
                                    aDetalhe[nPosSeg,5,4] := nDecimal
                                Case xConteudo=="DESPESA"
                                    aDetalhe[nPosSeg,6,1] := "DESPESA"
                                    aDetalhe[nPosSeg,6,2] := nPosIni
                                    aDetalhe[nPosSeg,6,3] := nTamanho
                                    aDetalhe[nPosSeg,6,4] := nDecimal
                                Case xConteudo=="DESCONTO"
                                    aDetalhe[nPosSeg,7,1] := "DESCONTO"
                                    aDetalhe[nPosSeg,7,2] := nPosIni
                                    aDetalhe[nPosSeg,7,3] := nTamanho
                                    aDetalhe[nPosSeg,7,4] := nDecimal
                                Case xConteudo=="ABATIMENTO"
                                    aDetalhe[nPosSeg,8,1] := "ABATIMENTO"
                                    aDetalhe[nPosSeg,8,2] := nPosIni
                                    aDetalhe[nPosSeg,8,3] := nTamanho
                                    aDetalhe[nPosSeg,8,4] := nDecimal
                                Case xConteudo=="JUROS"
                                    aDetalhe[nPosSeg,9,1] := "JUROS"
                                    aDetalhe[nPosSeg,9,2] := nPosIni
                                    aDetalhe[nPosSeg,9,3] := nTamanho
                                    aDetalhe[nPosSeg,9,4] := nDecimal
                                Case xConteudo=="MULTA"
                                    aDetalhe[nPosSeg,10,1] := "MULTA"
                                    aDetalhe[nPosSeg,10,2] := nPosIni
                                    aDetalhe[nPosSeg,10,3] := nTamanho
                                    aDetalhe[nPosSeg,10,4] := nDecimal
                                Case xConteudo=="IOF"
                                    aDetalhe[nPosSeg,11,1] := "IOF"
                                    aDetalhe[nPosSeg,11,2] := nPosIni
                                    aDetalhe[nPosSeg,11,3] := nTamanho
                                    aDetalhe[nPosSeg,11,4] := nDecimal
                                Case xConteudo=="OUTROSCREDITOS"
                                    aDetalhe[nPosSeg,12,1] := "OUTROSCREDITOS"
                                    aDetalhe[nPosSeg,12,2] := nPosIni
                                    aDetalhe[nPosSeg,12,3] := nTamanho
                                    aDetalhe[nPosSeg,12,4] := nDecimal
                                Case xConteudo=="DATACREDITO"
                                    aDetalhe[nPosSeg,13,1] := "DATACREDITO"
                                    aDetalhe[nPosSeg,13,2] := nPosIni
                                    aDetalhe[nPosSeg,13,3] := nTamanho
                                    aDetalhe[nPosSeg,13,4] := nDecimal
                                Case xConteudo=="MOTIVO"
                                    aDetalhe[nPosSeg,14,1] := "MOTIVO"
                                    aDetalhe[nPosSeg,14,2] := nPosIni
                                    aDetalhe[nPosSeg,14,3] := nTamanho
                                    aDetalhe[nPosSeg,14,4] := nDecimal
                                Case xConteudo=="NOSSONUMERO"
                                    aDetalhe[nPosSeg,15,1] := "NOSSONUMERO"
                                    aDetalhe[nPosSeg,15,2] := nPosIni
                                    aDetalhe[nPosSeg,15,3] := nTamanho
                                    aDetalhe[nPosSeg,15,4] := nDecimal
                                Case xConteudo=="RESERVADO"
                                    aDetalhe[nPosSeg,16,1] := "RESERVADO"
                                    aDetalhe[nPosSeg,16,2] := nPosIni
                                    aDetalhe[nPosSeg,16,3] := nTamanho
                                    aDetalhe[nPosSeg,16,4] := nDecimal
                                Case xConteudo=="SEGMENTO"
                                    aSegmento[nPosSeg,3] := nPosIni
                                    aSegmento[nPosSeg,4] := nTamanho
                                Case xConteudo=="AUTENTICACAO"
                                    aDetalhe[nPosSeg,17,1] := "AUTENTICACAO"
                                    aDetalhe[nPosSeg,17,2] := nPosIni
                                    aDetalhe[nPosSeg,17,3] := nTamanho
                                    aDetalhe[nPosSeg,17,4] := nDecimal
                                Case xConteudo=="CGC"
                                    aDetalhe[nPosSeg,18,1] := "CGC"
                                    aDetalhe[nPosSeg,18,2] := nPosIni
                                    aDetalhe[nPosSeg,18,3] := nTamanho
                                    aDetalhe[nPosSeg,18,4] := nDecimal
                                Case xConteudo=="CGCH"
                                    aDetalhe[nPosSeg,19,1] := "CGCH"
                                    aDetalhe[nPosSeg,19,2] := nPosIni
                                    aDetalhe[nPosSeg,19,3] := nTamanho
                                    aDetalhe[nPosSeg,19,4] := nDecimal
                                Case xConteudo=="CODBAR"
                                    aDetalhe[nPosSeg,20,1] := "CODBAR"
                                    aDetalhe[nPosSeg,20,2] := nPosIni
                                    aDetalhe[nPosSeg,20,3] := nTamanho
                                    aDetalhe[nPosSeg,20,4] := nDecimal
                                EndCase
                            EndIf
                            //Dados bancarios para a baixa
                        ElseIf ( SubStr(cBuffer,3,1)=="H" )
                            nPosIni  := Val(SubStr(cBuffer,20,03))
                            nPosFim  := Val(SubStr(cBuffer,23,03))
                            nDecimal := Val(SubStr(cBuffer,26,01))
                            nTamanho := nPosFim - nPosIni +1
                            xConteudo:= AllTrim(SubStr(cBuffer,27,255))
                            lHeadL   := .T.
                            Do Case
                            Case xConteudo=="BANCO"
                                aHeadL[1,1] := "BANCO"
                                aHeadL[1,2] := nPosIni
                                aHeadL[1,3] := nTamanho
                                aHeadL[1,4] := nDecimal
                                aHeadL[1,5] := .T.
                            Case xConteudo=="AGENCIA"
                                aHeadL[2,1] := "AGENCIA"
                                aHeadL[2,2] := nPosIni
                                aHeadL[2,3] := nTamanho
                                aHeadL[2,4] := nDecimal
                                aHeadL[2,5] := .T.
                            Case xConteudo=="CONTA"
                                aHeadL[3,1] := "CONTA"
                                aHeadL[3,2] := nPosIni
                                aHeadL[3,3] := nTamanho
                                aHeadL[3,4] := nDecimal
                                aHeadL[3,5] := .T.
                            EndCase
                        EndIf
                    EndIf
                Else
                    lContinua := .F.
                EndIf
            EndDo
            FClose(nHdlLay)
            __aLayCNAB	:=	{}
            Aadd(__aLayCNAB,cChave)
            Aadd(__aLayCNAB,aSegmento)
            Aadd(__aLayCNAB,aDetalhe)
            Aadd(__aLayCNAB,aHeadL)
            Aadd(__aLayCNAB,aBanco)
        Else
            aSegmento	:= aClone(__aLayCNAB[2])
            aDetalhe	:= aClone(__aLayCNAB[3])
            aHeadL		:= aClone(__aLayCNAB[4])
            aBanco		:= aClone(__aLayCNAB[5])
        EndIf

    EndIf

    lContinua := .T.

    While ( lContinua )
        aLinha		:= LerLinha(nHandle,nMaxLn)
        cBuffer 		:= aLinha[1]
        nLidosBco 	:= aLinha[2]
        lSegValido	:= .F.
        nLeitura++
        If (!Empty(cBuffer))
            //Lendo no Header de Lote o Banco, Agencia e Conta para baixa
            If Substr(cBuffer,8,1) == "1" .And. lHeadL
                For nCntFor := 1 To Len(aHeadL)
                    If aHeadL[nCntFor,5]
                        nPosIni := aHeadL[nCntFor,2]
                        nTamanho:= aHeadL[nCntFor,3]
                        nDecimal:= aHeadL[nCntFor,4]
                        Do Case
                        Case aHeadL[nCntFor,1]=="BANCO"
                            xBANCO	:= SubStr(cBuffer,nPosIni,nTamanho)
                            aBanco[1] := xBANCO
                        Case aHeadL[nCntFor,1]=="AGENCIA"
                            xAGENCIA	:= SubStr(cBuffer,nPosIni,nTamanho)
                            aBanco[2] := xAGENCIA
                        Case aHeadL[nCntFor,1]=="CONTA"
                            xCONTA	:= SubStr(cBuffer,nPosIni,nTamanho)
                            aBanco[3] := xCONTA
                        EndCase
                    EndIf
                Next
                __aLayCNAB[5] := aClone( aBanco )
            Else
                //Recarrego os dados bancarios quando estiver processando o detalhe
                //Esses dados estao apenas no header e somente serao trocados quando
                //lido um novo header
                If Empty(xBanco) .and. !Empty(aBanco[1])
                    xBanco	:= aBanco[1]
                    xAgencia := aBanco[2]
                    xConta	:= aBanco[3]
                Endif

                For nCntFor := 1 To Len(aSegmento)
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³                      Teste de Quebra                         ³
                    //³  1D(n)                                                       ³
                    //³  ------------------------------                              ³
                    //³  |(n)-------------------------  -> Linha Detalhe  =  Conj.   ³
                    //³  | 1 |------------------------A - Identificador    | da      ³
                    //³  | 2 |------------------------B - Identificador    | Linha   ³
                    //³  | 3 |------------------------C - Identificador    | Detalhe ³
                    //³  |   -------------------------                    =          ³
                    //³  |                                                           ³
                    //³  ------------------------------                              ³
                    //³  2D(n)                                                       ³
                    //³  ------------------------------                              ³
                    //³  |(n)-------------------------  -> Linha Detalhe  =  Conj.   ³
                    //³  | 1 |------------------------A - Identificador    | da      ³
                    //³  | 2 |------------------------B - Identificador    | Linha   ³
                    //³  | 3 |------------------------C - Identificador    | Detalhe ³
                    //³  |   -------------------------                    =          ³
                    //³  |                                                           ³
                    //³  ------------------------------                              ³
                    //³                                                              ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    xConteudo := SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4])
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³ Verifica a qual linha detalhe o segmento valido pertence.    ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    If ( xConteudo $ aSegmento[nCntFor,2] )
                        cLinAtu := SubStr(aSegmento[nCntFor][1],1,1)
                    EndIf
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³ Verifica se houve quebra de linha detalhe, ou se o houve re- ³
                    //³ peticao do mesmo conjunto da linha detalhe. A repeticao ocor-³
                    //³ re quando o identificador de linha repete-se.                ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    If ( (cIdent == xConteudo .Or. cLinAtu!=cLinUlt ) .And.;
                            !Empty(cIdent) .And. !Empty(cLinUlt) .And. nLeitura > 1 )
                        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        //³ Retorna a linha atual para ser relida na proxima interacao.  ³
                        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                        FSeek(nHandle,-2*(nLidosBco),1)
                        cBuffer := LerLinha(nHandle,nMaxLn)[1]
                        lContinua := .F.
                        Exit
                    EndIf
                    If ( lContinua )
                        If ( xConteudo $ aSegmento[nCntFor,2] )
                            lSegValido := .T.
                            xBuffer    += cBuffer
                            Aadd(aBuffer,cBuffer)
                            If (Empty(cIdent))
                                nLeitura := 1
                                cIdent 	:= xConteudo
                                cLinUlt  := SubStr(aSegmento[nCntFor][1],1,1)
                            EndIf
                            For nCntFor2 := 1 To Len(aDetalhe[nCntFor])
                                nPosIni := aDetalhe[nCntFor,nCntFor2,2]
                                nTamanho:= aDetalhe[nCntFor,nCntFor2,3]
                                nDecimal:= aDetalhe[nCntFor,nCntFor2,4]
                                Do Case
                                Case aDetalhe[nCntFor,nCntFor2,1]=="TITULO"
                                    xTITULO := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="NOSSONUMERO"
                                    xNOSSONUM := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="ESPECIE"
                                    xTIPO     := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="OCORRENCIA"
                                    xOCORRENCI := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DATA"
                                    xDATA := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="VALOR"
                                    xVALOR := SubStr(cBuffer,nPosIni,nTamanho)
                                    xVALOR := Val(xVALOR)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DESPESA"
                                    xDESPESA := SubStr(cBuffer,nPosIni,nTamanho)
                                    xDESPESA := Val(xDESPESA)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DESCONTO"
                                    xDESCONTO := SubStr(cBuffer,nPosIni,nTamanho)
                                    xDESCONTO := Val(xDESCONTO)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="ABATIMENTO"
                                    xABATIMENT := SubStr(cBuffer,nPosIni,nTamanho)
                                    xABATIMENT := Val(xABATIMENT)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="JUROS"
                                    xJUROS := SubStr(cBuffer,nPosIni,nTamanho)
                                    xJUROS := Val(xJUROS)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="MULTA"
                                    xMULTA := SubStr(cBuffer,nPosIni,nTamanho)
                                    xMULTA := Val(xMULTA)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="OUTROSCREDITOS"
                                    xValCC := SubStr(cBuffer,nPosIni,nTamanho)
                                    xValCC := Val(xValCC)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="IOF"
                                    xValIof := SubStr(cBuffer,nPosIni,nTamanho)
                                    xValIof := Val(xValIof)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DATACREDITO"
                                    xDATACRED := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="MOTIVO"
                                    xMOTIVO := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="RESERVADO"
                                    xRESERVADO:= SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="AUTENTICACAO"
                                    xAUTENTICA := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="CGC"
                                    xCGC:= SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="CGCH"
                                    xCGCH:= SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="CODBAR"
                                    xCODBAR:= SubStr(cBuffer,nPosIni,nTamanho)
                                EndCase
                            Next
                        EndIf
                    EndIf
                Next nCntFor
                If ( !lSegValido .And. !Empty(cIdent) )
                    lContinua := .F.
                EndIf
            Endif
        Else
            lContinua := .F.
        EndIf
    EndDo
Return({	xTITULO,xTIPO,xOCORRENCI,xDATA,xVALOR,;
        xDESPESA,xDESCONTO,xABATIMENT,xJUROS,xMULTA,;
        xNOSSONUM,xVALIOF,xVALCC,xDATACRED,xMOTIVO,;
        xRESERVADO,xBuffer,xAUTENTICA,aBuffer,xCGC,;
        xBanco,xAgencia,xConta,xCGCH,xCODBAR})

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³ GravaData³ Autor ³ Wagner Xavier 		  ³ Data ³ 26/05/92 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Determinado forma de grava‡„o para campo data.				  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³ GravaData(ExpD1,ExpL1,ExpN1)										  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpD1 := Data a ser convertida									  ³±±
    ±±³			 ³ ExpL1 := Tipo(Se .T. com Barra, se .F., sem Barra			  ³±±
    ±±³			 ³ ExpN1 := Formato (1,2,3)											  ³±±
    ±±³			 ³  Formato 1 := ddmmaa 												  ³±±
    ±±³			 ³ 			2 := mmddaa 												  ³±±
    ±±³			 ³ 			3 := aaddmm 												  ³±±
    ±±³			 ³ 			4 := aammdd 												  ³±±
    ±±³			 ³ 			5 := ddmmaaaa												  ³±±
    ±±³			 ³ 			6 := mmddaaaa												  ³±±
    ±±³			 ³ 			7 := aaaaddmm												  ³±±
    ±±³			 ³ 			8 := aaaammdd												  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Fina150																	  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function GravaData( dData, lBarra, nFormato )

    Local xData 	:= dData

    dData   := Iif( dData==Nil,dDataBase,dData )
    lBarra  := Iif( lBarra==Nil,.T.,lBarra )
    nFormato:= Iif( nFormato==Nil,1,nFormato )
    cSepar  := Iif( lBarra,"/","" )

    If !lBarra
        Do Case
        Case nFormato == 1
            xData := StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)+cSepar+SubStr(StrZero(Year(dData),4),3,2)
        Case nFormato == 2
            xData := StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)+cSepar+SubStr(StrZero(Year(dData),4),3,2)
        Case nFormato == 3
            xData := SubStr(StrZero(Year(dData),4),3,2)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)
        Case nFormato == 4
            xData := SubStr(StrZero(Year(dData),4),3,2)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)
        Case nFormato == 5
            xData := StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Year(dData),4)
        Case nFormato == 6
            xData := StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Year(dData),4)
        Case nFormato == 7
            xData := StrZero(Year(dData),4)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)
        OtherWise
            xData := StrZero(Year(dData),4)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)
        EndCase
    End
Return xData

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³ChecErr260³ Autor ³ Wagner Xavier 		  ³ Data ³ 10/11/92 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Rotina analizadora do erro											  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³Sigafin Advanced.														  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ChecErr260(e,cForm)
    If e:gencode > 0
        Help( " ",1,"ERR_FORM",,e:Description+" : "+Substr(cForm,1,20),3,1 )
        lRet:=.F.
    EndIf
    Break

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³Incrementa³ Autor ³ Wagner Xavier 		  ³ Data ³ 26/05/92 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Incrementa 1 a um determinado Numero 							  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³Incrementa(Numero) 													  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Generico 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function Incrementa(cNum)
    If PCOUNT()==0
        cNum:=StrZero(nSeq,6)
    EndIf
Return 1+Val(cNum)
				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³TesImpInf ³ Autor ³ Bruno Sobieski		³ Data ³ 17.11.98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Retorna um array com os dados dos impostos relacionados com³±±
    ±±³			 ³ o tes que ‚ pasado como parametro. Usado para Impostos nas |±±
    ±±³			 ³ Localizacoes no Exterior.								  ³±±
    ±±³			 ³ aImpFlag[n][1]-> Codigo do Imposto						  ³±±
    ±±³			 ³ 		  [n][2]-> Campo no SD1 ou SD2 onde ‚ gravado o valor |±±
    ±±³			 ³ 					  imposto.								  ³±±
    ±±³			 ³ 		  [n][3]-> Se o valor do imposto incide na Nota 	  ³±±
    ±±³			 ³ 		  [n][4]-> Se o valor do imposto incide na Duplicata  ³±±
    ±±³			 ³ 		  [n][5]-> Se o valor do imposto deve ser Creditado   ³±±
    ±±³			 ³ 		  [n][6]-> Campo no SF1 ou SF2 onde ‚ gravado o valor |±±
    ±±³			 ³ 					  imposto.								  ³±±
    ±±³			 ³ 		  [n][7]-> Campo no SD1 ou SD2 onde ‚ gravada a base  |±±
    ±±³			 ³ 					  do imposto.							  ³±±
    ±±³			 ³ 		  [n][8]-> Campo no SF1 ou SF2 onde ‚ gravada a base  |±±
    ±±³			 ³ 					  do imposto.							  ³±±
    ±±³			 ³ 		  [n][9]-> Aliquota do imposto                        ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Parametro³ cTes -> Codigo de Entrada-Saida							  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Generico Localizacoes.									  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function TesImpInf(cTes)
    Local cAlias
    Local aImpFlag :={}
    cAlias  :=Alias()
    nOrder  :=IndexOrd ()
    nReg	  :=Recno()
    SFB->(DbSetOrder(1))
    DbSelectArea("SFC")
    DbSetOrder(1)
    DbSeek(xFilial("SFC")+cTes)
    While SFC->(!eof()) .and. xFilial("SFC")== FC_FILIAL .and. cTes== FC_TES
        If SFB->(DbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
            If (cTes<="500" )
                If SD1->(FieldPos("D1_ALQIMP"+SFB->FB_CPOLVRO))  > 0
                    Aadd(aImpFlag,{SFB->FB_CODIGO,"D1_VALIMP"+SFB->FB_CPOLVRO,SFC->FC_INCNOTA,SFC->FC_INCDUPL,SFC->FC_CREDITA,"F1_VALIMP"+SFB->FB_CPOLVRO,"D1_BASIMP"+SFB->FB_CPOLVRO,"F1_BASIMP"+SFB->FB_CPOLVRO,SFB->FB_ALIQ,"D1_ALQIMP"+SFB->FB_CPOLVRO,SFC->FC_PROV,SFC->FC_INCIMP})
                EndIf
            Else
                Aadd(aImpFlag,{SFB->FB_CODIGO,"D2_VALIMP"+SFB->FB_CPOLVRO,SFC->FC_INCNOTA,SFC->FC_INCDUPL,SFC->FC_CREDITA,"F2_VALIMP"+SFB->FB_CPOLVRO,"D2_BASIMP"+SFB->FB_CPOLVRO,"F2_BASIMP"+SFB->FB_CPOLVRO,SFB->FB_ALIQ,"D2_ALQIMP"+SFB->FB_CPOLVRO,SFC->FC_PROV,SFC->FC_INCIMP})
            EndIf
        EndIf
        SFC->(DbSkip())
    End
    DbSelectArea(cAlias)
    DbSetOrder(nOrder)
    DbGoTo(nReg)

Return(aImpFlag)

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o		  ³AutoGrLog ³ Autor ³ Sandro 					³ Data ³ 12/03/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Grava o Log com a descricao do HELP.							  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ AutoGrLog [ cExpr ] )												³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parƒmetros³ ExpC1 - Texto a ser gravado no arquivo.						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function AutoGRLog(cLogErro)
    DEFAULT __cFileLog := CriaTrab(,.f.)+".LOG"

    If ( Type("lMSErroAuto") == "L" )
        lMSErroAuto := .T.
    EndIf

    If ( Type( 'lAutoErrNoFile' ) == 'L' ) .And. ( lAutoErrNoFile )
        Aadd( __aErrAuto, cLogErro )
        Return
    EndIf

    If ! File(__cFileLog)
        If (nHandle2 := MSFCreate(__cFileLog,0)) == -1
            Return
        EndIf
    Else
        If (nHandle2 := FOpen(__cFileLog,2)) == -1
            Return
        EndIf
    EndIf
    FSeek(nHandle2,0,2)
    FWrite(nHandle2,cLogErro+chr(13)+chr(10))
    FClose(nHandle2)
Return

Function GetAutoGRLog ( )
    Local aTemp := AClone( __aErrAuto )
    __aErrAuto := {}
Return( aTemp )

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³NomeAutoLog ³ Autor ³ Sandro 		  		  ³ Data ³ 21/07/00 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Retorna no nome do arq. de erro automatico  			   	  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ NomeAutoLog()        											     ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				__cFileLog e'uma variavel estatica
				*/
Function NomeAutoLog()
Return __cFileLog



				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³ FormBatch³ Autor ³ Juan Jose Pereira	  ³ Data ³ 04/12/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Monta tela generica para processo batch						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ FormBatch( cTitle, aSays, aButtons, lOk, bValid )			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parƒmetros³ cTitle = Titulo da janela											  ³±±
				±±³			 ³ aSays  = Array com Says 											  ³±±
				±±³			 ³ aButtons = Array com bottoes										  ³±±
				±±³			 ³ aButtons[i,1] = Tipo de botao 									  ³±±
				±±³			 ³ aButtons[i,2] = Tipo de enabled									  ³±±
				±±³			 ³ aButtons[i,3] = bAction 											  ³±±
				±±³			 ³ bValid = Bloco de validacao do Form 							  ³±±
				±±³			 ³ nAltura= Altura do Form em Pixel (Default 250)				  ³±±
				±±³			 ³ nLargura = Largura do Form em Pixel (Default 520)			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
    #DEFINE LARGURA_DO_SBUTTON 32

Function FormBatch( cTitle, aSays, aButtons, bValid, nAltura, nLargura )

    Local nButtons:= Len(aButtons),;
        nSays:= Len(aSays),;
        oSay,;
        i,nTop, nType, lEnabled, oFormPai, oFont,;
        nLarguraBox, nAlturaBox, nLarguraSay, cTextSay, oBtn, cCaption

    DEFAULT aSays:={}, aButtons:={}
    DEFAULT nAltura:= 250, nLargura:= 520

    // Numero maximo de linhas //
    If( nSays>7 )
        nSays:=7
    EndIf

    // Numero maximo de botoes //
    If( nButtons>5 )
        nButtons:= 5
    EndIf

    oFormPai:= Atail(aFormBatch)
    If( oFormPai==NIL )
        oFormPai:= oMainWnd
    EndIf

    DEFINE FONT oFont NAME "Arial" SIZE 0, -11

    DEFINE MSDIALOG oDlg TITLE cTitle FROM 0,0 TO nAltura,nLargura OF oFormPai PIXEL

    AADD(aFormBatch,oDlg)

    nAlturaBox:= (nAltura-60)/2
    nLarguraBox:= (nLargura-20)/2
    @ 10,10 TO nAlturaBox,nLarguraBox OF oDlg PIXEL

    //======================================================//
    // monta says (bof)												 //
    //======================================================//
    nTop:=20

    nLarguraSay:= nLarguraBox-30
    for i:=1 to nSays
        cTextSay:= "{||'"+aSays[i]+"'}"
        oSay := TSay():New( nTop, 20, MontaBlock(cTextSay),oDlg,, oFont, .F., .F., .F., .T.,,, nLarguraSay, 10, .F., .F., .F., .F., .F. )
        nTop+= 10
    next
    //======================================================//
    // monta says (eof)												 //
    //======================================================//

    //======================================================//
    // monta bottoes(bof) 											 //
    //======================================================//
    nPosIni:= ((nLargura-20)/2) - (nButtons* LARGURA_DO_SBUTTON )
    nAlturaButton:= nAlturaBox+10

    for i:=1 to nButtons
        nType:= aButtons[i,1]
        If nType == 5
            cCaption := STR0105 //"Param."
        Else
            cCaption := ""
        EndIf
        lEnabled:= aButtons[i,2]

        DEFAULT lEnabled:= .T.

        If lEnabled
            oBtn := SButton():New( nAlturaButton, nPosIni, nType,aButtons[i,3],oDlg,.T.,,)
        Else
            oBtn := SButton():New( nAlturaButton, nPosIni, nType,,oDlg,.F.,,)
        EndIf
        If !Empty(cCaption)
            oBtn:cCaption := cCaption
        EndIf

        nPosIni+= LARGURA_DO_SBUTTON
    next
    //======================================================//
    // monta bottoes(bof) 											 //
    //======================================================//
    oDlg:Activate( ,,,.T.,bValid,,,, )

Return nil

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³FechaBatch³ Autor ³ Juan Jose Pereira	  ³ Data ³ 04/12/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Fecha Ultima tela de batch 										  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ FechaBatch()															  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function FechaBatch()

    Local oDlg:= Atail( aFormBatch )

    oDlg:End()

    ASize( aFormBatch,Len(aFormBatch)-1 )

Return nil

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³GetFormBatch³ Autor ³ Juan Jose Pereira   ³ Data ³ 04/12/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Retorna um Form de Batch aberto									  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³oDlg:= GetFormBatch(nDialog), se nDialog==0 retorna o ultimo³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function GetFormBatch(nDialog)

    Local oRet:= NIL

    If( nDialog==0 )
        oRet:= Atail(aFormBatch)
    Else
        If( nDialog>0 .and. nDialog<=Len(aFormBatch) )
            oRet:= aFormBatch[nDialog]
        EndIf
    EndIf
Return oRet

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsExectAuto ³ Autor ³Alex Sandro Valario  ³ Data ³ 03/02/00 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Execute rotina de  manutencao automatica	     			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Generico 												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parƒmetros³ bRotina = Bloco de codigo com a chamada da rotina          ³±±
				±±³			 ³ uPar1 ... Uparn = paramentos de cada rotina                ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				Exemplo
				MSExecAuto({|x| mata010(x)},acab)
				MSExecAuto({|x,y| mata140(x,y)},aCab,aItens)
				*/

Function MSExecAuto(bRotina,uPar1,uPar2,uPar3,uPar4,uPar5,uPar6,uPar7,uPar8,uPar9,uPar10)
    LOCAL   ElMsHelpAuto
    LOCAL	EaTela
    LOCAL	EaGets
    LOCAL	EaHeader
    LOCAL	EaCols
    LOCAL	EaRotAuto
    LOCAL	EInclui
    LOCAL	EAltera
    LOCAL	En
    LOCAL	E__cInternet
    LOCAL   E__READVAR
    Local ElMsFinalAuto

    If ( Type('lMsFinalAuto') == 'U' )
        Private lMsFinalAuto := .T.
    EndIf

    ElMsFinalAuto := lMsFinalAuto
    lMsFinalAuto  := .T.

    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto   := .t.
    else
        ElMsHelpAuto :=lMsHelpAuto
    EndIf
    If Type("aTELA") <> "U"
        EaTela := aClone(aTELA)
    EndIf
    If Type("aGETS") <> "U"
        EaGets := aClone(aGETS)
    EndIf
    If Type("aHeader") <> "U"
        EaHeader := aClone(aHeader)
    EndIf
    If Type("aCols")  <> "U"
        EaCols := aClone(aCols)
    EndIf
    If Type("aRotAuto") <> "U"
        EaRotAuto := aClone(aRotAuto)
    EndIf
    If Type("Inclui") <> "U"
        EInclui := Inclui
    EndIf
    If Type("Altera") <> "U"
        EAltera := Altera
    EndIf
    If Type("n") <> "U"
        En := n
    EndIf
    If Type("__cInterNet") <> "U"
        E__cInternet := __cInterNet
    EndIf

    If Type("__READVAR") <> "U"
        E__READVAR := __READVAR
    EndIf


    __cInterNet := "AUTOMATICO"

    eval(bRotina,uPar1,uPar2,uPar3,uPar4,uPar5,uPar6,uPar7,uPar8,uPar9,uPar10)

    lMsHelpAuto := ElMsHelpAuto
    lMsFinalAuto:= ElMsFinalAuto
    aTELA       := EaTela
    aGETS       := EaGets
    aHeader     := EaHeader
    aCols  		:= EaCols
    aRotAuto    := EaRotAuto
    Inclui		:= EInclui
    Altera		:= EAltera
    n			:= En
    __cInterNet := E__cInternet
    __READVAR   := E__READVAR
Return .t.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsRotAuto ³ Autor ³ Alex Sandro Valario   ³ Data ³ 18/08/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Rotina de manutencao automatica									  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Generico 																  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parƒmetros³ nOpcAuto = Numero de opcao da manutencao (3=inclusao) 	  ³±±
				±±³			 ³ xRotAuto = array contEndo linhas para inclusao				  ³±±
				±±³			 ³ sAlias	= Alias														  ³±±
				±±³			 ³ uFunCpo  = Campos a serem editados 								  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MsRotAuto(nOpcAuto,xRotAuto,sAlias,uFunCpo)
    Local nCnt0,nCnt1, nCnt2, bBlock, aFuncoes,nOrderSX3,nPos
    Local AutoReadVar, lObrigat ,cConteudo,uVar,cErro
    Local lInit := .f.
    Local cAlias

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Parametro utilizado para validar campos obrigatorios      ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Local lVldObrig := SuperGetMv("MV_VLDOBRI",.F.,.F.)

    Private aTELA[0][0],aGETS[0]
    Private aHeader:={},aCols:={}
    Private aRotAuto

    nOpcAuto := if(nOpcAuto==NIL,3,nOpcAuto)
    If type("INCLUI")# "L"
        _SetOwnerPrvt("inclui",nOpcAuto==3)
    EndIf
    If type("ALTERA")# "L"
        _SetOwnerPrvt("altera",nOpcAuto==4)
    EndIf


    If Type("lMSErroAuto") == "U"
        Private lMSErroAuto := .F.
    EndIf
    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto := .t.
    EndIf
    cAlias := sAlias

    aRotAuto := (cAlias)->(MSArrayXDB(xRotAuto,.T.,nOpcAuto,,uFunCpo))
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ se funcao retornar vetor com 0 signIfica que gerou arquivo de log ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !( Len(aRotAuto) > 0 )
        Return .t.
    EndIf

    If  aRotAuto # NIL
        nOrderSX3:= SX3->(IndexOrd())
        SX3->(DbSetOrder(2))
        For nCnt1 := 1 To Len( aRotAuto )
            If ( aRotAuto[nCnt1,1] = "AUT" )
                Loop
            EndIf
            AutoReadVar  := "M->" + Upper( aRotAuto[nCnt1,1 ] )
            &AutoReadVar := aRotAuto[nCnt1,2 ]
            If aRotAuto[nCnt1,3 ] == NIL
                SX3->(DbSeek( aRotAuto[nCnt1,1 ] ))
                If SX3->(Found()) .And. !Empty(SX3->X3_VALID )
                    aRotAuto[nCnt1,3 ] := Upper(AllTrim( SX3->X3_VALID ))
                EndIf
            EndIf
            If ( Empty(aRotAuto[nCnt1,3 ]) )
                aRotAuto[nCnt1,3 ] := ".t."
            EndIf
        Next

        For nCnt1 := 1 To Len( aRotAuto )
            If ( aRotAuto[nCnt1,1] = "AUT" ) //Variavel serah utilizada dentro dos programas
                Loop
            EndIf
            AutoReadVar := "M->" + Upper( aRotAuto[ nCnt1,1 ] )
            If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. Empty(aRotAuto[ nCnt1,2])
                lInit := .f.
                If ExistIni(Subs(AutoReadVar,4))
                    lInit := .t.
                    &AutoReadVar := InitPad(SX3->X3_RELACAO)
                    If ValType(&AutoReadVar) = "C"
                        &AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
                    EndIf
                    If &AutoReadVar == NIL .or. Empty(aRotAuto[ nCnt1,2])
                        lInit := .f.
                    EndIf
                EndIf
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³Manter a variavel de memoria caso uma validacao as atualize e nao tenha   ³
                //³sido mensionada no arquivo texto, somente no caso de inclusao             ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                If Empty(aRotAuto[ nCnt1,2]) .and. !Empty(&AutoReadVar) .and. nOpcAuto == 3
                    lInit := .T.
                EndIf
                If !lInit
                    &AutoReadVar := aRotAuto[ nCnt1,2 ]
                EndIf
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³Se for alteracao e alguma validacao atualizar a variavel e a mesma³
            //³nao for um campo que foi passado no array, respeitar a alteracao  ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If nOpcAuto == 4 .and. !aRotAuto[ nCnt1,4 ] .and. (&AutoReadVar != aRotAuto[ nCnt1,2])
                aRotAuto[ nCnt1,2 ] := &AutoReadVar
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³Caso alguma validacao atualize a variavel manter o que foi passado³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If ( &AutoReadVar != aRotAuto[ nCnt1,2] .and. !Empty(aRotAuto[ nCnt1,2]) )
                &AutoReadVar := aRotAuto[ nCnt1,2 ]
            EndIf
            __READVAR := Upper(AllTrim(AutoReadVar))
            If !( aRotAuto[ nCnt1,3 ] == NIL )
                SX3->(DbSetOrder(2))
                SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
                lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
                If (lObrigat .or. ! Empty(&AutoReadVar))
                    bBlock := &( "{ || " + AllTrim( aRotAuto[nCnt1,3 ] ) + " }" )
                    If SX3->X3_VISUAL # "V"
                        If ! Eval( bBlock ) .Or.  IIf(lVldObrig, lObrigat .And. Empty(aRotAuto[ nCnt1,2 ]),.F.)
                            AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
                            SX3->(DbSetOrder(2))
                            For nCnt2 := 1 To Len(aRotAuto)
                                uVar := aRotAuto[nCnt2,2]
                                If 	 (ValType(uVar) == "C")
                                    cConteudo := uVar
                                ElseIf (ValType(uVar) == "N")
                                    cConteudo := Str(uVar)
                                ElseIf (ValType(uVar) == "D")
                                    cConteudo := DtoC(uVar)
                                ElseIf (ValType(uVar) == "L")
                                    cConteudo := If(uVar,"True","False")
                                ElseIf (ValType(uVar) == "M")
                                    cConteudo := "Memo"
                                ElseIf (ValType(uVar) == "U")
                                    cConteudo := "Nil"
                                EndIf
                                If (Padr(aRotAuto[nCnt2,1],12) == Padr(Subs(AutoReadVar,4),12))
                                    cErro := " < -- Invalido"
                                Else
                                    cErro := ""
                                EndIf
                                SX3->(DbSeek(Trim(aRotAuto[nCnt2,1])))
                                AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aRotAuto[nCnt2,1],12)+":="+cConteudo+cErro)
                            Next
                            AutoGRLog(Repl("-",80))
                            SX3->(DbSetOrder(nOrderSX3))
                            lMsHelpAuto := .F.
                            Return .t.
                        EndIf
                        SX3->(DbSetOrder(2))
                        SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
                        If SX3->(X3_TRIGGER) == "S"
                            RunTrigger(1)
                        EndIf
                    EndIf
                EndIf
                If ( lMSErroAuto )
                    AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
                    For nCnt2 := 1 To Len(aRotAuto)
                        uVar := aRotAuto[nCnt2,2]
                        If     (ValType(uVar) == "C")
                            cConteudo := uVar
                        ElseIf (ValType(uVar) == "N")
                            cConteudo := Str(uVar)
                        ElseIf (ValType(uVar) == "D")
                            cConteudo := DtoC(uVar)
                        ElseIf (ValType(uVar) == "L")
                            cConteudo := If(uVar,"True","False")
                        ElseIf (ValType(uVar) == "M")
                            cConteudo := "Memo"
                        ElseIf (ValType(uVar) == "U")
                            cConteudo := "Nil"
                        EndIf
                        If (Padr(aRotAuto[nCnt2,1],12) == Padr(Subs(AutoReadVar,4),12))
                            cErro := " < -- Invalido"
                        Else
                            cErro := ""
                        EndIf
                        AutoGRLog(Padr(aRotAuto[nCnt2,1],12)+":="+cConteudo+cErro)
                    Next
                    AutoGRLog(Repl("-",80))
                    SX3->(DbSetOrder(nOrderSX3))
                    lMsHelpAuto := .F.
                    Return .t.
                EndIf
            EndIf
        Next
        nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
        If ( nPos # 0 )
            dbSelectArea(cAlias)
            bBlock := &( "{ |x,y,z,k| " + aRotina[ nPos,2 ] + "(x,y,z,k) }" )  // { |x,y,z| A240Inclui(x,y,z) }
            Eval( bBlock, cAlias, (cAlias)->(Recno()),nOpcAuto)
            lMsHelpAuto := .F.
            SX3->(DbSetOrder(nOrderSX3))
            Return .t.
        EndIf
        SX3->(DbSetOrder(nOrderSX3))
    EndIf
    lMsHelpAuto := .F.
Return .f.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³AxIncluiAuto³ Autor ³ Alex Sandro Valario ³ Data ³ 19/08/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Incluisao automatica 												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parƒmetros³ cAlias     = Nome do alias                                 ³±±
				±±³          ³ cTudoOk    = Nome da Funcao TudoOk                         ³±±
				±±³          ³ nOpcaoAuto = Numero da aRotina                             ³±±
				±±³          ³ nLinha     = Linha que esta o registro correto             ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function AxIncluiAuto(cAlias,cTudoOk,cTransact,nOpcaoAuto,nlinha)
    Local i
    Local lAppEnd
    nOpcaoAuto := If (nOpcaoAuto == Nil,3,nOpcaoAuto)

    If !( nOpcaoAuto == 3 )
        (cAlias)->(DbGoTo(nLinha))
    EndIf

    bCampo := {|nCPO| Field(nCPO) }

    If cTudoOk != NIL
        If ! &cTudoOk
            AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
            AutoGRLog("Processo invalido")
            AutoGRLog(Replicate("-",80))
            Return 3
        EndIf
    EndIf

    Begin Transaction
        lAppEnd := If (nOpcaoAuto == 3,.t.,.f.)
        RecLock(cAlias,lAppEnd)
        For i := 1 TO FCount()
            If "_FILIAL"$Field(i)
                FieldPut(i,xFilial(cAlias))
            Else
                FieldPut(i,M->&(Eval(bCampo,i)))
            EndIf
        Next i
        If cTransact != Nil
            cTransact += Iif("("$cTransact,"","()")
            lX := &cTransact
        EndIf
    End Transaction
Return 1

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MSArrayXDB  ³ Autor ³ Alex Sandro Valario ³ Data ³ 14/10/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Retorna Array espelhando na Tabela SX3 						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³aVetor1  = Array contEndo informacoes do arquivo Texto      ³±±
				±±³          ³lVirtual = Se estiver .T. retornara Array espelhado no SX3  ³±±
				±±³          ³nOpcAuto = Numero da operacao a ser executada               ³±±
				±±³          ³lItens   = .T. indica que as validacoes sera feira para     ³±±
				±±³          ³           itens e se nao encontrar o registro acrescemta no³±±
				±±³          ³           aVetor1 este parametro eh para casos de alteracao³±±
				±±³          ³cFuncArray = Contera funcao de montagem do Array para os cam³±±±
				±±³          ³             pos que forem validados                        ³±±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MsArrayXDB(aVetor1,lVirtual,nOpcAuto,lItens,cFuncArray)
    Local nX,nAchoFilial:=0
    Local ac:={}
    Local nOrderSX3
    Local nPosTemp
    Local cAlias := upper(Alias())
    Local uConteudo := NIL
    Local cValid := ""
    Local nConta, nPosicao
    Local aConteudo := {}
    Local cMontaSeek := "", cPosiciona:= xFilial(Alias())
    Local aArea := {}, aChave := {}
    Local cOrdemSIX, cOriSIX, cString, cPalavra := ""
    Local lIndex := .f. //Verifica se tem que montar procura por campos informados
    Local cVerifica := "", aCpos := {}
    Local lachou := .T.
    lItens := If (lItens == Nil,.F.,lItens)

    nOpcAuto := if(nOpcAuto==NIL,3,nOpcAuto)
    If type("INCLUI")# "L"
        _SetOwnerPrvt("inclui",nOpcAuto==3)
    EndIf
    If type("ALTERA")# "L"
        _SetOwnerPrvt("altera",nOpcAuto==4)
    EndIf

    For nX := 1 To Len(aVetor1)
        If ( aVetor1[nX,3] <> NIL .and. subs(aVetor1[nX,3],1,1) == "#" )
            lIndex := .T.
            Exit
        EndIf
    Next
    nOrderSX3:= SX3->(IndexOrd())
    SX3->(DbSetOrder(1))
    SX3->(DbSeek(cAlias))

    If ( Upper(Alltrim(aVetor1[Len(aVetor1),1])) != "INDEX" )
        aadd(aVetor1,{"INDEX",1})
    EndIf

    // Aceita passagem de filial para manutencao de registros
    If (nAchoFilial:=Ascan(aVetor1,{|x| "_FILIAL" $ Upper(AllTrim(x[1]))})) > 0
        cMontaSeek:=aVetor1[nAchoFilial,2]
        If ValType(cMontaSeek) # "C"
            cMontaSeek:=xFilial(cAlias)
        EndIf
    Else
        cMontaSeek:=xFilial(cAlias)
    EndIf

    cOrdemSIX  := AllTrim(Str(aVetor1[Len(aVetor1),2]))
    cOriSIX    := cOrdemSIX
    cOrdemSIX  := RetAsc(cOrdemSIX,1,.T.)
    aDel(aVetor1,Len(aVetor1))
    aSize(aVetor1,Len(aVetor1)-1)
    aArea := GetArea()
    dbSelectArea("SIX") //Localiza no Sindex
    If dbSeek(cAlias+cOrdemSIX)
        cString := AllTrim(CHAVE)+"+"
        //À> para conseguir adicionar o ultimo campo
        For nX := 1 to   Len(cString)
            If ( subs(cString,nX,1) != "+" )
                cPalavra := cPalavra + subs(cString,nX,1)
            Elseif (Subs(cPalavra,3) == "_FILIAL")
                cPalavra := ""
            Else
                If Left(cPalavra,5)=="DTOS("
                    cPalavra:= Subs(cPalavra,6)
                    cPalavra:= StrTran(cPalavra,")","")
                EndIf
                nPosicao := Ascan(aVetor1,{|x| AllTrim(x[1]) == AllTrim(cPalavra)})
                If nPosicao > 0
                    If lIndex .and. aVetor1[nPosicao,3] <> nil .and. subs(aVetor1[nPosicao,3],1,1) == "#"
                        aadd(aChave,cPalavra)
                        cPalavra := ""
                        If Len(aVetor1[nPosicao,3]) > 1
                            If Empty(cVerifica)
                                cVerifica := "AllTrim("+subs(aVetor1[nPosicao,3],2) +") == '"+AllTrim(aVetor1[nPosicao,2])+"'"
                            Else
                                cVerifica := cVerifica +" .AND. AllTrim("+subs(aVetor1[nPosicao,3],2) +") == '"+AllTrim(aVetor1[nPosicao,2])+"'"
                            EndIF
                            aVetor1[nPosicao,3] := Nil
                            cPosiciona := cPosiciona + aVetor1[nPosicao,2]
                        Else
                            aVetor1[nPosicao,3] := Nil
                        EndIf
                    Elseif !lIndex
                        aadd(aChave,cPalavra)
                        cPalavra := ""
                    Else
                        exit
                    EndIf
                Else
                    exit
                EndIf
            EndIf
        End
    Else
        AutoGRLog(Dtoc(MsDate())+' '+Time() )
        AutoGRLog("Nao encontrado o indice "+cAlias+" do alias "+cOrdemSIX)
        AutoGRLog(Repl("-",80))
    EndIf
    RestArea(aArea)

    lVirtual := If (lVirtual == Nil,.T.,lVirtual)
    nOpcAuto := If (nOpcAuto == Nil,3,nOpcAuto)

    //ÚÄÄAÄTÄEÄNÄCÄAÄOÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³A variavel cVerifica deve estar vazia somente se for alteracao  ³
    //³de cabecalho e itens na mesma tabela. Ex.: SC1 (Solic. de Venda ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If Empty(cVerifica)
        cVerifica := ".T."
    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Se for exclusao ou alteracao primeiro posicionar o registro   ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If ( nOpcAuto == 4 ) .or. ( nOpcAuto == 5 )
        For nConta := 1 To Len(aChave)
            nPosicao := Ascan(aVetor1,{|x| AllTrim(x[1]) == AllTrim(achave[nconta])})
            If ( nPosicao > 0 )
                cMontaSeek := cMontaSeek + If(ValType(aVetor1[nPosicao,2])=="D",Dtos(aVetor1[nPosicao,2]),aVetor1[nPosicao,2])
                aadd(aConteudo,If(ValType(aVetor1[nPosicao,2])=="D",Dtos(aVetor1[nPosicao,2]),aVetor1[nPosicao,2]))
            EndIf
        Next
        If ( ValType(cOriSIX) == "C" )
            nIndAnt := IndexOrd()
            dbsetOrder(val(cOriSIX))
        EndIf
        If !(DbSeek(cMontaSeek))
            lachou := .F.
            If !lItens .or. !&cVerifica
                AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )
                For nConta := 1 To Len(aConteudo)
                    AutoGRLog(aChave[nConta]+" := "+aConteudo[nConta])
                Next
                AutoGRLog("Pesquisa nao encontrada com dados acima")
                AutoGRLog(Repl("-",80))
                Return aC := {}
            EndIf
            //A variavel cPosiciona esta os dados para procura somente dos
            //campos principais (que passaram validacao no array)
            If lItens .and. lIndex
                DbSeek(cPosiciona)
            EndIf
        EndIf
        If ( ValType(cOriSIX) == "C" )
            dbsetOrder(nIndAnt)
        EndIf
    EndIf
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Verifica se deverah validar os campos, somente nos que foram passado ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If ( cFuncArray <> Nil )
        aCpos := If (valType(cFuncArray) == "A",aClone(cFuncArray),&cFuncArray)
    EndIf
    For nX := 1 To Len(aVetor1)
        If ( Upper(subs(aVetor1[nX,1],1,3)) == "AUT" )
            If Len(aVetor1[nX]) >= 4
                aadd(aC,{aVetor1[nX,1],aVetor1[nX,2],aVetor1[nX,3],aVetor1[nX,4]})
            Else
                aadd(aC,{aVetor1[nX,1],aVetor1[nX,2],aVetor1[nX,3]})
            EndIf
        EndIf
    Next
    While ( ! Sx3->(eof()) .and. Sx3->X3_ARQUIVO == cAlias )
        If ( lVirtual ) .and. (SX3->X3_CONTEXT == "V") .and. nOpcAuto <> 4
            Sx3->(DbSkip())
            Loop
        EndIf
        If 	 ( SX3->X3_TIPO == "C" )
            uConteudo := Space(Sx3->X3_TAMANHO)
        ElseIf ( SX3->X3_TIPO == "D" )
            uConteudo := CToD("")
        ElseIf ( SX3->X3_TIPO == "N" )
            uConteudo := 0
        Elseif ( SX3->X3_TIPO == "L" )
            uConteudo := .F.
        Else
            uConteudo := ""
        EndIf
        nPosTemp := Ascan(aVetor1,{|x| AllTrim(Upper(x[1])) == AllTrim(SX3->X3_CAMPO)})
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³se for inclusao validar todos                            ³
        //³se for alteracao validar somente o que pode ser alterado ³
        //³se for exclusao nao validar nenhum                       ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If (nOpcAuto == 3)
            If Empty(aCpos)
                cValid := Upper(AllTrim( SX3->X3_VALID ))
            Else
                cValid := If ( Ascan(aCpos,{|x|x == Alltrim(SX3->X3_CAMPO)}) > 0,Upper(AllTrim( SX3->X3_VALID )),"")
            EndIf
        Elseif nOpcAuto == 4
            If ( nPosTemp # 0 )
                If Empty(aCpos)
                    cValid := If(!("x" $ SX3->(Substr(FirstBitOff(Bin2Str(x3_usado)),101,1))),Upper(AllTrim( SX3->X3_VALID )),"")
                Else
                    cValid := If ( Ascan(aCpos,{|x|x == Alltrim(SX3->X3_CAMPO)}) > 0,Upper(AllTrim( SX3->X3_VALID )),"")
                EndIf
            Else
                cValid := ""
            EndIf
        else
            cValid := ""
        EndIf

        If ( nPosTemp # 0 )
            uConteudo := aVetor1[nPosTemp,2]
            If (aVetor1[nPosTemp,3] # NIL  )
                cValid	  := aVetor1[nPosTemp,3]
            EndIf
        Elseif (nOpcAuto == 4) .and. (!lItens .or. lachou) // se for cabecalho ou se tiver sucesso na pesquida
            If fieldpos(AllTrim(SX3->X3_CAMPO)) > 0
                uConteudo := FieldGet(fieldpos(AllTrim(SX3->X3_CAMPO)))
            EndIf
        EndIf
        If ( Empty(cValid) )
            cValid := ".t."
        EndIf
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³Se uConteudo for do tipo caracter entao colocar a variavel do tamanho do campo do SX3³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If Valtype(uConteudo) == "C"
            IF SX3->X3_TIPO != "M"
                uConteudo := PadR(uConteudo,Sx3->X3_TAMANHO)
            EndIf
        EndIf
        If nPosTemp # 0
            aadd(aC,{SX3->X3_CAMPO,uConteudo,cValid,.T.})
        Else
            aadd(aC,{SX3->X3_CAMPO,uConteudo,cValid,.F.})
        EndIf

        Sx3->(DbSkip())
    End
    SX3->(DbSetOrder(nOrderSX3))
Return aC

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsVldGAuto³ Autor ³ Alex Sandro Valario   ³ Data ³14/10/1998³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³Valida os gets Automaticos											  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ 																			  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MsVldGAuto(aValidGet)
    Local nX
    Local bBlock
    Local lObrigat
    Local lObriAuto
    Local nOrderSX3

    Private Inclui := If (Type("Inclui") # "L",.t.,Inclui)
    Private Altera := If (Type("Altera") # "L",.f.,Altera)
    If Type("lMSErroAuto") == "U"
        Private lMSErroAuto := .F.
    EndIf
    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto := .t.
    EndIf
    If ( Empty(aValidGet))
        aValidGet := aClone(aAutoCab)
        For  nX := 1 To Len(aValidGet)
            aadd(aValidGet[nx],.f.)
        Next
    EndIf

    nOrderSX3:= SX3->(IndexOrd())
    SX3->(DbSetOrder(2))
    For nX := 1 to Len(aValidGet)
        If ( aValidGet[nX,1] = "AUT" ) //Variavel serah utilizada dentro dos programas
            Loop
        EndIf
        AutoReadVar  := "M->" +Upper(AllTrim(aValidGet[nX,1]))
        //	If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. ! Empty(aValidGet[nX,2])
        If Type("&AutoReadVar")== "U" .or. Empty(&AutoReadVar) .or. ! Empty(aValidGet[nX,2])
            lInit := .f.
            If ExistIni(Subs(AutoReadVar,4))
                lInit := .t.
                &AutoReadVar := InitPad(SX3->X3_RELACAO)
                If ValType(&AutoReadVar) = "C"
                    &AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
                EndIf
                If &AutoReadVar == NIL .or. !Empty(aValidGet[nX,2]) // aqui foi alterado
                    lInit := .f.
                EndIf
            EndIf
            If !lInit
                &AutoReadVar := aValidGet[nX,2]
            EndIf
        EndIf
        If ( Empty(aValidGet[nX,2]) )
            aValidGet[nX,2] := &AutoReadVar
        EndIf
        If ( Empty(aValidGet[nx,3]) )
            aValidGet[nX,3] := " .t. "
        EndIf
        __READVAR := Upper(AllTrim(AutoReadVar))
        SX3->(DbSetOrder(2))
        IF SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
            lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
            lObriAuto:= aValidGet[nX,4]
            If (lObrigat .or. ! Empty(&AutoReadVar) .or. lObriAuto )
                bBlock := &( "{ || " + AllTrim( aValidGet[nX,3 ] ) + " }" )
                If SX3->X3_VISUAL # "V"
                    If ! Eval( bBlock )
                        MsLogCab(aValidGet,AutoReadVar)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                    SX3->(DbSetOrder(2))
                    SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
                    If SX3->(X3_TRIGGER) == "S"
                        RunTrigger(1)
                    EndIf
                    If lMsErroAuto
                        MsLogCab(aValidGet,AutoReadVar)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                EndIf
            EndIf
        Else
            bBlock := &( "{ || " + AllTrim( aValidGet[nX,3 ] ) + " }" )
            If ! Eval( bBlock )
                MsLogCab(aValidGet,AutoReadVar)
                lMsHelpAuto := .F.
                SX3->(DbSetOrder(nOrderSX3))
                Return .f.
            EndIf
        EndIf
    Next
    SX3->(DbSetOrder(nOrderSX3))
Return .t.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsVldAcAuto³ Autor³ Alex Sandro Valario   ³ Data ³14/10/1998³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³aValidGet = aCols                                           ³±±
				±±³          ³cLinhaOk  = Dispara a funcao de Linha Ok                    ³±±
				±±³          ³cTudoOk   = Dispara a funcao de Tudo Ok                     ³±±
				±±³          ³cTmpAlias = Se estiver trabalhando com GetDb passar o alias ³±±
				±±³          ³            do arquivo temporario                           ³±±
				±±³          ³OpcAuto   = n da rotina a ser disparada, baseada no aRotina ³±±
				±±³          ³cChaPes   = Se for alteracao com cabecalho e itens,passar a ³±±
				±±³          ³            chave de pesquisa do acols. Ex: "??_ITEM"       ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³Valida os gets Automaticos (aCols)								  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ 																			  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MsVldAcAuto(aValidGet,cLinhaOk,cTudoOk,cTmpAlias,OpcAuto,cChaPes)
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³  A variavel cTmpAlias so sera usada quando se estiver        ³
    //³  trabalhando com a funcao MSGETDB                            ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    Local nX,nY
    Local bBlock
    Local nPos
    Local lObrigat
    Local nOrderSX3
    Local nP_aHeader, nP_aCols,nP_aAutoIt
    Private Inclui := .t.
    Private Altera := .f.
    Private n
    //esta variavel simula a cCampo da GetDados
    Private cCampo
    OpcAuto := If (OpcAuto == Nil,3,OpcAuto)
    Private o
    If Type("lMSErroAuto") == "U"
        Private lMSErroAuto := .F.
    EndIf
    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto := .t.
    EndIf
    nOrderSX3:= SX3->(IndexOrd())
    SX3->(DbSetOrder(2))
    If GetMV('MV_VEICULO')=='S'
        MsCodVei()  // utilizado para codigos auxiliares
    EndIf
    If !( cTmpAlias == NIL )
        (cTmpAlias)->(dbGoTop())
    EndIf
    For nX := 1 to Len(aCols)
        If ( OpcAuto == 4 .and. ValType(cChaPes) == "C")
            If !( aAutoItens[nX,1,1] == nil )
                nP_aHeader := ascan(aHeader,{|x| Upper(Alltrim(x[2])) == Upper(Alltrim(cChaPes))})
                nP_aAutoI  := ascan(aAutoItens[nX],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(cChaPes))})
                If ( aAutoItens[nX,nP_aAutoI,2]!=aCols[nX,nP_aHeader] )
                    Loop
                EndIf
            Else
                Loop
            EndIf
        EndIf
        n:= nX
        If !( cTmpAlias == NIL )
            If ( OpcAuto != 4 )
                RecLock(cTmpAlias,.t.)
            Elseif (OpcAuto == 4 )
                RecLock(cTmpAlias,.F.)
            EndIf
        EndIf

        For nY := 1 to Len(aCols[nX])- 1
            // criar todas variaveis de memoria
            AutoReadVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))
            &AutoReadVar := aCols[nX,nY]
            If !( cTmpAlias == NIL )
                (cTmpAlias)->(FieldPut(nY,aCols[nX,nY]))
            EndIf
        Next
        For nY := 1 to Len(aCols[nX])- 1
            nPos := Ascan(aAutoItens[nX],{|x| Alltrim(Upper(x[1])) == Alltrim(Upper(aHeader[nY,2]))})
            If nPos == 0
                Loop
            EndIf
            If ( ! Empty(nPos) ) .and. ( aAutoItens[nX,nPos,2] # NIL ) .and. ! Empty(aAutoItens[nX,nPos,2])
                If ( ValType(aAutoItens[nX,nPos,2])=="C")
                    aCols[nX,nY] := Padr(aAutoItens[nX,nPos,2],aHeader[nY,4] )
                Else
                    aCols[nX,nY] := aAutoItens[nX,nPos,2]
                EndIf
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³Quando a tabela temporaria for atualizada em alguma validacao       ³
            //³atualizarah tambem o acols                                          ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If !( cTmpAlias == NIL )
                If Empty(aCols[nX,nY]) .and. !Empty((cTmpAlias)->(FieldGet(ny)))
                    aCols[nX,nY] := (cTmpAlias)->(FieldGet(ny))
                EndIf
            EndIf

            AutoReadVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))

            If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. ! Empty(aCols[nX,nY])
                lInit := .f.
                If ExistIni(Subs(AutoReadVar,4))
                    lInit := .t.
                    &AutoReadVar := InitPad(SX3->X3_RELACAO)
                    If ValType(&AutoReadVar) = "C"
                        &AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
                    EndIf
                    If &AutoReadVar == NIL	.or. !Empty(aCols[nX,nY])
                        lInit := .f.
                    EndIf
                EndIf
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³Manter a variavel de memoria caso uma validacao as atualize e NAO tenha   ³
                //³sido mensionada no arquivo texto                                          ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                If Empty(aCols[nX,nY]) .and. !Empty(&AutoReadVar)
                    lInit := .T.
                EndIf
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³Se o inicializador nao estiver ativo volta o valor do aCOLS para a variavel de³
                //³memoria, mas caso esteja ativo e nao tenha sido mencionado no arquivo texto   ³
                //³entao atualiza o aCOLS                                                        ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                If !lInit
                    &AutoReadVar := aCols[nX,nY]
                ElseIf !aAutoItens[nX,nPos,4] .and. Empty(aCols[nX,nY]) .and. !Empty(&AutoReadVar)
                    aCols[nX,nY] := &AutoReadVar
                EndIf
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³Caso alguma validacao atualize a variavel manter o que foi passado³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If ( &AutoReadVar != aCols[nX,nY] .and. !Empty(aCols[nX,nY]) )
                &AutoReadVar := aCols[nX,nY]
            EndIf
            If 	 ( ValType(aCols[nX,nY]) =="C")
                &AutoReadVar := Padr(aCols[nX,nY],aHeader[nY,4] )
            EndIf
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³Variaveis de sistema       ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If OpcAuto <> 3
                cCampo    :=  aCols[nX,nY]
            Else
                cCampo    := CriaVar(aHeader[nY,2])
            EndIf
            __READVAR := Upper(AllTrim(AutoReadVar))

            If !( cTmpAlias == NIL )
                (cTmpAlias)->(FieldPut(nY,&AutoReadVar))
            EndIf

            SX3->(DbSetOrder(2))
            SX3->(DbSeek(Upper(AllTrim(aHeader[nY,2]))))
            lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
            If (lObrigat .or. ! Empty(&AutoReadVar))
                bBlock := &( "{ || " + AllTrim( aHeader[ny,6 ] ) + " }" )
                If SX3->X3_VISUAL # "V"
                    If ! Eval( bBlock )
                        MsLogCab(aValidGet,AutoReadVar)
                        MSLogItens(aHeader,aCols,AutoReadVar,n)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                    SX3->(DbSetOrder(2))
                    SX3->(DbSeek(Upper(AllTrim(aHeader[nY,2]))))
                    If SX3->(X3_TRIGGER) == "S"
                        RunTrigger(2,nX)
                    EndIf
                    If lMsErroAuto
                        MsLogCab(aValidGet,AutoReadVar)
                        MSLogItens(aHeader,aCols,AutoReadVar,n)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                EndIf
            EndIf
        Next
        If !( cTmpAlias == NIL )
            (cTmpAlias)->(MSUnLock())
        EndIf


        If !( cTmpAlias == Nil )
            (cTmpAlias)->(dbCommit())
        EndIf

        If cLinhaOk != NIL
            If ! &cLinhaOk
                MsLogCab(aValidGet,"Inconsistencia na Linha de Itens")
                MSLogItens(aHeader,aCols,"Inconsistencia na Linha de Itens",nX)
                lMsHelpAuto := .F.
                SX3->(DbSetOrder(nOrderSX3))
                Return .f.
            EndIf
        EndIf
    Next
    If cTudoOk != NIL
        If ! &cTudoOk
            MsLogCab(aValidGet,"Inconsistencia nos Itens")
            MSLogItens(aHeader,aCols,"Inconsistencia nos Itens ",n)
            lMsHelpAuto := .F.
            SX3->(DbSetOrder(nOrderSX3))
            Return .f.
        EndIf
    EndIf
    SX3->(DbSetOrder(nOrderSX3))
Return .t.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsAuto2aCols³ Autor ³ Alex Sandro Valario ³ Data ³21/10/1998³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Atualiza aCols conforme aAutoItens						  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³nOpcao    = N§ da rotina a ser executada                    ³±±
				±±³          ³TempAlias = Se for GetDb passar o Alias (temporario)        ³±±
				±±³          ³cChaPes   = Se for alteracao com cabecalho e itens,passar a ³±±
				±±³          ³            chave de pesquisa do acols. Ex: "??_ITEM"       ³±±
				±±³          ³ExpL5: Indica se o aheader deve ser atualizado              ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Rotina Automatica 										  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MsAuto2aCols(nOpcao,TempAlias,cChaPes,lChkIni,lAtuHead)
    Local nX         := 0
    Local nY         := 0
    Local nR         := 0
    Local nC         := 0
    Local nPos       := 0
    Local nRecPos    := 0
    Local nPosicao   := 0
    Local nPosDeleta := 0
    Local nLenHead	 := 0
    Local nH         := 0
    Local aPosicao   := {}
    Local aTempVetor := {}

    DEFAULT lChkIni  := .F.
    DEFAULT lAtuHead := .F.
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Validacoes dos Parametros                                    ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    nOpcao    := If (nOpcao == NIL,3,nOpcao)
    TempAlias := If (TempAlias == NIL,"",TempAlias)
    cChaPes   := If (cChaPes == nil,"",cChaPes)

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Determina tamanho do aHeader verificando se utiliza campos de WalkThru³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If Ascan(aHeader,{|x| UPPER(x[1]) == "ALIAS WT"}) > 0
        nLenHead:= Len(aHeader)-2
    Else
        nLenHead:= Len(aHeader)
    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Para os casos que estiverem usando o MSGETDB                 ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If ( Empty(aCols) )
        If ( nOpcao == 3 )
            aCols := Array(1,Len(aHeader))
            For nH := 1 To Len(aHeader)
                If ( aHeader[nH,8] == "C" )
                    acols[1,nH] := Space(aHeader[nH,4])
                ElseIf ( aHeader[nH,8] == "N" )
                    acols[1,nH] := 0
                ElseIf ( aHeader[nH,8] == "D" )
                    acols[1,nH] := dDataBase
                ElseIf aHeader[nY,8] == "M"
                    acols[1,nH] := ""
                Else
                    acols[1,nH] := .f.
                EndIf
            Next
            aadd(acols[1],.f.) //nH ja tera o numero total do aHeader + 1
        Else
            ntotLin := (TempAlias)->(RecCount())
            nTotCol := (TempAlias)->(fCount())
            aCols := Array(ntotLin,nTotCol)
            For nR := 1 To ntotLin
                RecLock(TempAlias,.F.)
                For nC := 1 To nTotCol
                    nPosicao := Ascan(aAutoItens[1],{|x| AllTrim(x[1]) == AllTrim((TempAlias)->(FieldName(nC)))})
                    If nPosicao > 0
                        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        //³Atualiza tabela temporaria da GetDB, somente se aAutoItens estiver com algum valor³
                        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                        If !Empty(aAutoItens[nR,nPosicao,2])
                            (TempAlias)->(FieldPut(nC,aAutoItens[nR,nPosicao,2]))
                        EndIf
                        aCols[nR,nC] := (TempAlias)->(FieldGet(nC))
                    EndIf
                Next
                (TempAlias)->(MSUnLock())
                (TempAlias)->(DbSkip())
            Next
        EndIf
    Else
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³Se for alteracao no caso de cabecalho e itens no mesmo arquivo³
        //³somente atualizar o acols e sair da funcao                    ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If ( nOpcao == 4 )
            For nR := 1 To Len(aHeader)
                If ( Empty(aHeader[nR,6]) )
                    aHeader[nR,6] := ".t."
                EndIf
                nPos := ascan(aAutoItens[1],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(aHeader[nR,2]))})
                If ( nPos > 0 )
                    aAdd(aPosicao,nPos)
                EndIf
            Next
            nPos     := ascan(aAutoItens[1],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(cChaPes))})
            nPosicao := ascan(aHeader,{|x| Upper(Alltrim(x[2])) == Upper(Alltrim(cChaPes))})
            For nR := 1 To Len(aAutoItens)
                nPos_aCols := aScan(aCols,{|x| Upper(Alltrim(x[nPosicao])) == Upper(Alltrim(aAutoItens[nr,nPos,2]))})
                If ( nPos_aCols > 0 .and. AllTrim(aAutoItens[nR,nPos,2]) == AllTrim(aCols[nPos_aCols,nPosicao]))
                    For nC := 1 To Len(aCols[nPos_aCols])-1
                        If lChkIni
                            If aAutoItens[nR,aPosicao[nC],4]
                                aCols[nPos_aCols,nC] := aAutoItens[nR,aPosicao[nC],2]
                            EndIf
                        Else
                            If nR <= len(aAutoItens) .and. nC <= len(aPosicao) //Sandro
                                aCols[nPos_aCols,nC] := aAutoItens[nR,aPosicao[nC],2]
                            EndIf
                        EndIf
                    Next
                Else
                    aSize(aCols,Len(aCols)+1)
                    aCols[len(aCols)] := {}
                    For nC := 1 To nLenHead
                        aAdd(aCols[len(aCols)],aAutoItens[nR,aPosicao[nC],2])
                    Next
                    aAdd(aCols[len(aCols)],.f.)
                    nPos_aCols := aScan(aCols,{|x| Upper(Alltrim(x[nPosicao])) == Upper(Alltrim(aAutoItens[nr,nPos,2]))})
                EndIf
                nPosDeleta := ascan(aAutoItens[nR],{|x| Upper(Alltrim(x[1])) == "AUTDELETA"})
                If ( nPosDeleta > 0 )
                    aCols[nPos_aCols,nC] := (Upper(aAutoItens[nR,nPosDeleta,2]) == "S")
                EndIf
            Next
            aTempVetor := Array(Len(aCols),Len(aAutoItens[1]),Len(aAutoItens[1,1]))
            For nX := 1 To Len(aAutoItens)
                For nC := 1 To Len(aCols)
                    If ( AllTrim(Upper(aCols[nC,nPosicao])) == AllTrim(Upper(aAutoItens[nX,nPos,2])))
                        aCopy(aAutoItens[nX],aTempVetor[nC],1,Len(aAutoItens[nX]))
                    EndIf
                Next
            Next
            aAutoItens := aClone(aTempVetor)
            Return
        EndIf
    EndIf
    // Atualizando os Valids do aHeader conforme array automatico esta vindo como parametros
    For nX := 1 To Len(aHeader)
        nPos := Ascan(aAutoItens[1],{|x| AllTrim(Upper(x[1])) == AllTrim(Upper(aHeader[nX,2]))})
        If !Empty(nPos) .And. aAutoItens[1,nPos,3] # NIL .And. lAtuHead
            aHeader[nX,6] := aAutoItens[1,nPos,3]
        EndIf
        If ( Empty(aHeader[nX,6]) )
            aHeader[nX,6] := ".t."
        EndIf
    Next
    If ( nOpcao == 3 )
        For nX := 1 To Len(aAutoItens)
            If ( nX > 1 )
                aadd(aCols,aClone(aCols[nX -1]))
                For nY := 1 to Len(aCols[nX])-1
                    If 	 aHeader[nY,8] == "C"
                        aCOLS[nX][nY] := SPACE(aHeader[nY,4])
                    ElseIf aHeader[nY,8] == "N"
                        aCOLS[nX][nY] := 0
                    ElseIf aHeader[nY,8] =="D"
                        aCOLS[nX][nY] := dDataBase
                    ElseIf aHeader[nY,8] == "M"
                        aCOLS[nX][nY] := ""
                    Else
                        aCOLS[nX][nY] := .F.
                    EndIf
                Next
            EndIf
            For nY := 1 To (Len(aCols[1]) - 1)
                nPos := Ascan(aAutoItens[1],{|x| AllTrim(Upper(x[1])) == AllTrim(Upper(aHeader[nY,2]))})
                If ( ! Empty(nPos) ) .and. ( aAutoItens[nX,nPos,2] # NIL  )
                    If ( ValType(aAutoItens[nX,nPos,2])=="C")
                        aCols[nX,nY] := Padr(aAutoItens[nX,nPos,2],aHeader[nY,4] )
                    Else
                        aCols[nX,nY] := aAutoItens[nX,nPos,2]
                    EndIf
                EndIf
            Next
        Next
    EndIf
Return




				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsLogCab	  ³ Autor ³ Alex Sandro Valario ³ Data ³21/10/1998³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Grava no log do Cab													  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Rotina Automatica 													  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/

Function MsLogCab(aValidGet,AutoReadVar)
    Local nX
    Local cConteudo
    Local uVar
    Local uVar2
    Local nT := 0
    AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )

    For nX := 1 To Len(aValidGet)
        uVar := aValidGet[nX,1]
        uVar2:= aValidGet[nX,2]
        If 	 (ValType(uVar2) == "C")
            cConteudo := uVar2
        ElseIf (ValType(uVar2) == "N")
            cConteudo := Str(uVar2)
        ElseIf (ValType(uVar2) == "D")
            cConteudo := DtoC(uVar2)
        ElseIf (ValType(uVar2) == "L")
            cConteudo := If(uVar2,"True","False")
        ElseIf (ValType(uVar2) == "M")
            cConteudo := "Memo"
        ElseIf (ValType(uVar2) == "U")
            cConteudo := "Nil"
        EndIf
        If (Padr(Upper(aValidGet[nX,1]),12) == Padr(Subs(Upper(AutoReadVar),4),12))
            cErro := " < -- Invalido"
            nT := nT + 1
        Else
            cErro := ""
        EndIf
        SX3->(DbSeek(Trim(aValidGet[nX,1])))
        AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aValidGet[nX,1],12)+":="+cConteudo+cErro)
    Next
    If Empty(nT)
        AutoGRLog("Erro --> "+AutoReadVar)
    EndIf
    AutoGRLog(Repl("-",80))
Return

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³MsLogItens  ³ Autor ³ Alex Sandro Valario ³ Data ³21/10/1998³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Grava no log de Itens												  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ Rotina Automatica 													  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MSLogItens(aHeader,aCols,AutoReadVar,n)
    Local cConteudo
    Local uVar
    Local nT := 0
    Local nY := 0
    AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )
    AutoGRLog("Erro no Item "+str(n,3))
    AutoGRLog(Repl("-",80))
    For nY := 1 To Len(aCols[n]) -1
        uVar := aCols[n,nY]
        If 	 (aHeader[nY,8] == "C")
            cConteudo := uVar
        ElseIf (aHeader[nY,8] == "N")
            cConteudo := Str(uVar)
        ElseIf (aHeader[nY,8] == "D")
            cConteudo := DtoC(uVar)
        ElseIf (aHeader[nY,8] == "L")
            cConteudo := If(uVar,"True","False")
        ElseIf (aHeader[nY,8] == "M")
            cConteudo := "Memo"
        ElseIf (aHeader[nY,8] == "U")
            cConteudo := "Nil"
        EndIf
        If (Padr(Upper(aHeader[nY,2]),12) == Padr(Subs(Upper(AutoReadVar),4),12))
            cErro := " < -- Invalido"
            nT ++
        Else
            cErro := ""
        EndIf
        SX3->(DbSeek(Trim(aHeader[nY,2])))
        AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aHeader[nY,2],12)+":="+cConteudo+cErro)
    Next
    If Empty(nT)
        AutoGRLog("Erro -->  "+AutoReadVar)
    EndIf
    AutoGRLog(Repl("-",80))
Return

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
				±±ºPrograma  ³MostraErroºAutor  ³Valdir/Sandro       º Data ³  12/07/00   º±±
				±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
				±±ºDesc.     ³Mostra erros do processo automatico ********.log na Tela    º±±
				±±º          ³                                                            º±±
				±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
				±±ºUso       ³ AP5                                                        º±±
				±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MostraErro(cPath,cNome)
    Local oDlg
    Local cMemo
    Local cFile    :=""
    Local cMask    := STR0043 //"Arquivos Texto (*.TXT) |*.txt|"
    Local oFont
    Local cStartPath := GetSrvProfString("Startpath","")

    cPath := If(cPath = Nil, "", cPath)
    cNome := If(cNome = Nil, __cFileLog, cNome)
    DEFAULT __cFileLog := Criatrab(,.f.)+".LOG"
    cMemo :=MemoRead(__cFileLog)

    If Empty(cPath)
        DEFINE FONT oFont NAME "Courier New" SIZE 5,0   //6,15

        DEFINE MSDIALOG oDlg TITLE __cFileLog From 3,0 to 340,417 PIXEL

        @ 5,5 GET oMemo  VAR cMemo MEMO SIZE 200,145 OF oDlg PIXEL
        oMemo:bRClicked := {||AllwaysTrue()}
        oMemo:oFont:=oFont

        DEFINE SBUTTON  FROM 153,175 TYPE 1 ACTION oDlg:End() ENABLE OF oDlg PIXEL //Apaga
        DEFINE SBUTTON  FROM 153,145 TYPE 13 ACTION (cFile:=cGetFile(cMask,OemToAnsi(STR0044)),If(cFile="",.t.,MemoWrite(cFile,cMemo)),oDlg:End()) ENABLE OF oDlg PIXEL //Salva e Apaga //"Salvar Como..."
        DEFINE SBUTTON  FROM 153,115 TYPE 6 ACTION (PrintAErr(__cFileLog,cMemo),oDlg:End()) ENABLE OF oDlg PIXEL //Imprime e Apaga

        ACTIVATE MSDIALOG oDlg CENTER
    Else
        ConOut(STR0046 + cNome)  //"Processo nao concluido. Verificar arquivo "
        Copy File (cStartPath + "\" + __cFileLog) To (cPath + "\" + cNome)
    EndIf
    Ferase(__cFileLog)
    __cFileLog := Nil
Return(cMemo)

Static Function PrintAErr(cFileErro,cConteudo)//Imprime o autoerro.log
    Local nLin := 0
    Local nX   := 0
    Default cConteudo := ""

    CursorWait()
    If IsTelnet() .Or. IsBlind()
        While !IsPrinter()
            If !MsgRetryCancel(OemToAnsi(STR0045),OemToAnsi(STR0001)) //"Impressora n„o est  pronta."###"Aten‡„o"
                Return .T.
            Endif
        Enddo
        RptStatus({|lEnd| __CopyFile(cFileErro,"Lpt1")} )
    Else
        Private aReturn:= {STR0059, 1,STR0060, 1, 2, 1, "",1 }

        SetPrint(,cFileErro,nil ,STR0061,cFileErro,'','',.F.,"",.F.,"M")
        If nLastKey <> 27
            SetDefault(aReturn,"")
            nLinha:= MLCount(cConteudo,132)
            For nX:= 1 To nLinha
                nLin++
                If nLin > 80
                    nLin := 1
                    @ 00,00 PSAY AvalImp(132)
                Endif
                @ nLin,000 PSAY Memoline(cConteudo,132,nX)
            Next nX
            Set device to Screen
            MS_FLUSH()
        EndIf
    EndIf
Return .T.




				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o    ³TemBxCanc ³ Autor ³ Andreia Santos        ³ Data ³ 09/12/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³VerIfica se a baixa do titulo foi cancelada                 ³±±
				±±³          ³Caso n„o seja passada a Chave, o SE5 deve estar posicionado ³±±
				±±³          ³para a montagem da Chave.                                   ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe   ³TemBxCanc()                                                 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³Financeiro                                                  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function TemBxCanc(cChave,lBxFut, cFil)
    LOCAL aArea    := GetArea()
    LOCAL aAreaSE5 := SE5->(GetArea())
    LOCAL lRet 	   := .F.
    LOCAL cQuery   := ""
    LOCAL cAlias   := ""
    DEFAULT lBxFut := .F.
    DEFAULT cFil := xFilial("SE5")

    dbSelectArea("SE5")
    cChave := If(cChave==Nil,E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ,cChave)
    If !Empty(cChave)
        // Se o SE5 nao estiver posicionado, posiciona para encontrar os estornos
        // do titulo correto, tanto em SQL como em CDX
        If !(IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL))
            If SE5->&(IndexKey()) != xFilial("SE5")+cChave .And. !Empty(IndexKey(7))
                dbSetOrder( 7 )
                dbSeek(cFil+cChave)
            Endif
        EndIf
    Endif

    #IFDEF TOP
        If ( TcSrvType()!="AS/400" )
            If Select("__NewSe5") == 0
                ChkFile("SE5",.F.,"__NewSe5")
            Endif
            dbSelectArea("__NewSe5")
        Endif
    #ENDIF

    #IFDEF TOP
        If ( TcSrvType()!="AS/400" )
            cQuery := "SELECT Count(*) ESTORNO FROM "+RetSqlName("Se5")+" WHERE "
            If IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL)
                cQuery += "E5_FILIAL='"+SE2->E2_FILIAL+"' AND "
            Else
                cQuery += "E5_FILIAL='"+cFil+"' AND "
            Endif
            cQuery += "E5_PREFIXO='"+SE5->E5_PREFIXO+"' AND "
            cQuery += "E5_NUMERO='"+SE5->E5_NUMERO+"' AND "
            cQuery += "E5_PARCELA='"+SE5->E5_PARCELA+"' AND "
            cQuery += "E5_TIPO='"+SE5->E5_TIPO+"' AND "
            cQuery += "E5_CLIFOR='"+SE5->E5_CLIFOR+"' AND "
            cQuery += "E5_LOJA='"+SE5->E5_LOJA+"' AND "
            cQuery += "E5_SEQ='"+SE5->E5_SEQ+"' AND "
            cQuery += "E5_TIPODOC='ES' AND "
            If !lBxFut
                cQuery += "E5_DATA <= '"+DTOS(dDataBase)+"' AND "
            EndIf
            cQuery += "D_E_L_E_T_<>'*'"
            cQuery := ChangeQuery(cQuery)
            cAlias := "__BXCAN"
            dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

            If ( (cAlias)->(ESTORNO) > 0 )
                lRet := .T.
            EndIf
            dbSelectArea(cAlias)
            dbCloseArea()
            dbSelectArea("__NewSe5")
        Else
        #ENDIF
        While !Eof() .and. cChave ==E5_PREFIXO+E5_NUMERO+;
                E5_PARCELA+E5_TIPO + E5_CLIFOR +E5_LOJA + E5_SEQ
            If ( E5_TIPODOC =="ES" ) .and. Iif (!lBxFut,E5_DATA <= dDataBase,.T.)
                lRet := .T.
                Exit
            EndIf
            dbSkip()
        EndDo
        #IFDEF TOP
        EndIf
    #ENDIF
    RestArea(aAreaSE5)
    RestArea(aArea)
Return lRet

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³ FirstDay ³ Autor ³ Cesar C S Prado		  ³ Data ³ 09/02/94 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Devolve o 1o. dia de um mes.										  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso		 ³ Generico 																  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function FirstDay(dData)
    Local cData := Dtos(dData)
    cData := "01/"+SubStr(cData,5,2)+"/"+Substr(cData,1,4)
Return ( Ctod(cData,"ddmmyy") )

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³A207Um 	³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 14.01.99 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³Gravar no arquivo SAH o conteudo da tabela 62 do SX5		  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function A207Um()
    Local cAlias	:= Alias()

    If AliasInDic("SAH")
        DbSelectArea("SAH")

        If !dbSeek(xFilial("SAH"))
            DbSelectArea("SX5")
            DbSeek(xFilial()+"62")

            While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"62"
                Reclock("SAH",.T.)
                Replace AH_FILIAL With xFilial()
                Replace AH_UNIMED With Substr(SX5->X5_CHAVE,1,Len(AH_UNIMED))
                Replace AH_UMRES  With Substr(X5Descri(),1,Len(AH_UMRES))
                Replace AH_DESCPO With Substr(X5Descri(),1,Len(AH_DESCPO))
                Replace AH_DESCIN With Substr(X5Descri(),1,Len(AH_DESCIN))
                Replace AH_DESCES With Substr(X5Descri(),1,Len(AH_DESCES))
                MsUnlock()
                DbSelectArea("SX5")
                DbSkip()
            End
        EndIf
    Else
        Aviso(OemToAnsi(STR0001),OemToAnsi(STR0058),{"Ok"})  //"O arquivo SAH deve ser incluido neste MNU."
    EndIf
    DbSelectArea(cAlias)
Return .t.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o	 ³A508Grupo ³ Autor ³ Alex Sandro Valario   ³ Data ³ 12.05.00 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³Gravar no arquivo SBM o conteudo da tabela 03 do SX5		  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function A508Grupo()
    Local cAlias	:= Alias()
    If AliasInDic("SBM")
        DbSelectArea("SBM")
        If FWModeAccess("SBM",3) == "C" // SBM Compartilhada
            If LastRec() == 0
                DbSelectArea("SX5")
                DbSeek(xFilial()+"03")
                While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"03"
                    Reclock("SBM",.T.)
                    Replace BM_FILIAL With xFilial()
                    Replace BM_GRUPO With Substr(SX5->X5_CHAVE,1,Len(BM_GRUPO))
                    Replace BM_DESC  With Substr(X5Descri(),1,Len(BM_DESC))
                    MsUnlock()
                    DbSelectArea("SX5")
                    DbSkip()
                End
            EndIf
        Else // SBM Exclusiva
            If !dbSeek(xFilial("SBM"))
                DbSelectArea("SX5")
                DbSeek(xFilial()+"03")
                While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"03"
                    Reclock("SBM",.T.)
                    Replace BM_FILIAL With xFilial()
                    Replace BM_GRUPO With Substr(SX5->X5_CHAVE,1,Len(BM_GRUPO))
                    Replace BM_DESC  With Substr(X5Descri(),1,Len(BM_DESC))
                    MsUnlock()
                    DbSelectArea("SX5")
                    DbSkip()
                End
            EndIf
        EndIf
    EndIf
    DbSelectArea(cAlias)
Return .T.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³AvalQtdPre³ Autor ³Rodrigo de A. Sartorio ³ Data ³21/01/1999³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Funcao generica para avaliar se considera ou nao quantidade³±±
				±±³			 ³ prevista de acordo com o parametro MV_QTDPREV			     ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ AvalQtdPre(ExpC1,ExpN1,ExpL1,ExpC2)  					        ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ExpC1 = Alias a ser pesquisado							        ³±±
				±±³			 ³ ExpN1 = Tipo da quantidade a ser pesquisada		       	  ³±±
				±±³			 ³ 		  1 = Saldo Empenhado								        ³±±
				±±³			 ³ 		  2 = Saldo Previsto para Entrada		    		     ³±±
				±±³			 ³ 		  3 = 1+2											           ³±±
				±±³			 ³ ExpL1 = Pesquisa da Segunda Unidade de Medida              ³±±
				±±³			 ³ ExpC2 = Alias da query a ser utilizada                     ³±±
				±±³			 ³ ExpL2 = Considera qtd prev independente do parametro       ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ GENERICO MATERIAIS									              ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function AvalQtdPre(cAlias,nTipo,lSegUM,cQuery,lEmpPrev)
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Variavel utilizada para verIficar se considera qtd prevista ou nao ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Static lConsPrev:=NIL
    Local nRetorno:=0

    DEFAULT cQuery := cAlias
    DEFAULT lEmpPrev:= .F.

    lSegUM := If(lSegUM==NIL, .F., lSegUM)
    If (lConsPrev == NIL)
        lConsPrev := If(GetMV("MV_QTDPREV")== "S",.T.,.F.)
    EndIf
    If lConsPrev .Or. lEmpPrev
        If nTipo == 1
            If cAlias == "SB2"
                nRetorno := If(lSegUM,(cQuery)->B2_QEPRE2,(cQuery)->B2_QEMPPRE)
            ElseIf cAlias == "SB8"
                nRetorno := If(lSegUM,(cQuery)->B8_QEPRE2,(cQuery)->B8_QEMPPRE)
            ElseIf cAlias == "SBF"
                nRetorno := If(lSegUM,(cQuery)->BF_QEPRE2,(cQuery)->BF_QEMPPRE)
            EndIf
        ElseIf nTipo == 2
            If cAlias == "SB2"
                nRetorno := If(lSegUM, ConvUM((cQuery)->B2_COD,(cQuery)->B2_SALPPRE,0,2),(cQuery)->B2_SALPPRE)
            EndIf
        ElseIf nTipo == 3
            If cAlias == "SB2"
                nRetorno := If(lSegUM,(cQuery)->B2_QEPRE2+ConvUM((cQuery)->B2_COD,(cQuery)->B2_SALPPRE,0,2),(cQuery)->B2_QEMPPRE+(cQuery)->B2_SALPPRE)
            ElseIf cAlias == "SB8"
                nRetorno := If(lSegUM,(cQuery)->B8_QEPRE2,(cQuery)->B8_QEMPPRE)
            ElseIf cAlias == "SBF"
                nRetorno := If(lSegUM,(cQuery)->BF_QEPRE2,(cQuery)->BF_QEMPPRE)
            EndIf
        EndIf
    EndIf
Return nRetorno

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³ GetArea()³ Autor ³ Fernando G/Sergio	  ³ Data ³ 07/10/97 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Guarda a area de trabalho              						  ³±±
				±±³			 ³ 															              ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ ExpA1 := GetArea()										           ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³ ExpC1: Alias da tabela que pode estar em insert.Quando este³±±
				±±³			 ³       parametro é informado o sistema nao reposiciona o    ³±±
				±±³			 ³ 		 recno quando a restarea for executada				     ³±±
				±±³			 ³ NAO SERVE PARA SALVAR A AREA PASSADA COMO PARAMETRO !!!    ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Retorno	 ³ ExpA1 													              ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				*/
Function GetArea(cSqlAlias)
    If cSqlAlias<>Nil .And. cSqlAlias==Alias()
        Return( { Alias(), IndexOrd(), Nil } )
    Else
        Return( { Alias() , IndexOrd() , RecNo() })
    EndIf

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³RestArea()³ Autor ³ Fernando G/Sergio	  ³ Data ³ 07/10/97 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Restaura a area de trabalho										  ³±±
				±±³			 ³ 																			  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe	 ³ RestArea( ExpA1 ) 													  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³ LOJAXFUN 																  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametro ³ ExpA1 -> Vetor contEndo a area ( retornado pela GetArea() )³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				*/

Function RestArea( aArea )
    If !Empty(aArea[ 1 ] )
        If Select(aArea[ 1 ]) > 0
            DbSelectArea( aArea[ 1 ] )
            If aArea[ 2 ] <> IndexOrd()
                DbSetOrder( aArea[ 2 ] )
            EndIf
            If ( aArea[ 3 ] <> Nil .And. aArea[ 3 ] <> RecNo() ) // Melhoria de Performace para o Top Connect
                DbGoTo( aArea[ 3 ] )
            EndIf
        Endif
    EndIf
Return( nil )

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³LjMsgRun	³ Autor ³ Fernando Godoy		  ³ Data ³ 11/03/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³Executa um Bloco de c¢digo e aguarda o retorno.				  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³Sigaloja																	  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				*/
function LjMsgRun( cCaption, cTitle, bAction, cCor )

    Local oDlg, nWidth
    Local oFont

    DEFINE FONT oFont NAME "Arial" SIZE 6,14 BOLD

    DEFAULT cCaption := STR0021,;  //"Aguarde por favor...",;
        bAction	:= { || Inkey( 1 ) }

    If cTitle == NIL
        DEFINE DIALOG oDlg ;
            FROM 0,0 TO 3, Len( cCaption ) + 8 ;
            STYLE nOr( DS_MODALFRAME, WS_POPUP )
        oDlg:SetFont(oFont)
        nWidth := oDlg:nRight - oDlg:nLeft
        @ 2,0 Say xPadc(cCaption,nWidth) 	 of oDlg PIXEL
    Else
        DEFINE DIALOG oDlg ;
            FROM 0,0 TO 4, Max( Len( cCaption ), Len( cTitle ) ) + 8 ;
            TITLE cTitle ;
            STYLE DS_MODALFRAME
        oDlg:SetFont(oFont)
        nWidth := oDlg:nRight - oDlg:nLeft
        @ 2,0 Say xPadc(cCaption,nWidth) 	 of oDlg PIXEL
    EndIf

    oDlg:bStart := { || Eval( bAction, oDlg ), oDlg:End()}
    oDlg:cMsg	:= cCaption

    ACTIVATE DIALOG oDlg CENTER
    //	ON PAINT oDlg:Say( 1, 0, xPadC( oDlg:cMsg, nWidth ),CLR_RED )

    oFont:End()

return nil

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o	 ³Numeral	³ Autor ³ Fernando Godoy		  ³ Data ³ 11/03/98 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³Retorna a forma numeral de um n£mero inteiro. 				  ³±±
				±±³			 ³N£emros de 1 a 100.													  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso		 ³Sigaloja																	  ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				*/
Function Numeral(nNumero)
    Local cRetorno := ""
    Local aNum_1	:= {}
    Local aNum_2	:= {}

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Carrega o Array com os nuemros b sicos ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Aadd( aNum_1, Oemtoansi(STR0023))  // Primeiro
    Aadd( aNum_1, Oemtoansi(STR0024))  // Segundo
    Aadd( aNum_1, Oemtoansi(STR0025))  // Terceiro
    Aadd( aNum_1, Oemtoansi(STR0026))  // Quarto
    Aadd( aNum_1, Oemtoansi(STR0027))  // Quinto
    Aadd( aNum_1, Oemtoansi(STR0028))  // Sexto
    Aadd( aNum_1, Oemtoansi(STR0029))  // S‚timo
    Aadd( aNum_1, Oemtoansi(STR0030))  // Oit vo
    Aadd( aNum_1, Oemtoansi(STR0031))  // Nono

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Carrega Array com os n£meros iniciais de cada dezena ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Aadd( aNum_2, Oemtoansi(STR0032))  // D‚cimo
    Aadd( aNum_2, Oemtoansi(STR0033))  // Vig‚simo
    Aadd( aNum_2, Oemtoansi(STR0034))  // Trig‚simo
    Aadd( aNum_2, Oemtoansi(STR0035))  // Quatrag‚simo
    Aadd( aNum_2, Oemtoansi(STR0036))  // Quinquag‚simo
    Aadd( aNum_2, Oemtoansi(STR0037))  // Sextoagesimo
    Aadd( aNum_2, Oemtoansi(STR0038))  // Septoagesimo
    Aadd( aNum_2, Oemtoansi(STR0039))  // Octoagesimo
    Aadd( aNum_2, Oemtoansi(STR0040))  // Nonoagesimo
    Aadd( aNum_2, Oemtoansi(STR0041))  // Cent‚simo
    If nNumero <= 10
        If nNumero == 10
            cRetorno := aNum_2[1]
        Else
            cRetorno := aNum_1[nNumero]
        EndIf
    ElseIf nNumero <= 20
        If nNumero == 20
            cRetorno := aNum_2[2]
        Else
            cRetorno := aNum_2[1] + Space(1) + ( aNum_1[nNumero - 10] )
        EndIf
    ElseIf nNumero <= 30
        If nNumero == 30
            cRetorno := aNum_2[3]
        Else
            cRetorno := aNum_2[2] + Space(1) + ( aNum_1[nNumero - 20] )
        EndIf
    ElseIf nNumero <= 40
        If nNumero == 40
            cRetorno := aNum_2[4]
        Else
            cRetorno := aNum_2[3] + Space(1) + ( aNum_1[nNumero - 30] )
        EndIf
    ElseIf nNumero <= 50
        If nNumero == 50
            cRetorno := aNum_2[5]
        Else
            cRetorno := aNum_2[4] + Space(1) + ( aNum_1[nNumero - 40] )
        EndIf
    ElseIf nNumero <= 60
        If nNumero == 60
            cRetorno := aNum_2[6]
        Else
            cRetorno := aNum_2[5] + Space(1) + ( aNum_1[nNumero - 50] )
        EndIf
    ElseIf nNumero <= 70
        If nNumero == 70
            cRetorno := aNum_2[7]
        Else
            cRetorno := aNum_2[6] + Space(1) + ( aNum_1[nNumero - 60] )
        EndIf
    ElseIf nNumero <= 80
        If nNumero == 80
            cRetorno := aNum_2[8]
        Else
            cRetorno := aNum_2[7] + Space(1) + ( aNum_1[nNumero - 70] )
        EndIf
    ElseIf nNumero <= 90
        If nNumero == 90
            cRetorno := aNum_2[9]
        Else
            cRetorno := aNum_2[8] + Space(1) + ( aNum_1[nNumero - 80] )
        EndIf
    Else
        cRetorno := aNum_2[10]
    EndIf

Return cRetorno


				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³ Condicao ³ Autor ³ Claudinei M. Benzi    ³ Data ³ 11.02.92  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Rotina para avaliar condicao de pagamento                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³ ExpA1 := Condicao(ExpN1,ExpC1,ExpN2,ExpD1,ExpN3,ExpA2)	   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpA1 = Array contEndo os valores e os vencimentos de cada  ³±±
    ±±³			 ³ 		  parcela.                                             ³±±
    ±±³			 ³ ExpN1 = Valor total a ser parcelado.                        ³±±
    ±±³			 ³ ExpC1 = Codigo da condicao de pagamento a ser considerada.  ³±±
    ±±³			 ³ ExpN2 = Valor do IPI destacado para condicao que obrigue o  ³±±
    ±±³			 ³ 		  IPI a entrar na 1a parcela.                          ³±±
    ±±³			 ³ ExpD1 = Data inicial para considerar desdobramento 		   ³±±
    ±±³			 ³ ExpN3 = Valor do ICMS Solidario                             ³±±
    ±±³			 ³ ExpA2 = Array contEndo a sigla e valor dos impostos calcula-³±±
    ±±³			 ³ 		  dos para os paises Internacionais (MercoSul...)	   ³±±
    ±±³			 ³ ExpA3 = Array contendo dados semelhantes ao que teria no    ³±±
    ±±³			 ³ 		  SE4 												   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso		 ³ Generico                                                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³	MOTIVO DA ALTERACAO                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Rogerio F.G. ³18/11/97³B.HUR ³Alt Cond Pagto Tipo 9                    ³±±
    ±±³ Rogerio F.G. ³24/11/97³B.HUR ³Ajuste Valor Cond Pagto tipo 8           ³±±
    ±±³ Lucas        ³29.06.98³16770A³Adaptacao para os impostos MercoSul...   ³±±
    ±±³ Aline C.Vale ³13.09.99³xxxxxx³Consistencia do ultimo dia da cond. 3    ³±±
    ±±³ Aline C.Vale ³20.09.99³18368A³Acerto na Cond.Pgto.Tipo 7               ³±±
    ±±³ Aline C.Vale ³25.10.99³24332A³Tratar Junta IPI na Cond.Pgto.Tipo 8     ³±±
    ±±³ Sandro       ³02.03.00³xxxxxx|funcionamento sem a existencia da codicao³±±
    ±±³              ³        ³      |cadastrada no SE4                        ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
FUNCTION Condicao(nValTot,cCond,nValIpi,dData0,nValSolid,aImpVar,aE4,nAcrescimo,nInicio3,aDias3)

    Local aDados   := {}
    Local aVenc    := {}
    Local aVencTmp := {}

    Local cAliasSEC:= "SEC"

    Local nX       := 0
    Local nY       := 0
    Local nValRat  := 0
    Local nIpiRat  := 0
    Local nSolRat  := 0
    Local nPosScan := 0
    Local nVlrAcum1:= 0
    Local nVlrAcum2:= 0
    Local nVlrParc := 0
    Local nParcRat := 0
    Local nParcIpi := 0
    Local nParcSol := 0
    Local lAgltDup := (SuperGetMv("MV_AGLDUPB",.F.,"2") == "1")    //"1"-AGLUTINA "2"-NAO AGLUTINA
    Local lDataRef := (SuperGetMv("MV_DATDUPB",.F.,"1") == "1")    //"1"-ULTIMA DATA "2"-DATA INICIAL
    Local lCondVenda := .F.

    #IFDEF TOP
        Local cQuery := ""
        Local nCntFor:= 0
    #ENDIF

    Default nValIpi   := 0
    Default nValSolid := 0

    SE4->(dbSetOrder(1))
    If SE4->(MsSeek(xFilial("SE4")+cCond))
        //
        // Template de GEM - Gestao de Empreendimentos Imobiliarios
        //
        // Verifica se a condicao de pagamento tem vinculado com uma condicao de venda
        //
        If ExistTemplate("GMCondPagto")
            lCondVenda := ExecTemplate("GMCondPagto",.F.,.F.,{cCond,} )
        EndIf

        If SE4->E4_TIPO == "B"

            SEC->(DbSetOrder(1))

            #IFDEF TOP

                aStruSEC := SEC->( dbStruct() )

                cAliasSEC := GetNextAlias()

                cQuery := "SELECT * FROM " + RetSqlName( "SEC" ) + " SEC "
                cQuery += "WHERE "
                cQuery += "EC_FILIAL='"    + xFilial( "SEC" )    + "' AND "
                cQuery += "EC_CODIGO='"    + SE4->E4_CODIGO      + "' AND "
                cQuery += "D_E_L_E_T_=' ' "

                cQuery += "ORDER BY "      + SqlOrder( SEC->( IndexKey() ) )

                cQuery := ChangeQuery( cQuery )

                SEC->( dbCommit() )

                dbUseArea( .T.,"TOPCONN", TcGenQry( ,,cQuery ), cAliasSEC, .F., .T. )

                For nCntFor := 1 To Len(aStruSEC)
                    If ( aStruSEC[nCntFor,2] <> "C" ) .And. ( aStruSEC[nCntFor,2] <> "M" )
                        TcSetField(cAliasSEC,aStruSEC[nCntFor,1],aStruSEC[nCntFor,2],aStruSEC[nCntFor,3],aStruSEC[nCntFor,4])
                    EndIf
                Next nCntFor

            #ELSE

                SEC->(MsSeek(xFilial("SEC")+SE4->E4_CODIGO))

            #ENDIF

            While ( cAliasSEC )->(!Eof()) .And. ( cAliasSEC )->EC_FILIAL == xFilial("SEC") .And.;
                    ( cAliasSEC )->EC_CODIGO == SE4->E4_CODIGO
                nValRat  := NoRound(nValTot   * ( ( cAliasSEC )->EC_RATEIO / 100 ),TamSX3("EC_RATEIO")[2])
                nIpiRat  := NoRound(nValIpi   * ( ( cAliasSEC )->EC_RATEIO / 100 ),TamSX3("EC_RATEIO")[2])
                nSolRat  := NoRound(nValSolid * ( ( cAliasSEC )->EC_RATEIO / 100 ),TamSX3("EC_RATEIO")[2])

                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³ Acumula para calcular diferenca de rateio            ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                nParcRat += nValRat
                nParcIpi += nIpiRat
                nParcSol += nSolRat

                Aadd(aDados, { nValRat,nIpiRat,nSolRat, {  ( cAliasSEC )->EC_CODIGO,;
                    ( cAliasSEC )->EC_COND,;
                    ( cAliasSEC )->EC_TIPO,;
                    ( cAliasSEC )->EC_DDD,;
                    ( cAliasSEC )->EC_IPI,;
                    ( cAliasSEC )->EC_SOLID } })
                ( cAliasSEC )->(dbSkip())
            Enddo

            #IFDEF TOP
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³ Fecha a area de trabalho da query                    ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                ( cAliasSEC )->( dbCloseArea() )
                dbSelectArea( "SEC" )
            #ENDIF


            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Ajusta a diferenca                                   ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            aDados[Len(aDados)][1] += nValTot   - nParcRat
            aDados[Len(aDados)][2] += nValIpi   - nParcIpi
            aDados[Len(aDados)][3] += nValSolid - nParcSol


        Else
            Aadd(aDados, { nValTot,nValIpi,nValSolid,{ SE4->E4_CODIGO,;
                SE4->E4_COND,;
                SE4->E4_TIPO,;
                SE4->E4_DDD,;
                SE4->E4_IPI,;
                SE4->E4_SOLID}})
        Endif
        For nX := 1 to Len(aDados)
            aVencTmp := AvalCond(aDados[nX][1],SE4->E4_CODIGO,aDados[nX][2],dData0,aDados[nX][3],aImpVar,aE4,nAcrescimo,aDados[nX][4],nInicio3,aDias3)
            If Len(aVencTmp) > 0
                For nY := 1 to Len(aVencTmp)
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³ Verifica se o parametro aglutina por data            ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    nPosScan := If(lAgltDup .AND. ! lCondVenda , Ascan(aVenc,{|x| x[1] == aVencTmp[nY][1]}), 0 )
                    If nPosScan > 0
                        aVenc[nPosScan][2] += aVencTmp[nY][2]
                    ElseIf aVencTmp[nY][2] > 0 .Or. ( cPaisLoc $ 'COL|VEN' .And. aVencTmp[nY][2] >= 0 )
                        Aadd(aVenc,{aVencTmp[nY][1],aVencTmp[nY][2]})
                    Endif
                Next nY
                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                //³ Verifica se o parametro da data inicial              ³
                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                If lDataRef
                    dData0 := aVencTmp[Len(aVencTmp),1]
                Endif
            Endif

        Next nX
    Endif

Return(aVenc)


Function DiaExtenso(dExRef,cExTipo)
    Local aExSemana := {STR0012,STR0013,STR0014,STR0015,STR0016,STR0017,STR0018}
Return( If ( Dow(dExRef) == 0, "", If (cExTipo == "N", aExSemana [Dow(dExRef)], aExSemana [Dow(dExRef)]) ))

Function Ano_Mes(lAno)
    If lAno
        Return STR0019
    Else
        Return STR0020
    EndIf


				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³ CONAOK	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 01.12.95 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Mensagem e confirmacao do processamento						  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³ CONA0K(void)															  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ConaOk()
Return (MsgYesNo(OemToAnsi(STR0042),OemToAnsi(STR0001)))

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o	 ³ ReadMotBx³ Autor ³ Andreia dos Santos	  ³ Data ³ 02/12/98 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Leitura do arquivo SIGAADV.MOT para carregar array aMotBx c/³±±
    ±±³			 ³o Motivo da baixa, se movimenta banco e se gera comissao	  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³ ReadMotBx																  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno	 ³ Array aMotBx															  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso		 ³ Generico 																  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ReadMotBx()
    Local nHdlMot := 0
    Local nBytes:=0,nTamArq
    Local xBuffer
    Local aMotRead:={}
    Local cFile := "SIGAADV.MOT"

    If __aMotRead == Nil .Or. Empty(__aMotRead)
        __aMotRead := {}

        If ExistBlock("FILEMOT")
            cFile := ExecBlock("FILEMOT",.F.,.F.,{cFile})
        Endif

        If !FILE(cFile)
            nHdlMot := fCreate(cFile)
            If nHdlMot == -1
                HELP(" ",1,"MOT_ERROR")
                Final("Erro F_"+str(ferror(),2)+" em SIGAADV.MOT")
            EndIf
            if __Language == "ENGLISH"
                fWrite(nHdlMot,"NORNORMAL    ASSS"+chr(13)+chr(10))
                fWrite(nHdlMot,"DACEXCHANGE  ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEVDEVOLUTIONANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEBDEBIT CC  PSNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"VENVENDOR    PNNN"+chr(13)+chr(10))
            elseif __Language == "SPANISH"
                fWrite(nHdlMot,"NORNORMAL    ASSS"+chr(13)+chr(10))
                fWrite(nHdlMot,"DACPERMUTA   ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEVDEVOLUCIONANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEBDEBITO CC PSNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"VENTIT.BANCO PNNN"+chr(13)+chr(10))
            else
                fWrite(nHdlMot,"NORNORMAL    ASSS"+chr(13)+chr(10))
                fWrite(nHdlMot,"DACDACAO     ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEVDEVOLUCAO ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEBDEBITO CC PSNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"VENVENDOR    PNNN"+chr(13)+chr(10))
            endif
            fClose(nHdlMot)
        EndIf

        nHdlMot := FOPEN(cFile,64)

        If nHdlMot <0
            HELP(" ",1,"SIGAADV.MOT")
            Final("SIGAADV.MOT")
        EndIf
        nTamArq:=FSEEK(nHdlMot,0,2)	// VerIfica tamanho do arquivo
        FSEEK(nHdlMot,0,0)			// Volta para inicio do arquivo

        While nBytes<nTamArq

            xBuffer:=Space(19)
            FREAD(nHdlMot,@xBuffer,19)

            AADD(aMotRead,Upper(SubStr(xBuffer,1,03)+"  ³"+SubStr(xBuffer,04,10)+"³ "+SubStr(xBuffer,15,01);
                +Space(4)+"³ "+SubStr(xBuffer,16,01);
                +Space(5)+"³ "+Substr(xBuffer,14,1);
                +Space(4)+"³ "+Substr(xBuffer,17,1)))
            nBytes+=19
        EndDo

        __aMotRead := aClone(aMotRead)

        Fclose(nHdlMot)
    Else
        aMotRead := aClone(__aMotRead)
    EndIf
Return aMotRead


				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o    ³AgentLock ³ Autor ³ F bio F. Pessoa       ³ Data ³ 06/10/99 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Loca um arquivo para Leitura e grava‡ao do AutComm.<caixa> ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³ Sigaloja                                                   ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function AgentLock(nHandle, cImpressora, lWinFrame, cDirAgent)
    Local lRet      := !(((cImpressora == "BEMATECH") .Or. (cImpressora == "VERIfONE SC552")) .And. lWinFrame)
    Local cLockFile := "AGENTE.LOC"

    While !lRet

        nHandle := FOpen(cDirAgent + cLockFile, 16)
        lRet    := !(nHandle < 0)
        SysRefresh()           // Similar ao ProcessMessage do Delphi

    End

Return lRet

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡„o    ³AgentUnLock³ Autor ³ F bio F. Pessoa       ³ Data ³ 06/10/99 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Loca um arquivo para Leitura e grava‡ao do AutComm.<caixa>  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³ Sigaloja                                                    ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function AgentUnlock(nHandle)

    FClose(nHandle)

Return .T.

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o    ³ LerLinha ³ Autor ³ J£lio Wittwer         ³ Data ³ 20.12.99 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡„o ³ Le mais uma linha do Arquivo de Retorno CNAB               ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Sintaxe   ³ cRet := LerLinha(nHandleRet)                               ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Uso       ³ ReadCnab2()                                                ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				*/
Static Function LerLinha(nHandle,nMaxLn)
    Local cString := ""
    Local nTotLidos :=0
    Local lCRLF := .T.

    Default nMaxLn := 1000

    cString := Space(nMaxLn)
    FReadLn(nHandle, @cString, nMaxLn, @lCRLF) // Le uma linha ate CR+LF.

    //Se a linha possuir CRLF no seu final
    If lCRLF
        nTotLidos := Len(cString)+2
        //Se a linha NAO possuir CRLF no seu final
    Else
        nTotLidos := Len(cString)
    Endif

Return {cString,nTotLidos}

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
				±±ºFuncao    ³MSCodVei  ³Autor  ³Sandro              ³ Data ³ 18/09/2000  º±±
				±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
				±±ºDescricao ³Faz consistencias do cod. auxiliar quando veiculos          º±±
				±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
				±±ºUso       ³ AP5                                                        º±±
				±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MSCodVei()
    Local nPosAux:= 0, nPosProd:= 0, nX , nY
    Local aItemH:={},aItemA:= {}
    Local cProduto, cCodAux
    nPosAux := ascan(aHeader,{|x| Upper(Subs(x[2],3,7)) == '_CODGRP'})
    If nPosAux > 0
        For nX := len(aHeader) to 1 step -1
            If (Upper(Subs(aHeader[nX,2],3,8)) == '_PRODUTO') .OR. ;
                    (Upper(Subs(aHeader[nX,2],3,8)) == '_COD    ')
                nPosProd := nX
                exit
            EndIf
        Next
        If nPosProd > 0
            aItemH := aClone(aHeader[nPosProd])
            aItemA := aClone(aHeader[nPosAux])
            aHeader[nPosAux] := aClone(aItemH)
            aHeader[nPosProd]:= aClone(aItemA)
            For nY := 1 to len(aCols)
                cProduto := aCols[nY,nPosProd]
                cCodAux  := aCols[nY,nPosAux]
                aCols[nY,nPosAux] := cProduto
                acols[nY,nPosProd]:= cCodAux
            Next
        EndIf
    EndIF
Return

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o    ³MatGraph  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 16.05.01 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Funcao generica para montagem de dialog com grafico        ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³                                                            ³±±
				±±³        01³ ExpC1 = Titulo da Janela                                   ³±±
				±±³        02³ ExpL1 = Flag indicando se inicializa grafico em 3 dimensoes³±±
				±±³        03³ ExpL2 = Flag indicando se mostra menu para mudar caracteris³±±
				±±³          ³ ticas do grafico como tipo e numero de dimensoes (2 ou 3)  ³±±
				±±³        04³ ExpL3 = Indica se muda a cor em cada barra ou faixa de vlr ³±±
				±±³        05³ ExpN1 = Indica o tipo inicial do grafico                   ³±±
				±±³        06³ ExpN2 = Indica a cor inicial dos valores apresentados      ³±±
				±±³        07³ ExpA1 = Array com os dados a serem apresentados. Dimensoes:³±±
				±±³          ³ [1] Nome a ser colocado no eixo x (Caracter)               ³±±
				±±³          ³ [2] Valor do eixo y (Numerico)                             ³±±
				±±³        08³ ExpC2 = Alias do arquivo de trabalho que contem os dados   ³±±
				±±³        09³ ExpA2 = Array com os campos que devem ter o conteudo lido  ³±±
				±±³          ³ [1] Nome do campo que tem os dados do eixo x (Caracter)    ³±±
				±±³          ³ [2] Nome do campo que tem os valores do eixo y (Caracter)  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³ Generico                                                   ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Function MatGraph(cTitle,lGraph3D,lMenuGraph,lMudaCor,nTipoGraph,nCorDefault,aDados,cAliasTrb,aCamposTrb)
    LOCAL oDlgGraph,oGraph
    Local aSize     := MsAdvSize( .T. )
    Local aPosObj   := {}
    Local aObjects  := {}
    Local lSoBarra  := .F.

    DEFAULT lGraph3D   :=.F.
    DEFAULT lMenuGraph :=.T.
    DEFAULT lMudaCor   :=.F.
    DEFAULT nTipoGraph :=2
    DEFAULT nCorDefault:=6
    DEFAULT cAliasTrb  :=""

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Efetua os calculos de Auto Size                                        ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    aObjects := {}
    AAdd( aObjects, { 100, 100, .T., .T. } )

    aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ]-5, 3, 3 }
    aPosObj := MsObjSize( aInfo, aObjects, , .T. )

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Multiplica por 2 para compatibilizar as dimensoes deste objeto         ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    aPosObj[1,1] *= 2
    aPosObj[1,2] *= 2
    aPosObj[1,3] *= 2
    aPosObj[1,4] *= 2

    DEFINE MSDIALOG oDlgGraph TITLE cTitle FROM aSize[7],0 TO aSize[6],aSize[5] PIXEL OF oMainWnd
    oGraph:= GRF_CreateNew(oDlgGraph)
    MontGraph(@oDlgGraph,@oGraph,aDados,cAliasTrb,aCamposTrb,nTipoGraph,nCorDefault,lGraph3D,lMudaCor,@lSoBarra)
    GRF_WinSet(	oGraph,aPosObj[1,1],;	// nTop
    aPosObj[1,2],;              	// nLeft
    aPosObj[1,3],;              	// nBottom
    aPosObj[1,4],0,0,0)         	// nRight
    @ aSize[4]-6,010 SAY STR0057 SIZE 250,6 OF oDlgGraph PIXEL	// "Pressionando o botao da direita do mouse pode-se arrastar o grafico horizontalmente"
    ACTIVATE MSDIALOG oDlgGraph	CENTERED ON INIT MatGTools(@oDlgGraph,@oGraph,lMenuGraph,lSoBarra)
RETURN NIL

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o    ³MatGTools ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 16.05.01 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Funcao generica para montagem de EnchoiceBar dos graficos  ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³                                                            ³±±
				±±³        01³ ExpO1 = Objeto da Dialog                                   ³±±
				±±³        02³ ExpO2 = Objeto do Grafico                                  ³±±
				±±³        03³ ExpL1 = Flag indicando se mostra menu para mudar caracteris³±±
				±±³        04³ ExpL2 = Indica se o grafico so podera ser de barra         ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³ Generico                                                   ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Static Function MatGTools(oDlgGraph,oGraph,lMenuGraph,lSoBarra)
    Local oBar
    DEFINE BUTTONBAR oBar SIZE 25,25 3D OF oDlgGraph
    DEFINE BUTTON RESOURCE "FINAL" OF oBar GROUP ACTION oDlgGraph:End() TOOLTIP OemToAnsi(STR0051) //"Abandona"
    If lMenuGraph
        If !lSoBarra
            DEFINE BUTTON RESOURCE "LINE"  OF oBar GROUP ;
                ACTION 	GRF_ChartType(oGraph,1),;
                GRF_FixedGap(oGraph,36) ;
                TOOLTIP STR0052; //"Gr fico de Linha"
            PROMPT STR0062
        EndIf
        DEFINE BUTTON RESOURCE "BAR" OF oBar ;
            ACTION 	GRF_ChartType(oGraph,2),;
            GRF_FixedGap(oGraph,20) ;
            TOOLTIP STR0053;  //"Gr fico de Barras"
        PROMPT STR0063
        If !lSoBarra
            DEFINE BUTTON RESOURCE "AREA"        OF oBar ;
                ACTION 	GRF_ChartType(oGraph,6),;
                GRF_FixedGap(oGraph,36) ;
                TOOLTIP STR0054; //"Gr fico de Area"
            PROMPT STR0064
        EndIf
        DEFINE BUTTON RESOURCE "GRAF2D"      OF oBar GROUP ;
            ACTION 	GRF_Chart3D(oGraph,.f.) ;
            TOOLTIP STR0055; //"Gr ficos Bidimensionais"
        PROMPT STR0065
        DEFINE BUTTON RESOURCE "GRAF3D"      OF oBar ;
            ACTION 	GRF_Chart3D(oGraph,.t.) ;
            TOOLTIP STR0056;  //"Gr ficos Tridimensionais"
        PROMPT STR0066
    EndIf
RETURN NIL

				/*
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o    ³MontGraph ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 16.05.01 ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³ Funcao que monta o obejto do grafico                       ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Parametros³                                                            ³±±
				±±³        01³ ExpO1 = Objeto da Dialog                                   ³±±
				±±³        02³ ExpO2 = Objeto do Grafico                                  ³±±
				±±³        03³ ExpA1 = Array com os dados a serem apresentados. Dimensoes:³±±
				±±³          ³ [1] Nome a ser colocado no eixo x (Caracter)               ³±±
				±±³          ³ [2] Valor do eixo y (Numerico)                             ³±±
				±±³        04³ ExpC1 = Alias do arquivo de trabalho que contem os dados   ³±±
				±±³        05³ ExpA2 = Array com os campos que devem ter o conteudo lido  ³±±
				±±³          ³ [1] Nome do campo que tem os dados do eixo x (Caracter)    ³±±
				±±³          ³ [2] Nome do campo que tem os valores do eixo y (Caracter)  ³±±
				±±³        06³ ExpN1 = Indica o tipo do grafico                           ³±±
				±±³        07³ ExpN2 = Indica a cor inicial dos valores apresentados      ³±±
				±±³        08³ ExpL1 = Flag indicando se inicializa grafico em 3 dimensoes³±±
				±±³        09³ ExpL2 = Indica se muda a cor em cada barra ou faixa de vlr ³±±
				±±³        10³ ExpL3 = Indica se o grafico so podera ser de barra         ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³ Generico                                                   ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Static Function MontGraph(oDlgGraph,oGraph,aDados,cAliasTrb,aCamposTrb,nTipoGraph,nCorDefault,lGraph3D,lMudaCor,lSoBarra)
    Local aArea:=GetArea()
    Local aAreaTrb:={}

    Local nLoop   := 0
    Local lEndData:=.F.

    DEFAULT lSoBarra := .F.

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Zera os dados do grafico                                                ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    GRF_InitData( oGraph )
    GRF_Chart3D(oGraph, lGraph3D )
    GRF_FixedGap(oGraph,36)

    If ValType(aDados) == "A" .And. Len(aDados) > 0
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Seta o modelo de grafico lendo as informacoes de um array              ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If Len( aDados ) < 2 .And. nTipoGraph <> 2
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Nao e possivel utilizar area ou linha com 1 coluna                     ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            Help( " ", 1, "ATC010BAR" )
            lSoBarra:=.T.
            GRF_ChartType(oGraph, 2 )
        Else
            GRF_ChartType(oGraph, nTipoGraph )
        EndIf
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Percorre o array de colunas                                            ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        For nLoop := 1 To Len( aDados )
            nValor := aDados[ nLoop, 2 ]
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Cria a coluna do grafico                                               ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            GRF_SetData(oGraph,0,2,nValor,aDados[nLoop,1],nCorDefault)
            lEndData:=.T.
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Muda a Cor Caso Necessario                                             ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If lMudaCor
                nCorDefault++
                If nCorDefault > 18
                    nCorDefault:=0
                EndIf
            EndIf
        Next nLoop
        If lEndData
            GRF_EndData(oGraph,0)
        Endif
    ElseIf Valtype(cAliasTrb) == "C" .And. Select(cAliasTrb) > 0
        GRF_ChartType(oGraph, nTipoGraph )
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Percorre o arquivo de colunas                                          ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        dbSelectArea(cAliasTrb)
        aAreaTrb:=GetArea()
        dbGotop()
        While !Eof()
            nValor := FieldGet(FieldPos(aCamposTrb[2]))
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Cria a coluna do grafico                                               ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            GRF_SetData(oGraph,0,2,nValor,FieldGet(FieldPos(aCamposTrb[1])),nCorDefault)
            lEndData:=.T.
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Muda a Cor Caso Necessario                                             ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            If lMudaCor
                nCorDefault++
                If nCorDefault > 18
                    nCorDefault:=0
                EndIf
            EndIf
            dbSkip()
        End
        RestArea(aAreaTrb)
        If lEndData
            GRF_EndData(oGraph,0)
        Endif

    EndIf
    RestArea(aArea)
RETURN NIL

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Program   ³ValidaCont³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Valida Conta Contabil no Lcto Contabil                     ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³ .T. / .F.                                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpC1 = Conta contabil                                     ³±±
    ±±³          ³ ExpC2 = Tipo do Lancamento                                 ³±±
    ±±³          ³ ExpO1 = Objeto Descricao da conta debito                   ³±±
    ±±³          ³ ExpO2 = Objeto Descricao da conta credito                  ³±±
    ±±³          ³ ExpL1 = Indicador se esta validacao partira da Getdados    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ValidaConta(cConta,cTipo,oDescDeb,oDescCrd,lGetDados,lHelp)

    Local aSaveArea		:= GetArea()
    Local lRet			:= .T.
    Local nPosCta
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCT1
    Local cFilCT1		:= xFilial('CT1')
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(1)

    Local bConta 		:= {|x| 	x[2,1] == cConta .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }
    DEFAULT	lHelp		:= .T.

    If CtbInUse()
        //procura no cache das contas ja pesquisada
        If lCache .And. ! Empty(__aCTBConta) .And. ( nPosCta := Ascan( __aCTBConta, bConta) ) > 0
            lRet 		:= __aCTBConta[nPosCta, 1]
            lAchou 		:= __aCTBConta[nPosCta, 3, 1]
            lSintetica 	:= __aCTBConta[nPosCta, 3, 2]
            nRecCT1		:= __aCTBConta[nPosCta, 3, 3]
            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help("  ", 1, "NOCONTAC")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CT1->(dbGoto(nRecCT1))  //posiciona por causa da descricao.

                If cTipo == "1"
                    CtbExibe(cConta,"1",@oDescDeb,,lRet)
                ElseIf cTipo == "2"
                    CtbExibe(cConta,"2",,@oDescCrd,lRet)
                EndIf
            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            dbSelectArea("CT1")
            dbSetOrder(1)

            If !Empty(cConta)
                dbSelectArea("CT1")
                dbSetOrder(1)
                If !dbSeek(xFilial()+cConta)
                    If lHelp
                        Help("  ", 1, "NOCONTAC")
                    EndIf
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf
                If lRet
                    If CT1->CT1_CLASSE != "2"				// Analitica
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf
            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibe(cConta,"1",@oDescDeb,,lRet)
                ElseIf cTipo == "2"
                    CtbExibe(cConta,"2",,@oDescCrd,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBConta, {lRet, {cConta,cTipo,lHelp,cEmpAnt,cFilCT1}, {lAchou,lSintetica,CT1->(Recno())} } )
            Endif
        Endif

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Program   ³ValidaCust³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Valida Centro de Custo no Lcto Contabil                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³ .T. / .F.                                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpC1 = Centro de Custo Extra Contabil                     ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ValidaCusto(cCusto,cTipo,oDescCCD,oDescCCC,lGetDados,lHelp)

    Local aSaveArea 	:= GetArea()
    Local lRet			:= .T.
    Local nPosCC
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCTT
    Local cFilCTT		:= xFilial('CTT')
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(2)
    Local bCusto 		:= {|x| 	x[2,1] == cCusto .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }
    DEFAULT lHelp		:= .T.

    If CtbInUse()
        //procura no cache dos Centros de Custo ja pesquisados
        If lCache .And. ! Empty(__aCTBCusto) .And. ( nPosCC := Ascan( __aCTBCusto, bCusto) ) > 0
            lRet 		:= __aCTBCusto[nPosCC, 1]
            lAchou 		:= __aCTBCusto[nPosCC, 3, 1]
            lSintetica 	:= __aCTBCusto[nPosCC, 3, 2]
            nRecCTT 	:= __aCTBCusto[nPosCC, 3, 3]
            lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help("  ", 1, "NOCUSTO")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CTT->(dbGoto(nRecCTT))     // posiciona por causa da descricao

                If cTipo == "1"
                    CtbExibeCC(cCusto,"1",@oDescCCD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCC(cCusto,"2",,@oDescCCC,lRet)
                EndIf
            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !Empty(cCusto)
                dbSelectArea("CTT")
                dbSetOrder(1)
                If __CtbFilVld = Nil
                    __CtbFilVld := ExistBlock("CtbFilVld")
                Endif

                If __CtbFilVld
                    cFilCtt := ExecBlock("CtbFilVld", .F., .F., "CTT")
                Else
                    cFilCtt := xFilial()
                Endif

                If !dbSeek(cFilCtt+cCusto)
                    If lHelp
                        Help("  ", 1, "NOCUSTO")
                    Endif
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf
                If lRet
                    If CTT->CTT_CLASSE != "2"				// Centro de Custo Sintetico
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf
            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibeCC(cCusto,"1",@oDescCCD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCC(cCusto,"2",,@oDescCCC,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBCusto, {lRet, {cCusto,cTipo,lHelp,cEmpAnt,cFilCTT}, {lAchou,lSintetica,CTT->(Recno())} } )
            EndIf
        EndIf

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Program   ³ValidItem ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Valida Item Contabil  no Lcto Contabil                     ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³ .T. / .F.                                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpC1 = Item  contabil                                     ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ValidItem(cItem,cTipo,oDescItD,oDescItC,lGetDados,lHelp)

    Local aSaveArea 	:= GetArea()
    Local lRet			:= .T.
    Local nPosItem
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCTD
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(3)
    Local cFilCTD		:= xFilial('CTD')
    Local bItem 		:= {|x| 	x[2,1] == cItem .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }
    DEFAULT lHelp		:= .T.

    If CtbInUse()
        //procura no cache dos Itens Contabeis ja pesquisados
        If lCache .And. ! Empty(__aCTBItem) .And. ( nPosItem := Ascan( __aCTBItem, bItem) ) > 0
            lRet 		:= __aCTBItem[nPosItem, 1]
            lAchou 		:= __aCTBItem[nPosItem, 3, 1]
            lSintetica 	:= __aCTBItem[nPosItem, 3, 2]
            nRecCTD 	:= __aCTBItem[nPosItem, 3, 3]
            lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help(" ", 1, "NOITEM")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CTD->(dbGoto(nRecCTD))     // posiciona por causa da descricao

                If cTipo == "1"
                    CtbExibeIt(cItem,"1",@oDescItD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeIt(cItem,"2",,@oDescItC,lRet)
                EndIf

            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !Empty(cItem)
                dbSelectArea("CTD")
                dbSetOrder(1)
                If !dbSeek(xFilial()+cItem)
                    If lHelp
                        Help(" ", 1, "NOITEM")
                    EndIf
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf
                If lRet
                    If CTD->CTD_CLASSE != "2"				// Item Sintetico
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf
            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibeIt(cItem,"1",@oDescItD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeIt(cItem,"2",,@oDescItC,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBItem, {lRet, {cItem,cTipo,lHelp,cEmpAnt,cFilCTD}, {lAchou,lSintetica,CTD->(Recno())} } )
            EndIf
        EndIf

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Program   ³ValidaCLVL³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Valida Classe de Valor no Lcto Contabil                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³ .T. / .F.                                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpC1 = Classe de Valor                                    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function ValidaCLVL(cCLVL,cTipo,oDescCVD,oDescCVC,lGetDados,lHelp)

    Local aSaveArea 	:= GetArea()
    Local lRet			:= .T.
    Local nPosClasse
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCTH
    Local cFilCTH		:= xFilial('CTH')
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(4)
    Local bClasse 		:= {|x| 	x[2,1] == cCLVL .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }

    DEFAULT lHelp  		:= .T.

    If CtbInUse()
        //procura no cache dos Itens Contabeis ja pesquisados
        If lCache .And. ! Empty(__aCTBClVlr) .And. ( nPosClasse := Ascan( __aCTBClVlr, bClasse) ) > 0
            lRet 		:= __aCTBClVlr[nPosClasse, 1]
            lAchou 		:= __aCTBClVlr[nPosClasse, 3, 1]
            lSintetica 	:= __aCTBClVlr[nPosClasse, 3, 2]
            nRecCTH 	:= __aCTBClVlr[nPosClasse, 3, 3]
            lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help(" ", 1, "NOCLVL")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CTH->(dbGoto(nRecCTH))     // posiciona por causa da descricao

                If cTipo == "1"
                    CtbExibeCV(cCLVL,"1",@oDescCVD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCV(cCLVL,"2",,@oDescCVC,lRet)
                EndIf

            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !Empty(cCLVL)
                dbSelectArea("CTH")
                dbSetOrder(1)
                If !dbSeek(xFilial()+cCLVL)
                    If lHelp
                        Help(" ", 1, "NOCLVL")
                    EndIf
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf

                If lRet
                    If CTH->CTH_CLASSE != "2"				// Classe de Valor Sintetico
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf

            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibeCV(cCLVL,"1",@oDescCVD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCV(cCLVL,"2",,@oDescCVC,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBClVlr, {lRet, {cCLVL,cTipo,lHelp,cEmpAnt,cFilCTH}, {lAchou,lSintetica,CTH->(Recno())} } )
            EndIf
        EndIf

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Programa  ³ NGSD1100I³ Autor ³ Nilton Pereira        ³ Data ³13/07/2001³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³ Inclusao de insumo no registro da NFE                      ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso       ³ Integracao de entrada das NF com SIGAMNT                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Obs.      ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function NGSd1100i(cAliasTPZ)
    Local cOrdem,lFound
    Local lQTDCON     := .F.

    Private lTEMSEQR  := NgVerify("STL")
    Private lSEQTPZ   := NgVerify("TPZ")

    DEFAULT cAliasTPZ := "TRBTPZ"

    dbSelectArea("SX3")
    dbSetOrder(2)
    If dbSeek("TPZ_QTDCON")
        lQTDCON := .T.
    EndIf

    dbSelectArea("SD1")
    If !Empty(SD1->D1_ORDEM)
        cOrdem := SD1->D1_ORDEM
        dbSelectArea("STJ")
        dbSetorder(1)
        If DbSeek(xFilial("STJ") + cOrdem)
            lFOUND   := .F.

            //Lança insumo para OS ja terminada
            lTermino := If(STJ->TJ_TERMINO == "S",.T.,.F.)

            dbSelectArea("STL")
            dbSetorder(7)  // ORDEM DE NUMSEQ
            dbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
            While !Eof() .and. STL->TL_FILIAL == xFilial("STL") .and. ;
                    STL->TL_NUMSEQ == SD1->D1_NUMSEQ

                If Trim(STL->TL_CODIGO) == Trim(SD1->D1_COD) .and. ;
                        Trim(STL->TL_ORDEM)  == cOrdem
                    lFound := .T.
                    Exit
                Endif
                DbSkip()
            End

            If !lFOUND .AND. SD1->D1_TIPO != 'D'
                // Verifica se a OS e uma OS em Lote e se já possui insumo aplicado
                dbSelectArea("TR8")
                dbSetOrder(02)
                If dbSeek(xFilial("TR8")+CORDEM)
                    dbSelectArea("STL")
                    dbSetOrder(01)
                    dbSeek(xFilial("STL")+CORDEM)
                    While STL->(!Eof()) .and.  STL->TL_ORDEM == CORDEM
                        If cValToChar(STL->TL_SEQRELA) > "0" .and. Empty(STL->TL_NUMSEQ)
                            RecLock("STL",.F.)
                            dbDelete()
                            MsUnLock("STL")
                        EndIf
                        dbSelectArea("STL")
                        STL->(dbSkip())
                    End
                EndIf
                NGSD1GESTL(CORDEM,SD1->D1_COD)//Grava Insumo realizado

                NGSD1STLSCOM()

                dbSelectArea("STJ")
                Reclock("STJ",.F.)
                STJ->TJ_TIPORET := "S"
                MsUnlock("STJ")
                If lTermino
                    NGFINAL(STJ->TJ_ORDEM,STJ->TJ_PLANO,STJ->TJ_DTPRINI,STJ->TJ_HOPRINI,STJ->TJ_DTPRFIM,STJ->TJ_HOPRFIM)
                EndIf

                //Grava a garantia do insumo
                dbSelectArea("SD1")
                If FieldPos("D1_GARANTI") > 0
                    If SD1->D1_GARANTI == "S"
                        dbSelectArea(cAliasTPZ)
                        If dbSeek(SD1->D1_ITEM)
                            dbSelectArea("TPZ")
                            RecLock("TPZ",.T.)
                            TPZ->TPZ_FILIAL := xFilial("TPZ")
                            TPZ->TPZ_CODBEM := STJ->TJ_CODBEM
                            TPZ->TPZ_TIPORE := STL->TL_TIPOREG
                            TPZ->TPZ_CODIGO := (cAliasTPZ)->TPZ_CODIGO
                            TPZ->TPZ_LOCGAR := (cAliasTPZ)->TPZ_LOCGAR
                            TPZ->TPZ_ORDEM  := (cAliasTPZ)->TPZ_ORDEM
                            TPZ->TPZ_PLANO  := STJ->TJ_PLANO
                            If lSEQTPZ
                                TPZ->TPZ_SEQREL := STL->TL_SEQRELA
                            EndIf
                            TPZ->TPZ_SEQUEN := STL->TL_SEQUENC
                            If Empty(STL->TL_DTFIM)
                                TPZ->TPZ_DTGARA := STL->TL_DTINICI
                            Else
                                TPZ->TPZ_DTGARA := STL->TL_DTFIM
                            EndIf
                            TPZ->TPZ_QTDGAR := (cAliasTPZ)->TPZ_QTDGAR
                            TPZ->TPZ_UNIGAR := (cAliasTPZ)->TPZ_UNIGAR
                            TPZ->TPZ_CONGAR := (cAliasTPZ)->TPZ_CONGAR
                            If lQTDCON
                                TPZ->TPZ_QTDCON := (cAliasTPZ)->TPZ_QTDCON
                            Endif
                            MsUnlock("TPZ")
                        EndIf
                    EndIf
                EndIf
            ElseIf SD1->D1_TIPO == 'D'
                nQtdeDevol := SD1->D1_QUANT
                aOldArea := GetArea()
                dbSelectArea("SD1")
                dbSetOrder(01)
                If dbSeek(xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
                    dbSelectArea("STL")
                    dbSetOrder(07)
                    dbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
                    While !Eof() .AND. STL->TL_FILIAL == xFilial("STL") .AND. STL->TL_NUMSEQ == SD1->D1_NUMSEQ
                        If STL->TL_TIPOREG == "P" .AND. STL->TL_ORIGNFE == "SD1" .AND. STL->TL_ORDEM == SD1->D1_ORDEM
                            RecLock("STL",.f.)
                            If nQtdeDevol >= STL->TL_QUANTID
                                dbDelete()
                            Else
                                nCustoNovo := (STL->TL_CUSTO/STL->TL_QUANTID)
                                STL->TL_QUANTID -= nQtdeDevol
                                STL->TL_CUSTO := nCustoNovo * STL->TL_QUANTID
                            Endif
                            STL->(MsUnlock())
                        Endif
                        dbSkip()
                    End
                Endif
                dbSelectArea("STL")
                dbSetorder(1)
                If !dbSeek(xFilial("STL")+SD1->D1_ORDEM)
                    dbSelectArea("STJ")
                    dbSetorder(1)
                    If dbSeek(xFilial("STJ")+SD1->D1_ORDEM)
                        RecLock("STJ",.F.)
                        STJ->TJ_TIPORET := " "
                        MsUnlock("STJ")
                    Endif
                Else
                    dbSelectArea("STJ")
                    dbSetorder(1)
                    If dbSeek(xFilial("STJ")+SD1->D1_ORDEM)
                        RecLock("STJ",.F.)
                        STJ->TJ_TIPORET := "S"
                        MsUnlock("STJ")
                    Endif
                Endif
                RestArea(aOldArea)
            Endif
        Endif
    Endif
    DbSelectArea("SD1")

Return

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funcao    ³NGGARANSD1³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Inclusao de garantia do produto utilizado na manutencao     ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso       ³Integracao de entrada das NF com SIGAMNT                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Obs.      ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function NGGARANSD1(cAliasTPZ)
    Local nOPGA2 := 0, lQTDCON := .F.
    Local nORDEM  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_ORDEM" })
    Local nCODIDO := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_COD" })
    Local nITEM   := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_ITEM" })
    Private  nQtde  := 0, nQtdeC := 0,cUni   := " ",cCont := " "
    DEFAULT cAliasTPZ := "TRBTPZ"

    If ExistBlock("NGGARESSD1")
        ExecBlock("NGGARESSD1",.F.,.F.)
    Else
        If M->D1_GARANTI = "S" .And. (Empty(acols[n][nORDEM]) .Or. Empty(acols[n][nCODIDO]))
            MsgInfo(STR0067,STR0068) //"Para informar a garantia é necessário informar a ordem de serviço e código do produto."  # "NÃO CONFORMIDADE"
            Return .F.
        EndIf

        dbSelectArea("SX3")
        dbSetOrder(2)
        If dbSeek("TPZ_QTDCON")
            lQTDCON := .T.
        EndIf

        aUni     := {" ",STR0069,STR0070,STR0020}  //"Dia"#"Semana"#"Mes"
        aCont    := {" ",STR0071,STR0072}  //"Contador 1" # "Contador 2"
        cLocaliz := Space(Len(TPS->TPS_CODLOC))
        cNomLoc  := Space(20)

        If M->D1_GARANTI = "S"

            NGIFDBSEEK("STJ",aCols[n,nORDEM],1)
            lTemCG1 := If(NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_TEMCONT") <> "N",.T.,.F.)
            lTemCG2 := If(NGIFDBSEEK("TPE",STJ->TJ_CODBEM,1,.F.),.t.,.f.)

            dbSelectArea(cAliasTPZ)
            If dbSeek(acols[n][nITEM])

                If !Empty((cAliasTPZ)->TPZ_LOCGAR)
                    cLocaliz := (cAliasTPZ)->TPZ_LOCGAR
                    NGDESLOC((cAliasTPZ)->TPZ_LOCGAR)
                EndIf
                cUni := " "
                nQtde := (cAliasTPZ)->TPZ_QTDGAR
                If (cAliasTPZ)->TPZ_UNIGAR == "D"
                    cUni := STR0069 //"Dia"
                ElseIf (cAliasTPZ)->TPZ_UNIGAR == "S"
                    cUni := STR0070 //"Semana"
                ElseIf (cAliasTPZ)->TPZ_UNIGAR == "M"
                    cUni := STR0020 //"Mes"
                EndIf

                If !Empty((cAliasTPZ)->TPZ_CONGAR)
                    cCont := If((cAliasTPZ)->TPZ_CONGAR == "1",STR0071,STR0072) //"Contador 1" # "Contador 2"
                EndIf
                If lQTDCON
                    nQtdeC := (cAliasTPZ)->TPZ_QTDCON
                EndIf
            EndIf

            If !lQTDCON

                Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0073 Pixel  //"Garantia"

                @ 30,008 Say Oemtoansi(STR0074) Size 47,07 Of oDlg1 Pixel  //"Local"
                @ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGDESLOC(cLocaliz)
                @ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

                @ 45,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
                @ 45,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'
                @ 45,100 Say Oemtoansi(STR0076) Size 47,07 Of oDlg1 Pixel  //"Unidade"
                @ 45,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NGVALINGA(cUni,cCont,1)

                @ 60,008 say OemtoAnSi(STR0077) Size 47,07 Of oDlg1 Pixel  //"Tp Contador"
                @ 60,040 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NGVALINGA(cUni,cCont,2)

                Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA2:=2,If(!NGVALCAMGA(nQtde,cUni,cCont),nOPGA2 := 1,oDlg1:End())},{||nOPGA2:=1,oDlg1:End()}) Centered

            Else
                Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0073 Pixel  //"Garantia"

                @ 1.5,.5 To 3.5,34 LABEL STR0078 OF oDlg1 //"Localizacao"
                @ 30,008 Say Oemtoansi(STR0074) Size 47,07 Of oDlg1 Pixel  //"Local"
                @ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGDESLOC(cLocaliz)
                @ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

                @ 4.0,.5 To 6.0,34 LABEL STR0073+" "+STR0079+" "+STR0080 OF oDlg1 //"Garantia"#"por"#"Tempo"
                @ 65,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
                @ 65,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'
                @ 65,100 Say Oemtoansi(STR0076) Size 47,07 Of oDlg1 Pixel  //"Unidade"
                @ 65,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NGVALINGA(cUni,cCont,1,nQtde)

                @ 6.5,.5 To 8.5,34 LABEL STR0073+" "+STR0079+" "+STR0081 OF oDlg1  //"Garantia"# "por"# "Contador"
                @ 100,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
                @ 100,040 MsGet nQtdeC Size 38,08 Of oDlg1 Pixel  Valid positivo(nQtdeC) Picture '@E 999,999,999' When lTemCG1 .Or. lTemCG2
                @ 100,100 say OemtoAnSi(STR0077) Size 47,07 Of oDlg1 Pixel  //"Tp Contador"
                @ 100,132 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NGVALINGA(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2

                Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA2:=2,If(!NGVALCAMGA(nQtde,cUni,cCont,nQtdeC),nOPGA2 := 1,oDlg1:End())},{||nOPGA2:=1,oDlg1:End()}) Centered
            Endif

            If nOPGA2 == 2

                //Grava informacoes de garantia no arquivo temporario
                dbSelectArea(cAliasTPZ)
                If dbSeek(acols[n][nITEM])
                    RecLock(cAliasTPZ,.F.)
                Else
                    RecLock(cAliasTPZ,.T.)
                    (cAliasTPZ)->TPZ_ITEM := acols[n][nITEM]
                EndIf
                (cAliasTPZ)->TPZ_CODIGO := acols[n][nCODIDO]
                (cAliasTPZ)->TPZ_LOCGAR := cLocaliz
                (cAliasTPZ)->TPZ_ORDEM  := acols[n][nORDEM]
                (cAliasTPZ)->TPZ_QTDGAR := nQtde
                (cAliasTPZ)->TPZ_UNIGAR := cUni
                If cCont == STR0071 //"Contador 1"
                    (cAliasTPZ)->TPZ_CONGAR := "1"
                ElseIf cCont == STR0072 //"Contador 2"
                    (cAliasTPZ)->TPZ_CONGAR := "2"
                Else
                    (cAliasTPZ)->TPZ_CONGAR := ""
                EndIf

                If lQTDCON
                    (cAliasTPZ)->TPZ_QTDCON := nQtdeC
                EndIf
                MsUnLock(cAliasTPZ)
            EndIf
        EndIf
    EndIf

Return .t.

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funcao    ³NGDESLOC  ³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Consistencia para mostrar a descricao da Localizacao        ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Static Function NGDESLOC(cLocaliz)

    dbSelectArea("TPS")
    dbSetOrder(1)
    If dbSeek(xFilial("TPS")+cLocaliz)
        cNomLoc := TPS->TPS_NOME
    EndIf

Return .t.

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funcao    ³NGVALINGA ³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Validacao dos campos de garantia                            ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Static Function NGVALINGA(cUni,cCont,nTipo,nQtd)

    dbSelectArea("SX3")
    dbSetOrder(2)
    If dbSeek("TPZ_QTDCON")
        If nTipo =2
            If Empty(cCont) .And. !Empty(nQtd)
                MsgStop(STR0082,STR0068) //"Informe qual o tipo do contador." # "NÃO CONFORMIDADE"
                Return .f.
            EndIf
        Else
            If Empty(cUni) .And. !Empty(nQtd)
                MsgStop(STR0083,STR0068) //"Informe a unidade." #"NÃO CONFORMIDADE"
                Return .f.
            EndIf
        EndIf
    Else
        If nTipo =2
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0084,STR0068) //"Nao pode ter unidade a garantia controlada por contador." # "NÃO CONFORMIDADE"
                Return .f.
            EndIf
        Else
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0085,STR0068) // "Nao pode ter contador a garantia controlada por tempo." # "NÃO CONFORMIDADE"
                Return .f.
            EndIf
        EndIf
    Endif
Return .T.

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funcao    ³NGVALCAMGA³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Valida todos os campos de garantia que foram informados     ³±±
    ±±³          ³no botao de OK                                              ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Retorno   ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Static Function NGVALCAMGA(nQtde,cUni,cCont,nQtdeC)

    dbSelectArea("SX3")
    dbSetOrder(2)
    If dbSeek("TPZ_QTDCON")

        If Empty(cCont) .And. nQtdeC == 0 .And. Empty(cUni) .And. nQtde == 0
            MsgStop(STR0086,STR0068) //"Entre com as informações necessárias para gravar a garantia do insumo." # "NÃO CONFORMIDADE"
            Return .f.
        EndIf

        If Empty(cCont) .And. nQtdeC > 0
            MsgStop(STR0082,STR0068) //"Informe qual o tipo do contador." # "NÃO CONFORMIDADE"
            Return .f.
        EndIf

        If !Empty(cCont) .And. nQtdeC == 0
            MsgStop(STR0087,STR0068) //"Informe a quantidade para a garantia controlada por contador." # "NÃO CONFORMIDADE"
            Return .f.
        EndIf

        If Empty(cUni) .And. nQtde > 0
            MsgStop(STR0088,STR0068) // "Informe a unidade para a garantia controlada por tempo." # "NÃO CONFORMIDADE"
            Return .f.
        EndIf

        If !Empty(cUni) .And. nQtde == 0
            MsgStop(STR0089,STR0068) // "Informe a quantidade para a garantia controlada por tempo." # "NÃO CONFORMIDADE"
            Return .f.
        EndIf

    Else

        If Empty(cCont) .And. Empty(cUni) .And. nQtde == 0
            MsgStop(STR0086,STR0068) // "Entre com as informações necessárias para gravar a garantia do insumo." # "NÃO CONFORMIDADE"
            Return .f.
        EndIf

        If nTipo =2
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0084,STR0068) //"Nao pode ter unidade a garantia controlada por contador."# "NÃO CONFORMIDADE"
                Return .f.
            EndIf
        Else
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0085,STR0068) //"Nao pode ter contador a garantia controlada por tempo." # "NÃO CONFORMIDADE"
                Return .f.
            EndIf
        EndIf

        If nQtde == 0 .And. (!Empty(cCont) .Or. !Empty(cUni))
            MsgStop(STR0090,STR0068) //""Informe a quantidade." # NÃO CONFORMIDADE"
            Return .f.
        EndIf

    Endif

    If  !MNT400GF(lTemCG1,lTemCG2)
        Return .f.
    EndIf

Return .t.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o    ³NGSD1STLSCOM³ Autor ³In cio Luiz Kolling  ³ Data ³14/07/2005³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³Grava os campos complementares do SD1 para STL              ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³GENERICO                                                    ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Static Function NGSD1STLSCOM()
    Local nVP      := 0
    Local vVETCAMN := {"_FILIAL","_NUMSEQ","_ORDEM"}
    Local aESTRUT  := {}

    DbSelectArea("STL")
    aESTRUT := DbStruct()

    RecLock("STL",.F.)
    DbSelectArea("SD1")
    For nVP := 1 To Fcount()
        ny := Fieldname(nVP)
        nc := "STL->TL"+Alltrim(Substr(ny,3,Len(ny)))
        cCAMPP := Alltrim(Substr(ny,3,Len(ny)))
        If Ascan(vVETCAMN, {|x| x == Alltrim(Substr(ny,3,Len(ny)))}) = 0
            If Ascan(aESTRUT, {|x| Alltrim(Substr(x[1],3,Len(x[1]))) == cCAMPP}) > 0
                nx   := "SD1->"+Fieldname(nVP)
                &nc. := &nx.
            Endif
        Endif
    Next
    MsUnlock("STL")
Return .t.

				/*
				ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
				±±³Fun‡…o    ³NGSTLSD3SCOM³ Autor ³In cio Luiz Kolling  ³ Data ³14/07/2005³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Descri‡…o ³Grava os campos complementares do STL para SD3 e vice versa ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³Paramentro³vALIAP  - Alias do arquivo com os valores - Obrigatorio     ³±±
				±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
				±±³ Uso      ³GENERICO                                                    ³±±
				±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
				±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
				ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				*/
Static Function NGSTLSD3SCOM(vALIAP)
    Local nVP      := 0
    Local cPRER    := If(vALIAP = "STL","D3","TL")
    Local cALIVAL  := If(vALIAP = "STL","STL","SD3")
    Local cALIREC  := If(vALIAP = "STL","SD3","STL")
    Local vVETCAMN := {"_FILIAL","_NUMSEQ","_ORDEM"}
    Local aESTRUT  := {}

    DbSelectArea(cALIREC)
    aESTRUT := DbStruct()

    RecLock(cALIREC,.F.)
    DbSelectArea(cALIVAL)
    For nVP := 1 To Fcount()
        ny := Fieldname(nVP)
        nc := cALIREC+"->"+cPRER+Alltrim(Substr(ny,3,Len(ny)))
        cCAMPP := Alltrim(Substr(ny,3,Len(ny)))
        If Ascan(vVETCAMN, {|x| x == Alltrim(Substr(ny,3,Len(ny)))}) = 0
            If Ascan(aESTRUT, {|x| Alltrim(Substr(x[1],3,Len(x[1]))) == cCAMPP}) > 0
                nx   := cALIVAL+"->"+Fieldname(nVP)
                &nc. := &nx.
            Endif
        Endif
    Next
    MsUnlock(cALIREC)
Return .t.

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Programa  ³ ULTSEQ1  ³ Autor ³ Nilton Pereira        ³ Data ³13/07/2001³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³ Incrementa a sequencia do insumo (proxima sequencia)       ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso       ³ Integracao de entrada das NF com SIGAMNT                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Obs.      ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Static Function UltSeq1()
    Local cSEQ := "0  ",lPRIMLO := .T.
    Local nSEQ := 0
    OLDKEY := INDEXORD()
    DbSelectArea("STL")
    DbSetOrder(3)
    DbSeek(xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO)

    While !Eof() .And. STL->TL_FILIAL == xFILIAL('STL') .And. STL->TL_ORDEM == STJ->TJ_ORDEM;
            .And. STL->TL_PLANO == STJ->TJ_PLANO
        If lTEMSEQR
            If Val(stl->tl_seqrela) > 0
                If Val(STL->TL_SEQRELA) > Val(cSEQ)
                    cSEQ := STL->TL_SEQRELA
                Endif
            Else
                If isDigit(Substr(stl->tl_seqrela,1,1))
                Else
                    cSEQ := If(lPRIMLO,stl->tl_seqrela,If(stl->tl_seqrela > cSEQ,stl->tl_seqrela,cSEQ))
                    lPRIMLO := .F.
                Endif
            Endif
        Endif
        nSEQ := MAX(nSEQ,STL->TL_SEQUENC)
        DbSkip()
    End
    DbSetOrder(1)
    If lTEMSEQR
        If !lPRIMLO
            //cSEQR := PADL(Soma1(cSEQ),3)
            cSEQR := PADL(Soma1Old(cSEQ),3)
        Else
            //cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1(cSEQ),3))
            cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1Old(cSEQ),3))
        Endif
    Else
        cSEQR := If(nSEQ == 0,1,nSEQ+1)
    Endif
Return cSEQR

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o    ³ NGSD1100E³ Autor ³ Nilton Pereira        ³ Data ³13/07/2001³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Exclusao de insumo no registro da NFE ( ESTORNO )          ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso       ³ Integracao de entrada das NF com SIGAMNT                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³OBS       ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Function NGSd1100e()
    Local OLDALI,CORDEM, nQuant := 0
    OldAli := Alias()

    If !Empty(SD1->D1_ORDEM)
        cORDEM := SD1->D1_ORDEM
        DbSelectArea("STJ")
        DbSetorder(1)

        IF DbSeek(xFilial("STJ") + cORDEM) .and. stj->tj_situaca == 'L' .and.;
                stj->tj_termino == 'N'
            DbSelectArea("STL")
            DbSetorder(7)

            IF DbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
                DbSelectArea("STN")
                DbSetorder(1)
                If DbSeek(xFilial("STN")+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA)
                    While !Eof() .And. STN->TN_FILIAL = Xfilial("STN") .And.;
                            STN->TN_ORDEM = STL->TL_ORDEM .And. STN->TN_TAREFA = STL->TL_TAREFA;
                            .And. STN->TN_SEQRELA = STL->TL_SEQRELA
                        RecLock("STN",.F.)
                        dbDelete()
                        MSUNLOCK("STN")
                        DbSkip()
                    End
                EndIf
                DbSelectArea("SD1")
                If FieldPos("D1_GARANTI") > 0 .And. SD1->D1_GARANTI == "S"
                    DbSelectArea("TPZ")
                    DbSetOrder(2)
                    cChaTPZ := STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
                    If DbSeek(xfilial("TPZ")+cChaTPZ)
                        While !Eof() .And. TPZ->TPZ_FILIAL = Xfilial("TPZ") .And.;
                                TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO+TPZ->TPZ_SEQREL = cChaTPZ
                            RecLock("TPZ",.F.)
                            dbDelete()
                            MSUNLOCK("TPZ")
                            DbSkip()
                        End
                    EndIf
                EndIf
                DbSelectArea("STL")
                RecLock("STL",.F.)
                dbDelete()
                MSUNLOCK("STL")
            Endif

            If NGCADICBASE("TL_NOTFIS","A","STL",.F.) .And. NGCADICBASE("TL_SERIE","A","STL",.F.)
                dbSelectArea("STL")
                dbSetOrder(4)
                If dbSeek(xFilial("STL")+SD1->D1_ORDEM)
                    aOldArea := GetArea()
                    While !Eof() .AND. STL->TL_FILIAL == xFilial("STL") .AND. STL->TL_ORDEM == SD1->D1_ORDEM
                        If STL->TL_TIPOREG == "P" .AND. STL->TL_ORIGNFE == "SD1" .AND. STL->TL_ORDEM == SD1->D1_ORDEM .AND.;
                                STL->TL_NOTFIS == SD1->D1_NFORI .AND. STL->TL_SERIE == SD1->D1_SERIORI
                            If SD1->D1_TIPO == 'D'
                                nQuant := STL->TL_QUANTID + SD1->D1_QUANT
                            Else
                                nQuant := STL->TL_QUANTID - SD1->D1_QUANT
                            Endif

                            RecLock("STL",.f.)
                            If nQuant <= 0
                                dbDelete()
                            Else
                                nCustoNovo := (STL->TL_CUSTO/STL->TL_QUANTID)
                                STL->TL_QUANTID -= nQtdeDevol
                                STL->TL_CUSTO := nCustoNovo * STL->TL_QUANTID
                            Endif
                            MsUnlock("STL")
                        Endif
                        dbSelectArea("STL")
                        dbSkip()
                    End
                    RestArea(aOldArea)
                Else
                    dbSelectArea("SD1")
                    aOldArea := GetArea()
                    dbSetOrder(01)
                    If	dbSeek(xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
                        NGSD1GESTL(SD1->D1_ORDEM,SD1->D1_COD)
                    Endif
                    RestArea(aOldArea)
                Endif
            Endif

            DbSelectArea("STL")
            DbSetorder(1)

            If !DbSeek( xFilial("STJ") + cORDEM)
                DbSelectArea("STJ")
                RecLock("STJ",.F.)
                STJ->TJ_TIPORET := " "
                MsUnlock("STJ")
            Else
                RecLock("STJ",.F.)
                STJ->TJ_TIPORET := "S"
                MsUnlock("STJ")
            Endif
        Endif
    Endif

    DbSelectArea(OldAli)
Return NIL

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Programa  ³ NGSD3240I³ Autor ³ Nilton Pereira        ³ Data ³ 30/07/99 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³ Atualizacao apos a gravacao de movto. interno              ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso       ³ Generico                                                   ³±±
    ±±³          ³                                                            ³±±
    ±±³          ³ Objetivo: Gravar a Requisicao no SIGAMNT                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/

Function NGsd3240i(nLinha)
    Local CORDEM,LFOUND,CTIPOREG,vVDATFIM,nLinSD3 := If(nLinha = Nil .Or. nLinha = 0,1,nLinha)
    Local aTercProd := {}
    Local lTercProd := .F.
    Private lTEMSEQR := NgVerify("STL")
    Private dDtMDO   := Ctod("  /  /  "),cHoMDO := Space(5)

    If !Empty(SD3->D3_ORDEM) .and. SubStr(SD3->D3_CF,1,2) == "RE"
        cORDEM := SD3->D3_ORDEM
        DbSelectArea("STJ")
        DbSetorder(1)

        If DbSeek(xFilial("STJ") + cORDEM)
            lFOUND   := .F.

            //Recebe os Produtos de Terceiros do parametro
            If FindFunction("NGProdMNT")
                aTercProd := aClone(NGProdMNT("T"))
                lTercProd := ( aScan(aTercProd, {|x| AllTrim(x) == AllTrim(SD3->D3_COD) }) > 0)
            Else
                lTercProd := ( AllTrim(GetMV("MV_PRODTER")) == AllTrim(SD3->D3_COD) )
            EndIf

            cTIPOREG := If(lTercProd, "T", "P")

            If cTIPOREG = "P"
                If NGIFFILSEEK("STL",xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
                    While !Eof() .And. STL->TL_FILIAL = Xfilial("STL") .And.;
                            STL->TL_ORDEM = STJ->TJ_ORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO
                        If Alltrim(STL->TL_SEQRELA) <> "0" .And. STL->TL_TIPOREG = "M"
                            dDtMDO := STL->TL_DTINICI
                            cHoMDO := STL->TL_HOINICI
                            Exit
                        Endif
                        Dbskip()
                    End
                Endif
            Endif

            DbSelectArea("STL")
            DbSetorder(7)
            DbSeek(xFilial("STL")+SD3->D3_NUMSEQ)
            While !Eof() .and. STL->TL_FILIAL == xFilial("STL") .and. ;
                    STL->TL_NUMSEQ == SD3->D3_NUMSEQ

                If Trim(STL->TL_CODIGO) == Trim(SD3->D3_COD) .and. ;
                        Trim(STL->TL_ORDEM)  == cORDEM
                    lFound := .T.
                    Exit
                Endif
                DbSkip()
            End

            If !lFOUND
                nSEQSTL := ULTSEQ1()
                DbSelectArea("STL")
                Reclock("STL",.T.)
                STL->TL_FILIAL  := xfilial('STL')
                STL->TL_ORDEM   := cORDEM
                STL->TL_PLANO   := STJ->TJ_PLANO
                STL->TL_CODIGO  := SD3->D3_COD
                STL->TL_TIPOREG := cTIPOREG
                STL->TL_TAREFA  := '0'
                STL->TL_USACALE := 'N'
                STL->TL_GARANTI := 'N'
                If lTEMSEQR
                    STL->TL_SEQRELA := nSEQSTL
                Else
                    STL->TL_SEQUENC := nSEQSTL
                Endif
                STL->TL_UNIDADE := If(cTIPOREG = "T","H",SD3->D3_UM)
                STL->TL_QUANTID := SD3->D3_QUANT
                STL->TL_NUMSEQ  := SD3->D3_NUMSEQ
                STL->TL_DTINICI := SD3->D3_EMISSAO
                STL->TL_HOINICI := '08:00'

                If cTIPOREG = "T"
                    vVDATFIM := NGDTHORFIM(SD3->D3_EMISSAO,'08:00',SD3->D3_QUANT)
                    STL->TL_DTFIM := vVDATFIM[1]
                    STL->TL_HOFIM := vVDATFIM[2]
                Else
                    STL->TL_DTFIM := SD3->D3_EMISSAO
                    STL->TL_HOFIM := '08:00'
                EndIf
                STL->TL_DESTINO := If(cTIPOREG = 'T',' ','A')
                STL->TL_REPFIM  := 'S'
                STL->TL_CUSTO   := SD3->D3_CUSTO1
                STL->TL_TIPOHOR := ALLTrim(GETMV("MV_NGUNIDT"))

                If cTIPOREG = "P" .And. !Empty(dDtMDO) .And. !Empty(cHoMDO)
                    STL->TL_DTINICI := dDtMDO
                    STL->TL_HOINICI := cHoMDO
                    STL->TL_DTFIM   := dDtMDO
                    STL->TL_HOFIM   := cHoMDO
                Endif

                If FieldPos("TL_ORIGNFE") > 0
                    STL->TL_ORIGNFE := 'SD3'
                Endif

                If FieldPos("TL_NOTFIS") > 0
                    STL->TL_NOTFIS := SD3->D3_DOC
                Endif

                MSUNLOCK("STL")

                NGSTLSD3SCOM("SD3")

                DbSelectArea("STJ")
                Reclock("STJ",.F.)
                STJ->TJ_TIPORET := "S"
                MsUnlock("STJ")
            Endif
        Endif
        If  FindFunction("NGD3GARANT") .And. NGD3GARANT()  .And. SD3->D3_GARANTI = "S"
            If Type("aMntGarant") == "A"
                nLSD3 := Ascan(aMntGarant,{|x| x[11] = nLinSD3 })
                If nLSD3  > 0
                    NGGRVGARAN(aMntGarant,nLSD3,STL->TL_SEQRELA)
                EndIf
            EndIf
        EndIf
    Endif
    DbSelectArea("SD3")

Return(.T.)

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o    ³ NGSD3240E³ Autor ³ Nilton Pereira        ³ Data ³ 04/11/99 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³ Atualizacao apos a gravacao de movto. interno ( ESTORNO )  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Generico                                                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ OBS.:    ³                                                            ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/

Function NGSd3240e()
    Local OLDALI,CPLANO,CORDEM
    Private lRegVir := .f.,nDifVir := 0, nACUMFIF := 0
    OldAli := Alias()
    If !Empty(SD3->D3_ORDEM)
        cPLANO := SUBSTR(SC2->C2_OBS,7,6)
        cORDEM := SD3->D3_ORDEM
        DbSelectArea("STJ")
        DbSetorder(1)

        IF DbSeek(xFilial("STJ") + cORDEM) .and. stj->tj_situaca == 'L' .and.;
                stj->tj_termino == 'N'
            DbSelectArea("SF5")
            DbSetorder(1)
            DbSeek(xFilial("SF5") + M->D3_TM)

            If sf5->f5_tipo == "R"
                DbSelectArea("STL")
                DbSetorder(7)

                IF DbSeek(xFilial("STL")+SD3->D3_NUMSEQ)
                    DbSelectArea("STN")
                    DbSetorder(1)
                    If DbSeek(xFilial("STN")+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA)
                        While !Eof() .And. STN->TN_FILIAL = Xfilial("STN") .And.;
                                STN->TN_ORDEM = STL->TL_ORDEM .And. STN->TN_TAREFA = STL->TL_TAREFA;
                                .And. STN->TN_SEQRELA = STL->TL_SEQRELA
                            RecLock("STN",.F.)
                            dbDelete()
                            MSUNLOCK("STN")
                            DbSkip()
                        End
                    EndIf
                    DbSelectArea("SD3")
                    If NGCADICBASE("D3_GARANTI","A","SD3",.F.)  .And.   SD3->D3_GARANTI == "S
                        DbSelectArea("TPZ")
                        DbSetOrder(2)
                        cChaTPZ := STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
                        If DbSeek(xfilial("TPZ")+cChaTPZ)
                            While !Eof() .And. TPZ->TPZ_FILIAL = Xfilial("TPZ") .And.;
                                    TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO+TPZ->TPZ_SEQREL = cChaTPZ

                                RecLock("TPZ",.F.)
                                dbDelete()
                                MSUNLOCK("TPZ")
                                DbSkip()
                            End
                        EndIf
                    EndIf
                    DbSelectArea("STL")
                    RecLock("STL",.F.)
                    dbDelete()
                    MSUNLOCK("STL")
                Endif

                DbSelectArea("STL")
                DbSetorder(1)

                If !DbSeek( xFilial("STJ") + cORDEM)
                    DbSelectArea("STJ")
                    RecLock("STJ",.F.)
                    STJ->TJ_TIPORET := " "
                    MsUnlock("STJ")
                Else
                    DbSelectArea("STJ")
                    RecLock("STJ",.F.)
                    STJ->TJ_TIPORET := "S"
                    MsUnlock("STJ")
                Endif
            Endif
        Endif
    Endif

    If nModulo != 19
        DbSelectArea("SX6")
        DbSetorder(1)
        If GetNewPar("MV_NGMNTFR","N") = "S"
            nOrdId := NGRETORDEM("TQN","TQN_FILIAL+TQN_NUMSEQ")
            If nOrdId > 0
                DbSelectArea("TQN")
                DbSetorder(nOrdId)

                If DbSeek(xFilial("TQN")+SD3->D3_NUMSEQ)
                    // PROCESSO COPIADO DO MNTA655

                    DbSelectArea("ST9")
                    DbSetOrder(16)
                    If DbSeek(TQN->TQN_FROTA)
                        cFilBem	:= ST9->T9_FILIAL
                    EndIf
                    aRetTPN := NgFilTPN(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS)
                    cFilTPN := aRetTPN[1]
                    If cFilTPN = " "
                        cFilTPN := TQN->TQN_FILIAL
                    EndIf

                    lSegCont := NGCADICBASE("TQN_POSCO2","A","TQN",.F.)

                    //Referentes ao primeiro contador
                    aARALTC := {'STP','stp->tp_filial','stp->tp_codbem',;
                        'stp->tp_dtleitu','stp->tp_hora','stp->tp_poscont',;
                        'stp->tp_acumcon','stp->tp_vardia','stp->tp_viracon'}
                    aARABEM := {'ST9','st9->t9_poscont','st9->t9_contacu',;
                        'st9->t9_dtultac','st9->t9_vardia'}

                    DbSelectArea(aARALTC[1])
                    Dbsetorder(5)
                    If Dbseek(xFilial(aARALTC[1],cFilTPN)+TQN->TQN_FROTA+Dtos(TQN->TQN_DTABAS)+TQN->TQN_HRABAS)
                        nRECNSTP := Recno()
                        nRECASTP := 0
                        lULTIMOP := .T.
                        nACUMFIP := 0
                        nCONTAFP := 0
                        nVARDIFP := 0
                        dDTACUFP := Ctod('  /  /  ')
                        DbSkip(-1)
                        If !Eof() .And. !Bof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                &(aARALTC[3]) = TQN->TQN_FROTA
                            nACUMFIP := &(aARALTC[7])
                            dDTACUFP := &(aARALTC[4])
                            nCONTAFP := &(aARALTC[6])
                            nVARDIFP := &(aARALTC[8])
                            nRECASTP := Recno()
                        Endif
                        Dbgoto(nRECNSTP)

                        nACUMDEL := stp->tp_acumcon

                        DbSelectArea(aARALTC[1])
                        RecLock(aARALTC[1],.F.)
                        Dbdelete()
                        MsUnlock(aARALTC[1])
                        MNTA875ADEL(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,2,cFilTPN,cFilTPN)
                        DbSelectArea(aARALTC[1])
                        If nRECASTP > 0
                            Dbgoto(nRECASTP)
                            DbSkip()
                            If !Eof() &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                    &(aARALTC[3]) = TQN->TQN_FROTA
                            Else
                                NGATUCONT(STP->TP_CODBEM,STP->TP_DTLEITU,STP->TP_POSCONT,;
                                    STP->TP_ACUMCON,STP->TP_VARDIA,1,.f.,.f.)
                            Endif
                        Endif
                    Endif

                    //Referentes ao segundo contador
                    If lSegCont
                        dbSelectArea("TPE")
                        dbSetOrder(1)
                        If DbSeek(If(NGSX2MODO("TPE")="E",cFilBem,xFilial("TPE"))+TQN->TQN_FROTA)
                            aARALTC := {'TPP','tpp->tpp_filial','tpp->tpp_codbem',;
                                'tpp->tpp_dtleit','tpp->tpp_hora','tpp->tpp_poscon',;
                                'tpp->tpp_acumco','tpp->tpp_vardia','tpp->tpp_viraco'}
                            aARABEM := {'TPE','tpe->tpe_poscon','tpe->tpe_contac',;
                                'tpe->tpe_dtulta','tpe->tpe_vardia'}
                            DbSelectArea(aARALTC[1])
                            Dbsetorder(5)
                            If Dbseek(xFilial(aARALTC[1],cFilTPN)+TQN->TQN_FROTA+Dtos(TQN->TQN_DTABAS)+TQN->TQN_HRABAS)
                                nRECNSTP := Recno()
                                nRECATPP := 0
                                lULTIMOP := .T.
                                nACUMFIP := 0
                                nCONTAFP := 0
                                nVARDIFP := 0
                                dDTACUFP := Ctod('  /  /  ')
                                DbSkip(-1)
                                If !Eof() .And. !Bof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                        &(aARALTC[3]) = TQN->TQN_FROTA
                                    nACUMFIP := &(aARALTC[7])
                                    dDTACUFP := &(aARALTC[4])
                                    nCONTAFP := &(aARALTC[6])
                                    nVARDIFP := &(aARALTC[8])
                                Endif
                                Dbgoto(nRECNSTP)

                                nACUMDEL := TPP->TPP_ACUMCO

                                DbSelectArea(aARALTC[1])
                                RecLock(aARALTC[1],.F.)
                                Dbdelete()
                                MsUnlock(aARALTC[1])

                                MNTA875ADEL(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,2,cFilTPN,cFilTPN)

                                DbSelectArea(aARALTC[1])
                                If nRECATPP > 0
                                    Dbgoto(nRECATPP)
                                    DbSkip()
                                    If !Eof() &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                            &(aARALTC[3]) = cCodfrot
                                    Else
                                        NGATUCONT(TPP->TPP_CODBEM,TPP->TPP_DTLEIT,TPP->TPP_POSCON,;
                                            TPP->TPP_ACUMCO,TPP->TPP_VARDIA,"2",.f.,.f.)
                                    Endif
                                Endif
                            Endif
                        EndIf
                    EndIf
                    NGDelTTVAba(TQN->TQN_NABAST)

                    DbSelectArea("TQN")
                    RecLock("TQN",.F.)
                    Dbdelete()
                    MsUnlock("TQN")

                Endif
            Endif
        Endif
    Endif

    DbSelectArea(OldAli)
return nil

				/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡„o    ³NGDTHORFIM³ Autor ³Inacio Luiz Kolling    ³ Data ³04/08/2005³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡„o ³Calcula a data e hora fim a partir de uma data e hora       ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³GENERICA                                                    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Static Function NGDTHORFIM(dVDATI,cVHORI,nQTDHO)
    Local cINI  := HTOM(cVHORI),cDAT := dVDATI
    Local nHINT := Int(nQTDHO)
    Local nREST := (nQTDHO-nHINT) * 100
    Local cFIM  := If(GetMv("MV_NGUNIDT") = "D",cINI+(nQTDHO * 60),cINI+((nHINT * 60)+nREST))
    Local nSOMA := 0

    While cFIM > 1440
        nSOMA++
        cFIM -= 1440
    End
    dDATF  := cDAT+nSOMA
    cHORAF := MTOH(cFIM)
Return {dDATF,cHORAF}

				/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o    ³  HTOM    ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Converte horas em minutos                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ Parametros -> cTime -> Horas em 99:99                      ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Generico                                                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
				/*/
Static Function HTOM(cTIME)
    Local nHORA,nMINUTO,POS

    POS := At(":",cTIME)
    If POS == 0;Return 0;End
        nHORA   := Val(Substr(cTIME,1,(POS-1)))
        nMINUTO := Val(Substr(cTIME,(POS+1)))
        Return (nHORA*60)+nMINUTO

					/*/
        ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
        ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
        ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
        ±±³Fun‡…o    ³  MTOH    ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
        ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
        ±±³Descri‡…o ³ Converte minutos em horas                                  ³±±
        ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
        ±±³Parametros³ Parametros -> nMINUTO                                      ³±±
        ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
        ±±³ Uso      ³ Generico                                                   ³±±
        ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
        ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
        ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
					/*/
Static Function MTOH(nMINUTO)
    Local nHoras,nRest,cRet,cHoraC := Alltrim(Str(nMINUTO))
    Local nPonVi := At(".",cHoraC)
    If nPonVi = 0
        nPonVi := At(",",cHoraC)
    EndIf

    nHoras := INT(nMINUTO / 60)
    nRest  := INT(nMINUTO % 60)

    If nPonVi = 0
        nPonVi := At(",",cHoraC)
    EndIf
    If nPonVi > 0
        nMinuM := Val(Substr(cHoraC,nPonVi+1,1))
        If nMinuM > 5
            nRest += 1
        Endif
    EndIf

    cRet   := StrZero(nHoras,2) + ":" + StrZero(nRest,2)

    If nHORAS > 99
        cRET := StrZero(nHoras,3) + ":" + StrZero(nRest,2)
    EndIf
    If nHORAS > 999
        cRet := StrZero(nHoras,4) + ":" + StrZero(nRest,2)
    EndIf
    If nHORAS > 9999
        cRet := StrZero(nHoras,5) + ":" + StrZero(nRest,2)
    EndIf
    If nHORAS > 99999
        cRet := StrZero(nHoras,6) + ":" + StrZero(nRest,2)
    EndIf
Return cRET

					/*
					ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
					±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
					±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
					±±³Fun‡„o	 ³GetAutoPar  ³ Autor ³ Eduardo Motta   		  ³ Data ³ 26/02/02 ³±±
					±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
					±±³Descri‡„o ³ Funcao para retornar parametros em array de rotina Automatica ³±±
					±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
					±±³Sintaxe	 ³ GetAutoPar(cPar,aRotAuto,uDef)								 ³±±
					±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
					±±³Parametros³cPar     - Nome do parametro          						 ³±±
					±±³          ³aRotAuto - Array da rotina automatica						     ³±±
					±±³          ³uDef     - Valor default do parametro, caso nao exista     	 ³±±
					±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
					±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
					ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
					*/
Function GetAutoPar(cPar,aArray,uDef)
    Local nPos := aScan(aArray,{|x|Upper(AllTrim(x[1]))==AllTrim(Upper(cPar))})
    Local uRet
    If nPos == 0
        uRet := uDef
    Else
        uRet := aArray[nPos,2]
    EndIf
Return uRet

					/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Fun‡…o	 ³ AvalCond ³ Autor ³ Henry Fila            ³ Data ³ 14.11.03  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³ Rotina para avaliar condicao de pagamento 				   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe	 ³ ExpA1 := AvalCond(ExpN1,ExpC1,ExpN2,ExpD1,ExpN3,ExpA2)	   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ ExpA1 = Array contEndo os valores e os vencimentos de cada  ³±±
    ±±³			 ³ 		  parcela.											   ³±±
    ±±³			 ³ ExpN1 = Valor total a ser parcelado.                        ³±±
    ±±³			 ³ ExpC1 = Codigo da condicao de pagamento a ser considerada.  ³±±
    ±±³			 ³ ExpN2 = Valor do IPI destacado para condicao que obrigue o  ³±±
    ±±³			 ³ 		  IPI a entrar na 1a parcela.                          ³±±
    ±±³			 ³ ExpD1 = Data inicial para considerar desdobramento 		   ³±±
    ±±³			 ³ ExpN3 = Valor do ICMS Solidario                             ³±±
    ±±³			 ³ ExpA2 = Array contEndo a sigla e valor dos impostos calcula-³±±
    ±±³			 ³ 		  dos para os paises Internacionais (MercoSul...)	   ³±±
    ±±³			 ³ ExpA3 = Array contendo dados semelhantes ao que teria no    ³±±
    ±±³			 ³ 		  SE4 												   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Uso		 ³ Generico                                                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³	MOTIVO DA ALTERACAO                    ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Rogerio F.G. ³18/11/97³B.HUR ³Alt Cond Pagto Tipo 9                    ³±±
    ±±³ Rogerio F.G. ³24/11/97³B.HUR ³Ajuste Valor Cond Pagto tipo 8           ³±±
    ±±³ Lucas        ³29.06.98³16770A³Adaptacao para os impostos MercoSul...   ³±±
    ±±³ Aline C.Vale ³13.09.99³xxxxxx³Consistencia do ultimo dia da cond. 3    ³±±
    ±±³ Aline C.Vale ³20.09.99³18368A³Acerto na Cond.Pgto.Tipo 7               ³±±
    ±±³ Aline C.Vale ³25.10.99³24332A³Tratar Junta IPI na Cond.Pgto.Tipo 8     ³±±
    ±±³ Sandro       ³02.03.00³xxxxxx|funcionamento sem a existencia da codicao³±±
    ±±³              ³        ³      |cadastrada no SE4                        ³±±
    ±±³Bruna Zechetti³30.12.09³      ³Ajustada a validação nos campos FB_JNS e ³±±
    ±±³              ³        ³      |E4_SOMSUB, para poder definir a regra de ³±±
    ±±³              ³        ³      |geração (se E4_SOMSUB = 2, deverá        ³±±
    ±±³              ³        ³      ³subtrair do valor da(s) parcelas ate     ³±±
    ±±³              ³        ³      |finalizar o valor de retenção do IVA).   ³±±
    ±±³Ivan Haponczuk³15.07.10³      ³Adicionado tratamento para localizacao   ³±±
    ±±³              ³        ³      |fiscal Venezuela, ajusta parcelas de     ³±±
    ±±³              ³        ³      |acordo com a natureza.                   ³±±
    ±±³Felipe Seolin ³28.07.10³      ³Adicionado tratamento para localizacao   ³±±
    ±±³              ³        ³      |fiscal Venezuela, pesquisa natureza com  ³±±
    ±±³              ³        ³      |pedido para entrada.                     ³±±
    ±±³Felipe Seolin ³06.08.10³      ³Adicionado tratamento para localizacao   ³±±
    ±±³              ³        ³      |fiscal Venezuela, ajusta valor retencao  ³±±
    ±±³Felipe Seolin ³09.08.10³      ³Ajuste no tratamento para localizacao    ³±±
    ±±³              ³        ³      |fiscal Venezuela, ajusta parcelas de     ³±±
    ±±³              ³        ³      |acordo com a natureza.                   ³±±
    ±±³Ivan Haponczuk³08.04.11³      ³Ajuste no tratamento para localizacao    ³±±
    ±±³              ³        ³      |fiscal Republica dominicana, ajusta      ³±±
    ±±³              ³        ³      |parcelas de acordo com a natureza.       ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
					/*/
FUNCTION AvalCond(nValTot,cCond,nValIpi,dData0,nValSolid,aImpVar,aE4,nAcrescimo,aDados,nInicio3,aDias3)

    Local cAlias := Alias()
    Local nRegSE4:=SE4->(Recno())
    Local lPorcent
    Local aArr
    Local aElem
    Local cString
    Local dProx
    Local nWeek
    Local nDIfDay
    Local i
    Local j
    Local x      := 0
    Local nC     := 0
    Local bData
    Local bValor
    Local aVenc  := { }
    Local nDup   := 0
    Local nValor := 0
    Local nReg   := 0
    Local cChave := ""
    Local cChave1:= ""
    Local nParcelas
    Local cParcela
    Local nValPed
    Local nDias
    Local n
    Local nValor9    := 0
    Local nX         := 0
    Local lVista     := .f.
    Local lEntrada   := .f.
    Local lCndTipo3  := SuperGetMv("MV_CNDTP3",.F.,.F.)
    Local nDIf:=0
    Local aTipo3     := {}
    Local nAux3
    Local lIPI       := (GetMV("MV_IPITP9") == "S")
    Local lDiaCont   := (SuperGetMv("MV_DIACONT",.F.,"1") == "1") //Considera o dia atual no calculo
    Local lPVista    := .F.
    Local aTP8       := {}
    Local aCondEsp3  := {}
    Local nValTp8    := 0
    Local cCalcImpV  := GetMV("MV_GERIMPV")
    Local cE4_CODIGO := aDados[1] //SE4->E4_CODIGO
    Local cE4_COND	 := aDados[2] //SE4->E4_COND
    Local cE4_TIPO	 := aDados[3] //SE4->E4_TIPO
    Local cE4_DDD	 := aDados[4] //SE4->E4_DDD
    Local cE4_IPI	 := aDados[5] //SE4->E4_IPI
    Local cE4_SOLID	 := aDados[6] //SE4->E4_SOLID
    Local cE4_ACRES  := IIf(SE4->(FieldPos("E4_ACRES"))<>0,SE4->E4_ACRES,"N")
    Local nMaxTipo9  := 26
    Local cMv1Dup    := ""
    Local aVencTlp   := {}
    Local nDecE1Vlr  := TamSX3( "E1_VALOR"  )[2]
    Local nVlrParc   := 0
    Local nVlrAcum1  := 0
    Local nLoop      := 0
    Local nValDup    := nValTot
    Local nSomaTp9   := 0
    Local nAuxC
    Local aTipoC     := {}
    LOCAL nDia       := 0
    LOCAL nMes       := 0
    LOCAL nAno       := 0
    LOCAL dVenc      := CTOD('  /  /  ')
    LOCAL nContA     := 0
    LOCAL nContB     := 0
    LOCAL nDtVenc
    Local dDiaAnt	 := CTOD('  /  /  ')	// Armazena o dia que foi utilizado anteriormente
    Local nDiaValid	 := 0					// Guarda o ultimo dia valido do mes
    Local nlRetIVA	:= 0
    Local nlRIVA	:= 0
    Local clTpCF	 := ""
    Local llAgRet	 := .F.
    Local nlVlrIVA	:= 0
    Local nlBaseIVA	:= 0
    Local nlAlqIVA	:= 0
    Local cAux
    Local clAgen	:= GetMV("MV_AGENTE")
    Local clNaturez := ""
    local ccdnat    := ""
    Local cImpRet	 := ""
    Local nValImp    := 0
    Local nValRetImp := 0
    Local nlRImp	 := 0
    Local nTotRet	 := 0
    Local nlPosImp	 := 0
    Local nlValAux	 := 0
    Local lXFis:=(MaFisFound() .And. ProcName(1)<>"EXECBLOCK")
    Local clCodTes   := ""
    Local clPedido   := ""
    DEFAULT nAcrescimo := 0
    DEFAULT aDias3     := {}

    If cPaisLoc == 'COL'
        If !lXFis
            clCodTes := SF4->F4_CODIGO
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") + SF4->F4_CODIGO + "RV0") //Retenção IVA
                cImpRet		:= SFC->FC_IMPOSTO
                nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RV0"})
                If nlPosImp	> 0
                    nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                EndIf

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                EndIf

            Elseif dbSeek(xFilial("SFC") + SF4->F4_CODIGO +  "RF0" )//Retenção TIMBRE
                cImpRet		:= SFC->FC_IMPOSTO
                nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RF0"})
                If nlPosImp	> 0
                    nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                EndIf

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_RETFUEN == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),3,1) == 'S',.T.,.F.)
                EndIf

            Elseif dbSeek(xFilial("SFC") + SF4->F4_CODIGO +  "RC0" )//Retenção ICA
                cImpRet		:= SFC->FC_IMPOSTO
                nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RC0"})
                If nlPosImp	> 0
                    nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                EndIf

                If cModulo $ "FAT"
                    clTpCF	:= Iif(SA1->A1_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SA1->A1_RETICA == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= Iif(SA2->A2_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),2,1) == 'S',.T.,.F.)
                EndIf
            EndIf

        Else
            clCodTes := MaFisRet(N,"IT_TES")
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") + MaFisRet(N,"IT_TES") + "RV0") //Retenção IVA
                cImpRet		:= SFC->FC_IMPOSTO
                nValRetImp 	:= Round(MaFisRet(,"NF_VALIV2"),2)

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                EndIf

            Elseif dbSeek(xFilial("SFC") + MaFisRet(N,"IT_TES") +  "RF0" )//Retenção TIMBRE
                cImpRet		:= SFC->FC_IMPOSTO
                nValRetImp 	:= Round(MaFisRet(,"NF_VALIV4"),2)

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_RETFUEN == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),3,1) == 'S',.T.,.F.)
                EndIf

            Elseif dbSeek(xFilial("SFC") + MaFisRet(N,"IT_TES") +  "RC0" )//Retenção ICA
                cImpRet		:= SFC->FC_IMPOSTO
                nValRetImp 	:= Round(MaFisRet(,"NF_VALIV7"),2)

                If cModulo $ "FAT"
                    clTpCF	:= Iif(SA1->A1_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SA1->A1_RETICA == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= Iif(SA2->A2_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),2,1) == 'S',.T.,.F.)
                EndIf
            EndIf
        Endif
    EndIf

    If cPaisLoc == 'EQU'
        If !lXFis
            clCodTes := SF4->F4_CODIGO
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") + SF4->F4_CODIGO + "RV") //Retenção IVA
                cAux:=Substr(FC_IMPOSTO,1,2)
                While FC_FILIAL==xFilial("SFC") .And. FC_TES==SF4->F4_CODIGO .And. cAux=="RV"
                    cImpRet		:= SFC->FC_IMPOSTO
                    nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == SFC->FC_IMPOSTO})
                    If nlPosImp	> 0
                        nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                    EndIf
                    DbSkip()
                    cAux:=Substr(FC_IMPOSTO,1,2)
                Enddo
                If cModulo $ "FAT"
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                EndIf
                If cModulo $ "FAT"
                    clTpCF := SA1->A1_AGENRET
                ElseIf cModulo $ "COM"
                    clTpCF := iif (SubStr(clAgen,1,1)=="S","1","0")
                EndIf


            EndIf

        Else
            clCodTes := MaFisRet(N,"IT_TES")
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") +  clCodTes + "RV") //Retenção IVA
                cAux:=Substr(FC_IMPOSTO,1,2)
                While FC_FILIAL==xFilial("SFC") .And. FC_TES==clCodTes .And. cAux=="RV"
                    cImpRet		:= SFC->FC_IMPOSTO
                    nValRetImp 	:= Round(MaFisRet(,"NF_VALIV"+SFB->FB_CPOLVRO),2)
                    DbSkip()
                    cAux:=Substr(FC_IMPOSTO,1,2)
                Enddo
                If cModulo $ "FAT"
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                EndIf
                If cModulo $ "FAT"
                    clTpCF := SA1->A1_AGENRET
                ElseIf cModulo $ "COM"
                    clTpCF := iif (SubStr(clAgen,1,1)=="S","1","0")
                EndIf
            EndIf
        Endif
    EndIf

    If cPaisLoc == "DOM"
        dbSelectArea("SFC")
        SFC->(dbSetOrder(2))
        If SFC->(dbSeek(xFilial("SFC")+SF4->F4_CODIGO))
            Do While SFC->FC_FILIAL == xFilial("SFC") .and. SFC->FC_TES == SF4->F4_CODIGO .and. SFC->(!EOF())
                If SFC->FC_INCDUPL <> "3"
                    If !lXFis
                        nlPosImp := aScan(aImpVar,{|x| Alltrim(x[1]) == SFC->FC_IMPOSTO})
                        If nlPosImp	> 0
                            nValImp += Round(aImpVar[nlPosImp,2],2)
                        EndIf
                    Else
                        dbSelectArea("SFB")
                        SFB->(dbSetOrder(1))
                        If SFB->(dbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
                            nValImp += Round(MaFisRet(,"NF_VALIV"+SFB->FB_CPOLVRO),2)
                        EndIf
                    EndIf
                EndIf
                SFC->(dbSkip())
            EndDo
        EndIf
    EndIf

    If aE4 <> NIL
        cE4_CODIGO 	:= aE4[1]
        cE4_COND		:= aE4[2]
        cE4_TIPO		:= aE4[3]
        cE4_DDD 		:= aE4[4]
        cE4_IPI		:= aE4[5]
        cE4_SOLID	:= aE4[6]
        If Len(aE4) >= 7
            cE4_ACRES    := aE4[7]
        EndIf
    Endif
    If dData0 == NIL
        dData0 := dDataBase
    EndIf

    If aImpVar == NIL
        aImpVar := {}
    EndIf

    nValSolid := Iif(nValSolid == Nil,0,nValSolid)
    aElem:=aArr:={ }
    nValIpi:=Iif(nValIpi==NIL,0,nValIpi)

    DbSelectArea("SE4")
    dbSetOrder(1)
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Somente dar o seek se o registro corrente for != do desejado. 	  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If (cE4_CODIGO != cCond .Or. Empty(cE4_CODIGO)) .and. aE4 == NIL
        DbSeek(cFilial+cCond)
        If !Found() .Or. (cCond == "CN" .and. lLoja)
            nDup := 1
            dProx := dData0
            AADD(aVenc,{ dProx , nValTot })
            DbGoTo(nRegSE4)
            Return(aVenc)
        EndIf


        cE4_CODIGO 	:= SE4->E4_CODIGO
        cE4_COND		:= SE4->E4_COND
        cE4_TIPO		:= SE4->E4_TIPO
        cE4_DDD 		:= SE4->E4_DDD
        cE4_IPI		:= SE4->E4_IPI
        cE4_SOLID	:= SE4->E4_SOLID
        cE4_ACRES   := IIf(SE4->(FieldPos("E4_ACRES"))<>0,SE4->E4_ACRES,"N")
    EndIf

    cString:=cE4_COND

    While Len(cString) > 0
        AADD(aElem,Parse(@cString))
    End

    aArr := aClone( aElem )

    FOR i:=1 TO Len(aArr)
        aArr[i]:=Val(aArr[i])
        If aArr[i] == 0
            lPVista := .T.
        EndIf
    Next

    If cE4_TIPO == "3" .And. Len(aDias3) > 0

        Aadd(aCondEsp3,aArr[1])
        Aadd(aCondEsp3,If(Type("nInicio3") == "U",aArr[2],nInicio3))
        For nX := 1 to Len(aDias3)
            Aadd(aCondEsp3,aDias3[nX])
        Next
        aArr := aCondEsp3

    Endif
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Tratamento para o campo E4_DDD												  ³
    //³	  D = Data do dia 															  ³
    //³	  L = Fora o dia																  ³
    //³	  S = Fora a semana															  ³
    //³	  Z = Fora a dezena															  ³
    //³	  Q = Fora a quinzena														  ³
    //³	  F = Fora o mes																  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If cE4_TIPO <> "9" .And.;
            cE4_TIPO <> "7"
        If cE4_DDD $ "D "
            dProx := dData0
        ElseIf cE4_DDD == "L"
            dProx   := dData0 + 1
        ElseIf cE4_DDD == "S"
            nDias   := Dow(dData0)
            If nDias == 7						  // Sabado
                dProx := dData0 + 1
            ElseIf nDias == 6 				  // Sexta
                dProx := dData0 + 2
            ElseIf nDias == 5 				  // Quinta
                dProx := dData0 + 3
            ElseIf nDias == 4 				  // Quarta
                dProx := dData0 + 4
            ElseIf nDias == 3 				  // Terca
                dProx := dData0 + 5
            ElseIf nDias == 2 				  // Segunda
                dProx := dData0 + 6
            ElseIf nDias == 1 				  // Domingo
                dProx := dData0 + 7
            EndIf
        ElseIf cE4_DDD == "Z"
            nDia := day(dData0)
            nMes := month(dData0)
            nAno := year(dData0)
            If nDia >= 01 .And. nDia <= 10
                nDia := 11
            ElseIf nDia >= 11 .And. nDia <= 20
                nDia := 21
            Else
                nDia := 01
                nMes := nMes + 1
            EndIf

            If nMes == 13
                nMes := 01
                nAno := nAno + 1
            EndIf
            nDia	  := strzero(nDia,2)
            nMes	  := strzero(nMes,2)
            nAno	  := substr(lTrim(str(nAno)),3,2)
            dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
        ElseIf cE4_DDD == "Q"
            nMes := month(dData0)
            nAno := year (dData0)
            If day(dData0) > 15
                nDia := 01
                nMes		:= nMes + 1
            Else
                nDia := 16
            EndIf
            If nMes == 13
                nMes		:= 01
                nAno := nAno + 1
            EndIf
            nDia	  := strzero(nDia,2)
            nMes	  := strzero(nMes,2)
            nAno	  := substr(lTrim(str(nAno)),3,2)
            dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
        ElseIf cE4_DDD == "F"
            nDia := 01
            nMes := month(dData0) + 1
            nAno := year (dData0)
            If nMes == 13
                nMes		:= 01
                nAno := nAno + 1
            EndIf
            nDia	  := strzero(nDia,2)
            nMes	  := strzero(nMes,2)
            nAno	  := substr(lTrim(str(nAno)),3,2)
            dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
        EndIf
    Else
        dProx := dData0
    EndIf

    If cE4_TIPO == "1"
        For i:= 1 TO Len(aArr)
            If lDiaCont
                If ( aArr[1] > 0 )
                    aArr[i] -= 1
                EndIf
            Endif
            AADD(aVenc,{ dProx + aArr[i], 0 })
        Next i
    ElseIf cE4_TIPO == "2"
        For i:= 1 TO Val(Subs(cCond,2,1))
            If i == 1
                dProx += (Val(cE4_COND) * Val(Subs(cCond,1,1)))
            Else
                dProx += (Val(cE4_COND) * Val(Subs(cCond,3,1)))
            EndIf
            AADD(aVenc,{ dProx , 0 })
        Next i
    ElseIf cE4_TIPO == "3"

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Dados do Array - aArr								³
        //³	[1] - Numero de duplicatas a gerar					³
        //³	[2] - Intervalo entre as duplicatas 				³
        //³	[3]...[n] - Dias possiveis de vencimento no mes     ³
        //³		Obs. : Se o primeiro vencto for 00, a primeira  ³
        //³				 duplicata sera a vista, caso haja 00 nos³
        //³				 nos outros venctos sera desconsiderado. ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

        nDtVenc := aArr[3]

        If aArr[3] == 00				// Primeira parcela a vista
            If lCndTipo3 .And. Len(aDias3) == 0
                aArr[3] := Day(dProx)
                nAux3    := 3
            Else
                nAux3 := 4
                lVista:= .T.
            Endif
        Else
            nAux3 := 3
        EndIf

        For n:=nAux3 To Len(aArr)	// Elimino a parcela 00 e crio array dos possiveis dias vencto
            If aArr[n] != 00
                Aadd(aTipo3,aArr[n])
            EndIf
        Next n

        If Len(aTipo3) != 0
            aTipo3:= aSort(aTipo3)		//  Colocar em ordem crescente de vencimentos
            For i:=1 to aArr[1]
                If !lVista
                    If i == 1
                        dProx+= aArr[2]
                        If cE4_DDD == "L"
                            dProx--
                        Endif
                    Else
                        dDiaAnt	:= dProx
                        dProx ++
                        dProx	:= If(Day(dProx)>30,dProx+1,dProx)
                    EndIf
                    nDia:= Day(dProx)
                    nMes:= Month(dProx)
                    nAno:= Year(dProx)

                    If nDtVenc <> 00 .or. i <> 1
                        For n:= 1 to Len(aTipo3)
                            If nDia <= aTipo3[n]
                                nDia		:= aTipo3[n]
                                nDiaValid 	:= nDia
                                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                //³Caso seja seja zero o dia de vencimento, valida se a diferenca entre a nova data ³
                                //³e a antiga eh maior que 1 , isso por que no caso de vencimentos iniciado 31/01   ³
                                //³com o intervalo de 30 dias , sera da seguinte forma ( 31/01 , 02/03 , 31/03 )    ³
                                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                                    nDiaValid := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                                EndIf
                                If nDtVenc <> 0 .OR. (nDtVenc == 0 .AND.;
                                        CTOD(StrZero(nDiaValid,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy") - dDiaAnt > 1 )
                                    lEntrada:=.T.
                                EndIf
                                Exit
                            EndIf
                        Next n
                        If !lEntrada
                            nDia := aTipo3[1]
                            nMes := Iif((nMes+1) > 12,1 ,nMes+1)
                            nAno := Iif( nMes == 1, (nAno+1), nAno)
                        EndIf
                    Endif
                Else
                    lVista := .F.
                    nDia := Day(dProx)
                    nMes := Month(dProx)
                    nAno := Year(dProx)
                EndIf
                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                EndIf
                dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                AADD(aVenc, { dProx , 0 } )
                lEntrada := .F.
            Next i
        Else
            For i:=1 To aArr[1]
                nDia := Day(dProx)
                nMes := Month(dProx)
                nAno := Year(dProx)
                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                EndIf
                dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                AADD(aVenc, { dProx , 0 } )
                dProx+=aArr[2]
            Next i
        EndIf
    ElseIf cE4_TIPO == "4"
        For i:=1 To aArr[1]
            dProx   += aArr[2]
            For x:=1 to 7
                If Dow(dProx) == aArr[3]
                    Exit
                EndIf
                dProx++
            Next i
            AADD(aVenc,{ (dProx), 0 } )
        Next i
    ElseIf cE4_TIPO == "5"
        If Len(aArr) == 3
            For i:= 1 TO aArr[2] //Val(Subs(cCond,2,1))
                If i == 1
                    dProx += aArr[1]
                Else
                    dProx += aArr[3]
                EndIf
                AADD(aVenc,{ dProx , 0 })
            Next i
        Else
            AADD(aVenc,{ dData0 , 0 })
        EndIf
    ElseIf cE4_TIPO == "6"
        For i:=1 To aArr[1]
            If i==1
                dProx += aArr[2]
            Else
                dProx   += aArr[4]
            EndIf
            For x:=1 to 7
                If DOW(dProx) == aArr[3]
                    Exit
                EndIf
                dProx++
            Next x
            AADD(aVenc,{ (dProx), 0 } )
        Next i
    ElseIf cE4_TIPO == "7"
        // Descricao da Condicao de Pagamento Tipo 7
        // Cadastrar na Condicao 13 parametros separados por virgula onde o sistema
        // ira considerar o 1o parametro como o numero de parcelas e os outros 12
        // como as datas fixas de vencimento referente ao mes, ex.:
        // 10,1,2,3,4,5,6,7,8,9,10,11,12 (serao 10 parcelas com vencimento no dia
        // referente ao mes, ou seja o mes 4 vai vencer no dia 4)
        nDia := Day( dData0 )
        nMes := Month( dData0 )
        nAno := Year( dData0 )
        If cE4_DDD == "F"  //Fora o mes
            nMes ++
            nAno := If(nMes > 12, nAno+1, nAno)
            nMes := If(nMes>12,1,nMes)
        EndIf
        If cE4_DDD == "Q"  //Fora a quinzena
            If day(dData0) > 15
                nDia := 01
                nMes := nMes + 1
            Else
                nDia := 16
            EndIf
            If nMes == 13
                nMes := 01
                nAno := nAno + 1
            EndIf
        EndIf
        While Len(aVenc) < aArr[1]  //Numero de Parcelas
            If (Len( aArr ) # 13)
                aAdd( aVenc,{ dData0,0 } )
                Exit
            EndIf
            nDia := aArr[nMes+1]
            If !Empty(aArr[nMes+1])
                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                EndIf
                dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                If dProx >= dData0
                    AADD(aVenc, { dProx , 0 } )
                EndIf
            EndIf
            nMes ++
            If (nMes > 12)
                nAno++
                nMes := 1
            EndIf
        End
    ElseIf cE4_TIPO == "8"
        aTP8:=ArrayTP8(cE4_COND)
        If cE4_IPI == "J"
            nValTot -= nValIPI
        EndIf
        For i := 1 to Len(aTP8)
            AAdd(aVenc,{dProx+aTP8[i][1],Round((nValTot/100)*aTP8[i][2],2)})
            nValTp8 += Round((nValTot/100)*aTP8[i][2],2)
        Next i
        If cE4_IPI == "J"
            aVenc[1][2] += nValIPI
            nValTp8 += nValIPI
            nValTot += nValIPI
        EndIf
        If nValTp8 != nValTot
            aVenc[Len(aVenc)][2] += Round(nValTot - nValTp8,2)
        EndIf
    ElseIf cE4_TIPO == "9"
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Verifica se pode estender a tipo 9 ate 36 parcelas                     ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        cMv1Dup := GetMV( "MV_1DUP" )
        If Len( cMv1Dup ) > 1 .And. Len( cMv1Dup ) == Len( SE1->E1_PARCELA )
            nMaxTipo9 := 36
        EndIf

        cParcela  := "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0"
        nParcelas := GETMV("MV_NUMPARC")
        cChave := "C5_DATA"+Subs(cParcela,nParcelas,1)
        cChave1:= "C5_PARC"+Subs(cParcela,nParcelas,1)
        DbSelectArea("SX3")
        nReg := Recno()
        DbSetOrder(2)
        If nParcelas > nMaxTipo9
            nParcelas := nMaxTipo9
        EndIf
        If nParcelas > 4
            If !DbSeek(cChave) .or. !DbSeek(cChave1)
                nParcelas := 4
            EndIf
        Else
            nParcelas := 4
        EndIf
        DbSetOrder(1)
        If !Empty (cAlias)
            DbSelectArea(cAlias)
        Endif
        bData := { |x| "C5_DATA"+Subs(cParcela,x,1) }
        bValor:= { |x| "C5_PARC"+Subs(cParcela,x,1) }
        nValPed := 0
        // Valor Total das Parcelas
        For i:= 1 to nParcelas
            nValPed += SC5->&(EVAL(bValor,i))
        Next i

        If Trim(cE4_COND) == "0"
            // VerIfica se IPI ja esta nas parcelas
            If !lIPI ; nValtot-= nValIPI ; EndIf
            EndIf
            For i:= 1 to nParcelas
                If !Empty(SC5->&(EVAL(bData,i))) .And. !Empty(SC5->&(EVAL(bValor,i)))
                    If Trim(cE4_COND) == "%"
                        If i == 1
                            If cE4_IPI == "J"
                                nSomaTp9 := nValIPI
                                nValTot -= nValIPI
                            EndIf
                            If cE4_SOLID == "J"
                                nSomaTp9 += nValSolid
                                nValTot -= nValSolid
                            EndIf
                            If cE4_ACRES == "J"
                                nSomaTp9 += nAcrescimo
                                nValTot  -= nAcrescimo
                            EndIf
                        Else
                            nSomaTp9 := 0
                        EndIf
                        If nValPed > 100
                            nValor := nValTot * (((SC5->&(EVAL(bValor,i))/nValPed)*100) / 100 )
                        Else
                            nValor := nValTot * (SC5->&(EVAL(bValor,i)) / 100 )
                        EndIf
                        nValor += nSomaTp9
                    Else
                        // achar o % referente ao valor
                        nValor := SC5->&(EVAL(bValor,i)) / nValPed
                        nValor := nValTot * nValor
                        // os quant. presentes em C5_PARCn referem-se a valores
                        //nValor := SC5->&(EVAL(bValor,i))
                        nValor := Iif(Abs(nValor - SC5->&(EVAL(bValor,i) ) ) <= 1,SC5->&(EVAL(bValor,i)),nValor)
                    EndIf
                    AADD(aVenc,{ SC5->&(EVAL(bData,i)), nValor } )
                EndIf
            Next i
        ElseIf cE4_TIPO == "C"
            If aArr[1] <> 0				// Primeira parcela a vista
                If Len(aDias3) == 0
                    nAuxC := 1
                Else
                    nAuxC := 2
                    lVista := .T.
                Endif
            Else
                nAuxC := 1
            EndIf

            For n:=nAuxC To Len(aArr)	// Elimino a parcela 00 e crio array dos possiveis dias vencto
                If Day(dDataBase) != 00
                    Aadd(aTipoC,Day(dDataBase))
                EndIf
            Next n

            If Len(aTipoC) != 0
                aTipoC:= aSort(aTipoC)		//  Colocar em ordem crescente de vencimentos
                For i:=1 to aArr[1]
                    If !lVista
                        If i == 1
                            dProx+= 0
                        Else
                            dProx:= If(Day(dProx)>30,dProx+1,dProx)
                        EndIf
                        nDia:= Day(dProx)
                        nMes:= Month(dProx)
                        nAno:= Year(dProx)
                        If !lEntrada
                            If i <> 1
                                nDia := nDia
                                nMes := Iif((nMes+1) > 12,1 ,nMes+1)
                                nAno := Iif( nMes == 1, (nAno+1), nAno)
                                lEntrada:= .F.
                            EndIf
                        EndIf
                    Else
                        lVista := .F.
                        nDia := Day(dProx)
                        nMes := Month(dProx)
                        nAno := Year(dProx)
                    EndIf
                    If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                        nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    EndIf
                    dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                    AADD(aVenc, { dProx , 0 } )
                    lEntrada := .F.
                Next i
            Else
                For i:=1 To aArr[1]
                    nDia := Day(dProx)
                    nMes := Month(dProx)
                    nAno := Year(dProx)
                    If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                        nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    EndIf
                    dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                    AADD(aVenc, { dProx , 0 } )
                    dProx+=0
                Next i
            EndIf
        ELSEIF cE4_TIPO == 'D'
            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Os campos do E4_COND, separados por Virgulas, correspondem ³
            //³ aos Meses dos Vencimentos, a partir da Data de Emissao.    ³
            //³ Ex.: Na Emissao em 30/05/07 e E4_COND = '0,2,3,4' os Ven-  ³
            //³ cimentos serao: 30/05, 30/07, 30/08 e 30/09 de 2007.       ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            FOR nContA := 1 TO LEN(aArr)
                nDia := DAY(dProx)
                nMes := MONTH(dProx)
                nAno := YEAR(dProx)
                FOR nContB := 1 TO aArr[nContA]
                    nAno := nAno+IIF(nMes==12,1,0)
                    nMes := IIF(nMes==12,1,nMes+1)
                NEXT nContB
                IF !EMPTY(CTOD(STRZERO(nDia,2)+'/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy'))
                    dVenc := CTOD(STRZERO(nDia,2)+'/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy')
                ELSE
                    dVenc := LASTDAY(CTOD('01/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy'))+1
                ENDIF
                AADD(aVenc,{dVenc,0})
            NEXT nContA
        EndIf
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³		Desdobramento dos valores baseado no numero de duplicatas	  ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        nDup:=Len(aVenc)

        If !(cE4_TIPO $ "89")

            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //³ Desdobrar valores dos impostos variaveis baseando se campo FB_JNS ³
            //³ de cada imposto correspondente. 											 ³
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄLucasÄÙ
            If cCalcImpV == "S" .And. Len(aImpVar) > 0

                nIniLoop := 1

                For nC := 1 To Len(aImpVar)
                    SFB->( DbSetOrder(1) )
                    SFB->( DbSeek( xFilial("SFB")+AllTrim(aImpVar[nC][1])) )

                    If SFB->FB_JNS $ "JS" .And. cPaisLoc <> 'COL'
                        aVenc[1][2] := If( nC==1,aImpVar[nC][2],aVenc[1][2] + aImpVar[nC][2] )
                        nValTot -= aImpVar[nC][2]
                        nIniLoop := 2
                    EndIf
                    If cE4_ACRES $ "JS"
                        aVenc[1][2] := nAcrescimo
                        nValTot     -= nAcrescimo
                        nIniLoop    := 2
                    ElseIf cE4_ACRES $ "V" .And. lPVista
                        nValTot     -= nAcrescimo
                    EndIf

                    If !("S" $ SFB->FB_JNS + cE4_ACRES)
                        nIniLoop := 1
                    EndIf
                Next nC

                If nIniLoop == 2
                    nValor := Round( nValTot / (nDup-1) ,2 )
                Else
                    nValor := Round( nValTot / nDup ,2 )
                EndIf


                If llAgRet
                    nlRImp	:= nValRetImp
                EndIf
                For i := nIniLoop TO nDup

                    If nlRImp > 0 .And. cPaisLoc == 'COL'
                        If SFB->FB_JNS == 'J'
                            dbSelectArea("SFC")
                            dbSetOrder(2)
                            If dbSeek(xFilial("SFC") + clCodTes + cImpRet)
                                Do Case
                                Case FC_INCDUPL == '2'
                                    nValRetImp := nValor - nlRImp
                                    If nValRetImp >= 0
                                        aVenc[i][2] += Round(nValRetImp,2)
                                        nlRImp	:= 0
                                    Else
                                        aVenc[i][2] += 0
                                        nlRImp	:= Round((nValRetImp * (-1)),2)
                                    EndIf
                                Case FC_INCDUPL == '1'
                                    aVenc[i][2] += Round(nValor + nlRImp,2)
                                    nlRImp	:= 0
                                Otherwise
                                    aVenc[i][2] += Round(nValor,2)
                                    nlRImp	:= 0
                                EndCase
                            EndIf
                        EndIf
                    elseIf nlRImp > 0 .And. clTpCF == '1' .And. cPaisLoc == 'EQU'
                        dbselectarea("SED")
                        SED->(Dbsetorder(1))
                        dbSeek(xFilial("SED") + SC5->C5_NATUREZ)
                        dbSelectArea("SFC")
                        dbSetOrder(2)
                        If dbSeek(xFilial("SFC") + clCodTes + cImpRet)
                            Do Case
                            Case SED->ED_RATRET == '1'
                                nValor := Round( (nValTot + nValRetImp) / nDup ,2 )
                                nValRetImp := nValor - nlRImp
                                If nValRetImp >= 0
                                    aVenc[i][2] += Round(nValRetImp,2)
                                    nlRImp	:= 0
                                Else
                                    aVenc[i][2] += 0
                                    nlRImp	:= Round((nValRetImp * (-1)),2)
                                EndIf
                            Otherwise
                                nValor := Round( nValTot / nDup ,2 )
                                aVenc[i][2] += Round(nValor,2)
                                nlRImp	:= 0
                            EndCase
                        EndIf
                    ElseIf nValRetImp > 0 .and. clTpCF == '1' .and. cPaisLoc == 'VEN'
                        If Type("SC5->C5_NATUREZ") <> "U"
                            clNaturez := SC5->C5_NATUREZ
                        EndIf
                        DBSelectArea("SED")
                        SED->(DBSetOrder(1))
                        If DBSeek(xFilial("SED") + clNaturez)
                            Do Case
                            Case SED->ED_RATRET == '1'
                                nValor	:= Round((nValTot + nValRetImp) / nDup,2)
                                nTotRet	:= nValor - nValRetImp
                                If nTotRet >= 0
                                    aVenc[i][2]	+= Round(nTotRet,2)
                                    nValRetImp	:= 0
                                Else
                                    aVenc[i][2]	+= 0
                                    nValRetImp	:= Round((nTotRet * (-1)),2)
                                EndIf
                            OtherWise
                                nValor		:= Round(nValTot / nDup,2)
                                aVenc[i][2]	+= Round(nValor,2)
                                nValRetImp	:= 0
                            EndCase
                        Else
                            nValor	:= Round((nValTot + nValRetImp) / nDup,2)
                            nTotRet	:= nValor - nValRetImp
                            If nTotRet >= 0
                                aVenc[i][2]	+= Round(nTotRet,2)
                                nValRetImp	:= 0
                            Else
                                aVenc[i][2]	+= 0
                                nValRetImp	:= Round((nTotRet * (-1)),2)
                            EndIf
                        EndIf
                    ElseIf nValImp > 0 .and. cPaisLoc == "DOM"

                        If Type("M->C5_NATUREZ") <> "U"
                            clNaturez := M->C5_NATUREZ
                        ElseIf Type("SC5->C5_NATUREZ") <> "U"
                            clNaturez := SC5->C5_NATUREZ
                        Else
                            clNaturez := ""
                        EndIf

                        dbSelectArea("SED")
                        SED->(dbSetOrder(1))
                        If SED->(dbSeek(xFilial("SED")+clNaturez))
                            If SED->ED_RATRET == "1"
                                nValor      := Round((nValTot-nValImp)/nDup,2)
                                aVenc[i][2]	+= Round(nValor+nValImp,2)
                                nValImp := 0
                            Else
                                nValor		:= Round(nValTot / nDup,2)
                                aVenc[i][2]	+= Round(nValor,2)
                                nValImp     := 0
                            EndIf
                        Else
                            nValor		:= Round(nValTot / nDup,2)
                            aVenc[i][2]	+= Round(nValor,2)
                            nValImp     := 0
                        EndIf

                    Else
                        aVenc[i][2] += nValor
                    EndIf
                    If cE4_ACRES $ "V" .And. lPVista
                        nValor += Round( nAcrescimo / (nDup-i) ,2 )
                        lPVista  := .F.
                    EndIf
                Next i

            Else

                nIniLoop := 1

                If cE4_IPI $ "JS"
                    aVenc[1][2] := nValIPI
                    nValTot -= nValIPI
                    nIniLoop := 2
                EndIf

                If cE4_SOLID $ "JS"
                    aVenc[1][2] += nValSolid
                    nValTot -= nValSolid
                    nIniLoop := 2
                EndIf

                If cE4_ACRES $ "JS"
                    aVenc[1][2] += nAcrescimo
                    nValTot     -= nAcrescimo
                    nIniLoop    := 2
                ElseIf cE4_ACRES $ "V" .And. lPVista
                    nValTot     -= nAcrescimo
                EndIf

                If !("S" $ cE4_IPI + cE4_SOLID + cE4_ACRES)
                    nIniLoop := 1
                EndIf

                If nIniLoop == 2
                    nValor := Round( nValTot / (nDup-1) ,2 )
                Else
                    nValor := Round( nValTot / nDup ,2 )
                EndIf

                For i := nIniLoop TO nDup

                    If nValRetImp > 0 .And. cPaisLoc == 'COL'
                        If SFB->FB_JNS $ 'J/S'
                            DbSelectArea("SFC")
                            SFC->(DbSetOrder(2))
                            If DbSeek(xFilial("SFC") + clCodTes + cImpRet )
                                Do Case
                                Case FC_INCDUPL == '2'
                                    nTotRet := nValor - nValRetImp
                                    If nTotRet >= 0
                                        aVenc[i][2] += Round(nTotRet,2)
                                        nValRetImp := 0
                                    Else
                                        aVenc[i][2] += 0
                                        nValRetImp	:= Round((nTotRet * (-1)),2)
                                    Endif
                                Case FC_INCDUPL == '1'
                                    aVenc[i][2] += Round(nValor + nValRetImp,2)
                                OtherWise
                                    aVenc[i][2] += Round(nValor,2)
                                    nValRetImp := 0
                                EndCase
                            Endif
                        Endif
                    elseIf nValRetImp > 0 .And. clTpCF == '1' .And. cPaisLoc == 'EQU'
                        IF SC7->C7_NATUREZ <> " "
                            dbselectarea("SED")
                            SED->(Dbsetorder(1))
                            dbSeek(xFilial("SED") + SC7->C7_NATUREZ)
                        EndIf
                        DbSelectArea("SFC")
                        SFC->(DbSetOrder(2))
                        If DbSeek(xFilial("SFC") + clCodTes + cImpRet )
                            Do Case
                            Case SED->ED_RATRET == '1'
                                nValor := Round( (nValTot + nValRetImp) / nDup ,2 )
                                nTotRet := nValor - nValRetImp
                                If nTotRet >= 0
                                    aVenc[i][2] += Round(nTotRet,2)
                                    nValRetImp := 0
                                Else
                                    aVenc[i][2] += 0
                                    nValRetImp	:= Round((nTotRet * (-1)),2)
                                Endif
                            OtherWise
                                nValor := Round( nValTot / nDup ,2 )
                                aVenc[i][2] += Round(nValor,2)
                                nValRetImp := 0
                            EndCase
                        Endif
                    ElseIf nValImp > 0 .and. cPaisLoc == "DOM"

                        If Type("SC7->C7_NATUREZ") <> "U"
                            clPedido := aCols[1][17]
                            If AllTrim(clPedido) <> ""
                                DBSelectArea("SC7")
                                DBSetOrder(1)
                                If DBSeek(xFilial("SC7") + clPedido)
                                    clNaturez := SC7->C7_NATUREZ
                                EndIf
                            EndIf
                        EndIf

                        If Type("M->C5_NATUREZ") <> "U"
                            clNaturez := M->C5_NATUREZ
                        ElseIf Type("M->F1_NATUREZ") <> "U"
                            clNaturez := M->F1_NATUREZ
                        ElseIf Type("M->F2_NATUREZ") <> "U"
                            clNaturez := M->F2_NATUREZ
                        EndIf

                        dbSelectArea("SED")
                        SED->(dbSetOrder(1))
                        If SED->(dbSeek(xFilial("SED")+clNaturez))
                            If SED->ED_RATRET == "1"
                                nValor      := Round((nValTot-nValImp)/nDup,2)
                                aVenc[i][2]	+= Round(nValor+nValImp,2)
                                nValImp := 0
                            Else
                                nValor		:= Round(nValTot / nDup,2)
                                aVenc[i][2]	+= Round(nValor,2)
                                nValImp     := 0
                            EndIf
                        Else
                            nValor		:= Round(nValTot / nDup,2)
                            aVenc[i][2]	+= Round(nValor,2)
                            nValImp     := 0
                        EndIf

                    Else
                        aVenc[i][2] += nValor
                    EndIf
                    If cE4_ACRES $ "V" .And. lPVista
                        nValor += Round( nAcrescimo / (nDup-i) ,2 )
                        lPVista  := .F.
                    EndIf
                Next i
            EndIf
        Else
            If Trim(cE4_COND) == "0"  .and.  nValPed < nValTot
                If Len(aVenc) > 0
                    nDup:=Len(aVenc)
                    nDIf := nValTot - nValPed
                    If NoRound(nDIf,4) > 0
                        aVenc[nDup][2] += nDIf
                    EndIf
                    nDIf := nValIpi / nDup
                    If !lIPI
                        For i:=1 To nDup
                            aVenc[i][2] += nDIf
                        Next
                    EndIf
                EndIf
            ElseIf Trim(cE4_COND) == "0"  .and.  nValPed >= nValTot
                If Len(aVenc) > 0
                    nDup:=Len(aVenc)
                    aVenc[nDup][2] -= nValIpi
                    nDIf := nValIPI / nDup
                    If nValIPI == 0
                        aVenc[nDup][2] += nDIf
                    Else
                        If !lIPI
                            For i:=1 To nDup
                                aVenc[i][2] += nDIf
                            Next
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Trata diferenca de centavo nas parcelas              ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        For nLoop := 1 to Len(aVenc)
            nVlrParc := NoRound( aVenc[nLoop][2], nDecE1Vlr )
            nVlrAcum1 += nVlrParc

            If ( Len(aVenc)==nLoop .And. nValDup <> 0) .And. !cPaisLoc$"COL|VEN"
                nVlrParc += nValDup - nVlrAcum1
            EndIf
            // reatribui com o novo valor da parcela
            aVenc[nLoop][2] := nVlrParc

        Next nLoop
        //
        // Template de GEM - Gestao de Empreendimentos Imobiliarios
        //
        If ExistTemplate("GMCondicao")
            aVencTlp := ExecTemplate("GMCondicao",.F.,.F.,{cE4_CODIGO,dData0,nValDup,.F.})
            If !Empty(aVencTlp)
                aVenc := aClone(aVencTlp)
            EndIf
        EndIf

        SE4->(DbGoTo(nRegSE4))

        Return(aVenc)

						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
						±±ºFuncao    ³D3Valido  ºAutor  ³Fernando J. Siquini º Data ³ 18/10/2004  º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºDesc.     ³ Avalia se o registro posicionado no SD3 eh valido.         º±±
						±±º          ³ !!!Atencao!!! Deve-se posicionar no SD3 a ser testado      º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºParametros³ Void                                                       º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºRetorno   ³ .T. se o registro for valido, .F. se o registro nao for    º±±
						±±º          ³ valido.                                                    º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºUso       ³ Advanced Protheus                                          º±±
						±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function D3Valido(cAlias)

						Static lEstornado := Nil
						Static lD3Servico := Nil
						Static lD3Valido  := Nil

						Local lRet       := .T.
						Local lRetPE     := .T.

						Default cAlias     := 'SD3'

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se considera registros estornados no SD3            ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lEstornado := If(lEstornado==NIL, GetMV('MV_D3ESTOR', .F., 'N')=='S', lEstornado)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se considera registros com Servico de WMS no SD3    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lD3Servico := If(lD3Servico==NIL, GetMV('MV_D3SERVI', .F., 'N')=='S', lD3Servico)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se o ponto de Entrada D3Valido existe               ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lD3Valido := If(lD3Valido==NIL, ExistBlock('D3VALIDO'), lD3Valido)

    If lD3Valido
							lRetPE := ExecBlock('D3VALIDO', .F., .F., cAlias)
							lRet   := If(ValType(lRetPE)=='L', lRetPE, lRet)
    EndIf

    Do While lRet
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Nao considera Registros Estornados                           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If !lEstornado .And. !Empty((cAlias)->D3_ESTORNO)
								lRet := .F.
								Exit
        EndIf

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Nao considera Registros referentes a servicos de WMS Nao Executados ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If !lD3Servico .And. !Empty((cAlias)->D3_SERVIC) .And. IntDL((cAlias)->D3_COD)
            If (cAlias)->D3_TM > '500' .And. !((cAlias)->D3_LOCAL==SuperGetMV('MV_CQ', .F., '98')) //-- Saidas nao serao consideradas (quando o servico for executado ira gerar outro registro no SD3)
									lRet := .F.
									Exit
            EndIf
        EndIf

							Exit
    EndDo

						Return lRet


						/*/
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
						±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
						±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
						±±³          ³a stored procedure a variavel sera incrementada.            ³±±
						±±³          ³Procedure MAT006                                            ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
						±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						/*/
    #IFDEF TOP

Static Function VerIDProc()
							Return '010'

#ENDIF
						/*/
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
						±±³Funcao    ³VerIDProc2³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
						±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
						±±³          ³a stored procedure a variavel sera incrementada.            ³±±
						±±³          ³Procedure FIN001                                            ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
						±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						/*/
#IFDEF TOP

Static Function VerIDProc2()
							Return '010'

#ENDIF

						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
						±±³Fun‡…o    ³ MATXFUNB_V ³ Autor ³ Microsiga S/A       ³ Data ³ 12/12/09 ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Descri‡…o ³ Funcao utilizada para verificar a ultima versao do fonte   ³±±
						±±³			 ³ matxfunb aplicado no rpo do cliente, verificando assim a   ³±±
						±±³			 ³ necessidade de uma atualizacao neste fonte.		    	  ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³ Uso      ³ EST/PCP/FAT/COM	                                          ³±±
						±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						*/
Function MATXFUNB_V
    Local nRet := 20091212 // 12 de Dezembro de 2009
Return nRet


						/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funcao    ³NGSD3TQN³ Autor ³ Marcos Wagner Junior  ³ Data ³05.1.2010   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descri‡…o ³Faz a consistencia da delecao do abastecimento (tqn)        ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ MNT         	                                          ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						/*/
Function NGSD3TQN()
    Local lRet := .t.
    Local aOldArea := GetArea()

    If nModulo != 19
        DbSelectArea("SX6")
        DbSetorder(1)
        If GetNewPar("MV_NGMNTFR","N") = "S"
            nOrdId := NGRETORDEM("TQN","TQN_FILIAL+TQN_NUMSEQ")
            If nOrdId > 0
                DbSelectArea("TQN")
                DbSetorder(nOrdId)

                If DbSeek(xFilial("TQN")+SD3->D3_NUMSEQ)
                    // PROCESSO COPIADO DO MNTA655
                    //Verifica Historico de Contador de Bomba
                    If lRet .AND. !MNT655LOTE() //Se foi pelo Abastecimento em Lote nao podera alterar
                        ApMsgInfo(STR0092) //"Para realizar o estorno utilize a rotina de Abastecimento em Lote do módulo de Manutenção de Ativos."
                        lRet := .f.
                    Endif

                    If lRet .AND. !MNTA655OK(STR0093) //"Excluído"
                        lRet := .f.
                    Endif

                    If lRet .AND. NGVDHBomba(TQN->TQN_POSTO,TQN->TQN_LOJA,TQN->TQN_TANQUE,TQN->TQN_BOMBA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,"'2'") .Or. ;
                            NGVDHBomba(TQN->TQN_POSTO,TQN->TQN_LOJA,TQN->TQN_TANQUE,TQN->TQN_BOMBA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,,"'3'")
                        ShowHelpDlg(STR0001,{STR0094},3,; //"Atençäo"###"Estorno não permitido pois já existe Aferição de Bomba com data/hora superior a este abastecimento."
                        {STR0095},3) //"Exclua as Aferições cadastradas com data/hora superior a este abastecimento pelo módulo de Manutenção de Ativos."
                        lRet := .F.
                    EndIf

                    If lRet .AND. !Empty(TQN->TQN_DTCON)
                        If !MsgYesNo(STR0096) //"Abastecimento relacionado já foi conciliado! Deseja continuar?"
                            lRet := .f.
                        Endif
                    Endif

                Endif
            Endif
        Endif
    Endif

    RestArea(aOldArea)

Return lRet

						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
						±±³Fun‡…o    ³UsaFilTrf  ³ Autor ³ Emerson Rony Oliveira ³ Data ³ 13/04/11 ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Descricao ³ Analisa parametro MV_FILTRF, que define se serao utilizados ³±±
						±±³ 		 | os novos campos "A1_FILTRF" e "A2_FILTRF" no processo de    ³±±
						±±³ 		 | transferencia entre filiais. A ausencia do parametro ou     ³±±
						±±³ 		 | conteudo .F. indica o uso padrao da rotina, ou seja, sera   ³±±
						±±³ 		 | utilizado o CNPJ para identificar o cliente/fornecedor      ³±±
						±±³ 		 | durante o processo de transferencia entre filiais. Se o     ³±±
						±±³ 		 | conteudo for .T. entao serao usados os novos campos das     ³±±
						±±³ 		 | tabelas SA1 e SA2. (UPDEST39)                               ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Retorno   ³ Logico (default .F.)                                        ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Uso       ³ MATA310, MATA103, MATA410, MATR715                          ³±±
						±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						*/
Function UsaFilTrf()
    Local lRet := GetMV("MV_FILTRF",.F.,.F.) // .F. == indica funcionamento padrao da rotina -- atraves do CNPJ do cliente/fornecedor

    If lRet
        If !(SA1->(FieldPos("A1_FILTRF")) > 0 .And. SA2->(FieldPos("A2_FILTRF")) > 0)
            lRet := .F. // os campos devem existir na base
        EndIF
    EndIf

Return lRet

						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
						±±³Fun‡…o    ³MtValidFil ³ Autor ³ Emerson Rony Oliveira ³ Data ³ 13/04/11 ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Descricao ³ Verifica a existência da filial enviada como parametro.     ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Retorno   ³ Logico (default .F.)                                        ³±±
						±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
						±±³Uso       ³ MATA020, MATA030                                            ³±±
						±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						*/
Function MtValidFil(cChave)
    Local aArea := GetArea()
    Local lRet  := .T.

    dbSelectArea("SM0")
    dbSetOrder(1)
    If !MsSeek(cChave)	// Tenta localizar a Empresa+Filial enviadas no parametro cChave
        Help(" ",1,"SAVALFIL")
        lRet := .F.
    EndIf

    MsSeek(cEmpAnt+cFilAnt)
    RestArea(aArea)

Return lRet


						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
						±±ºPrograma  ³ NGSD1GESTL ºAutor  ³Marcos Wagner Jr. º Data ³  30/03/11   º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºDesc.     ³ Geracao do insumo (STL) atraves de inclusao de SC1         º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºUso       ³ MATXFUNB                                                   º±±
						±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						*/
Function NGSD1GESTL(_CORDEM,_CCODIGO)
    Local lTermino  := .f.
    Local lTercProd := .f.
    Local aTercProd := {}
    Local cDestino  := "", cCodigo := "", cTipoReg := ""
    Private lTEMSEQR  := NgVerify("STL")
    Private dDtMDO    := Ctod("  /  /  "),cHoMDO := Space(5)

    //Recebe os Produtos de Terceiros do parametro
    If FindFunction("NGProdMNT")
        aTercProd := aClone(NGProdMNT("T"))
        lTercProd := ( aScan(aTercProd, {|x| AllTrim(x) == AllTrim(_CCODIGO) }) > 0)
    Else
        lTercProd := ( AllTrim(GetMV("MV_PRODTER")) == AllTrim(_CCODIGO) )
    EndIf
    cTipoReg := If(lTercProd, "T", "P")
    nSEQSTL := ULTSEQ1()
    If cTipoReg == "T"
        cCodigo  := SD1->D1_FORNECE
    Else
        cCodigo  := SD1->D1_COD
        cDestino := "A"
    EndIf

    If cTIPOREG = "P"
        If NGIFFILSEEK("STL",xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
            While !Eof() .And. STL->TL_FILIAL = Xfilial("STL") .And.;
                    STL->TL_ORDEM = _CORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO
                If Alltrim(STL->TL_SEQRELA) <> "0" .And. STL->TL_TIPOREG = "M"
                    dDtMDO := STL->TL_DTINICI
                    cHoMDO := STL->TL_HOINICI
                    Exit
                Endif
                Dbskip()
            End
        Endif
    Endif

    dbSelectArea("STJ")
    dbSetorder(1)
    If dbSeek(xFilial("STJ")+_CORDEM)
        lTermino := If(STJ->TJ_TERMINO == "S",.T.,.F.)
    Endif

    dbSelectArea("STL")
    dbSetorder(1)  // ORDEM DE NUMSEQ
    Reclock("STL",.T.)
    STL->TL_FILIAL  := xfilial('STL')
    STL->TL_ORDEM   := _CORDEM
    STL->TL_PLANO   := STJ->TJ_PLANO
    STL->TL_CODIGO  := cCodigo
    STL->TL_TIPOREG := cTipoReg
    STL->TL_TAREFA  := '0'
    STL->TL_USACALE := 'N'
    STL->TL_GARANTI := 'N'
    If lTEMSEQR
        STL->TL_SEQRELA := nSEQSTL
    Else
        STL->TL_SEQUENC := nSEQSTL
    Endif
    STL->TL_UNIDADE := If(cTIPOREG = "T","H",SD1->D1_UM)
    STL->TL_QUANTID := SD1->D1_QUANT
    STL->TL_NUMSEQ  := SD1->D1_NUMSEQ
    STL->TL_DTINICI := If(lTermino,STJ->TJ_DTMRFIM,SD1->D1_DTDIGIT)
    STL->TL_HOINICI := If(lTermino,STJ->TJ_HOMRFIM,'08:00')
    If cTIPOREG = "T"
        vVDATFIM := NGDTHORFIM(SD1->D1_DTDIGIT,'08:00',SD1->D1_QUANT)
        STL->TL_DTFIM := If(lTermino,STJ->TJ_DTMRFIM,vVDATFIM[1])
        STL->TL_HOFIM := If(lTermino,STJ->TJ_HOMRFIM,vVDATFIM[2])
    Else
        STL->TL_DTFIM := If(lTermino,STJ->TJ_DTMRFIM,SD1->D1_DTDIGIT)
        STL->TL_HOFIM := If(lTermino,STJ->TJ_HOMRFIM,'08:00')
    EndIf
    STL->TL_DESTINO := cDestino
    STL->TL_REPFIM  := 'S'
    STL->TL_CUSTO   := SD1->D1_CUSTO
    STL->TL_NUMOP   := Substr(SD1->D1_OP,1,6)
    STL->TL_ITEMOP  := Substr(SD1->D1_OP,7,2)
    STL->TL_SEQUEOP := Substr(SD1->D1_OP,9,3)
    STL->TL_TIPOHOR := ALLTrim(GETMV("MV_NGUNIDT"))

    If cTIPOREG = "P" .And. !Empty(dDtMDO) .And. !Empty(cHoMDO)
        STL->TL_DTINICI := dDtMDO
        STL->TL_HOINICI := cHoMDO
        STL->TL_DTFIM   := dDtMDO
        STL->TL_HOFIM   := cHoMDO
    Endif

    If FieldPos("TL_ORIGNFE") > 0
        STL->TL_ORIGNFE := 'SD1'
    Endif

    If FieldPos("TL_FORNEC") > 0
        STL->TL_FORNEC := SD1->D1_FORNECE
    Endif

    If FieldPos("TL_LOJA") > 0
        STL->TL_LOJA := SD1->D1_LOJA
    Endif

    If FieldPos("TL_NOTFIS") > 0
        STL->TL_NOTFIS := SD1->D1_DOC
    Endif

    If FieldPos("TL_SERIE") > 0
        STL->TL_SERIE := SD1->D1_SERIE
    Endif

    If lTermino
        STL->TL_OBSERVA := STR0103+DtoC(STL->TL_DTFIM)+"."+Chr(13)+; //"Insumo lançado após a finalização da O.S. em: "
        STR0104+DtoC(SD1->D1_DTDIGIT)+"." //"Data de lançamento: "
    EndIf

    MSUNLOCK("STL")

Return .t.

						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
						±±ºPrograma  ³Ctb_IsCache ºAutor  ³Microsiga         º Data ³  12/06/10   º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºDesc.     ³                                                            º±±
						±±º          ³                                                            º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºUso       ³ AP                                                         º±±
						±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						*/

Static Function Ctb_IsCache(nCache)
    If __lCacheIs == Nil
        __lCacheIs := ( GetNewPar( "MV_CTBCACH" , "1" ) == "1" )   //"0"=Nao Trabalha com Cache "1"=Trabalha com Cache
    EndIf
Return(__lCacheIs)

						/*
						ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
						±±ºPrograma  ³AtuVldEnt ºAutor  ³Microsiga           º Data ³  01/07/10   º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºDesc.     ³ Atualizacao do cache de validacao das entidades contabeis. º±±
						±±º          ³                                                            º±±
						±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
						±±ºUso       ³ AP                                                         º±±
						±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
						±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
						ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
						*/
Function AtuVldEnt(cEntid, cCodigo)
    Local nPos 		:= 0
    Local bPesq  	:= {|x| 	x[2,1] == cCodigo }
    Local lChkCache := Findfunction("Ctb_IsCache")

    If lChkCache .And. cEntid == "CT1" .And. Ctb_IsCache(1) .And. !Empty(__aCTBConta) .And. ( nPos := Ascan( __aCTBConta, bPesq) ) > 0
        __aCTBConta[nPos][2][1] := ""
    Endif

    If lChkCache .And. cEntid == "CTT" .And. Ctb_IsCache(2) .And. !Empty(__aCTBCusto) .And. ( nPos := Ascan( __aCTBCusto, bPesq) ) > 0
        __aCTBCusto[nPos][2][1] := ""
    Endif

    If lChkCache .And. cEntid == "CTD" .And. Ctb_IsCache(3) .And. !Empty(__aCTBItem) .And. ( nPos := Ascan( __aCTBItem, bPesq) ) > 0
        __aCTBItem[nPos][2][1] := ""
    Endif

    If lChkCache .And. cEntid == "CTH" .And. Ctb_IsCache(4) .And. !Empty(__aCTBClVlr) .And. ( nPos := Ascan( __aCTBClVlr, bPesq) ) > 0
        __aCTBClVlr[nPos][2][1] := ""
    Endif

Return
