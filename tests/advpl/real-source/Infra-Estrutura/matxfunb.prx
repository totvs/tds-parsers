#include "protheus.ch"
#include "matxfunb.ch"

Static aFormBatch:={}
Static __cFileLog
Static __aErrAuto	:= {}
Static __CtbFilVld		// Filial para validacao CTB
Static __aCache := {}
Static __aLayCNAB	:= {}
Static __aCTBConta 	:= {}
Static __aCTBCusto 	:= {}
Static __aCTBItem 	:= {}
Static __aCTBClVlr 	:= {}
Static __lUMSMM
Static __lNewJuros
Static __lFJURCST
Static __lFJURREC
Static __lFILEMOT
Static __lGEMJUROS
Static __lE1_NCONTR
Static __aMotRead
Static __lFJURREC
Static __lProcFIN001
Static __lCacheIs

/*


Ŀ
 DATA    BOPS Prograd.ALTERACAO							  		  
Ĵ
16.12.98XXXXXXAndreia Inclusao da Funcao TEMBXCANC()				  
04.01.99XXXXXXPilar   Acerto do nome da variavel cPicture- TmContab 
06.01.9919274AAndreia Acerto na funcao FA070JUROS() quando juros	  
		  	   		   composto.									  
14.01.99xxxxxxRODRIGO Incluida funcao A207Um()					  
22/01/99META  Rodrigo Incluida funcao AvalQtdPre					  
22.01.99xxxxxAPilar   Travamento CNAB II							  
26.01.99META  Rodrigo Incluidas funcoes para OPs/SCs Firme/Prevista 
19.02.99******Julio   Transf. Funcao ConaOk() do ConxFun.prx		  
19.02.99XXXXXXFernandoIncl.funes QA_ULTRV, QA_VERNUM, QA_NUMDEC   
  	     	   		   QA_GRCOD e QA_SEQU do QAXFUN.PRW		  
20.02.99XXXXXXFernandoIncl.funo A200SKTE do QIEA200.PRW			  
20.02.99XXXXXXFernandoIncl.funo READMOTBX do FINXFUN.PRX. 		  
15.03.99xxxxxxPilar   Estava pulando linha indevida no CNAB2		  
18.03.99xxxxxxMarcelo Incluso da funo QA_CHOICE.				  
22.03.99META  Julio   Acrescentar col. Cheque na Tab. Mot.Baixa.	  
08.04.99xxxxxxVera    Exclusao das funcoes do Siga Quality		  
19.04.99PROTH.Julio   Melhoria da funo fa070juros() sem usar 	  
		  	   		   ErrorBlock(). 								  
17.07.99xxxxxxWag/KotaSubstituicao da Serial.dll					  
21.07.9922934ACesarValAlterar funao E_FIELD - SIGAEIC p/ 2.06/4.06 
28.07.99xxxxxxFabio FPAlterada funao E_FIELD						  
12.08.99xxxxxxJoly    Na MSROTAUTO nao mudar o Indice do SX3 s/ness.
25.08.99XXXXXXMauricioReposicionar alias de entrada na TEMBXCANC()  
25.08.9923454AAline CVAcerto na funcao Condicao nos Tipo 6 e Tipo 3 
17.09.99XXXXXXJulio W Acerto na chave da Funcao TemBxCanc()         
09.11.9923514AKotaki  Inclusao de um PE. para MARLOCK               
23.11.99XXXXXXFabio R VerIficar se existe o Sigaloja.???            
20.12.99XXXXXXJulio W Implementao na Leitura do CNAB II -> Le uma 
                      linha inteira (at encontrar Chr(13)+Chr(10)) 
22.12.99226744Lucas   Considerar Remitso SCM/SCN na xCalcEst().     
26.01.00XXXXXXStiefanoAcerto na xProcedure - AS400                  
03.02.00XXXXXXMauricioAcerto na TemBxCan() - Vicente                
04.02.00XXXXXXSandro  Acerto na MSRotAuto,MSVldGAuto,MSVldACAuto    
04.02.00XXXXXXSandro  Inclusao da funcao MSExecAuto()				  
11.02.0025504AJulio W Acerto no pulo de Segmento no CNAB II         
02.03.00xxxxxxSandro  Implementaco na funcao condicao para funcionar
                      sem o cadastro SE4                            
11.05.00xxxxxxBruno   Acertar a CalcEst para entradas e saidas de   
                       localizacoes.                                
13.07.00      Sandro  Inclusao de funcao para mostrar o autoerro.log
                      na tela                                       
01.12.006931  Iuspa   ASC2SLD() Obedecendo decimais do X3 (C2_QUANT)
07.02.01      F GarbinAlteracao da funcao MostraErro, p/ utilizacao 
                      em caso de JOBs                               
02.03.01xxxxxxNaldo   Passagem de Novo Paramentro para fDesc()  para
                      o tratamento de Filiais.                      
28.08.01xxxxxxNaldo   Alterada fDesc() para quando nao for  localiza
                      da a Chave retornar com Space de nBytes.      
21.05.02xxxxxxNaldo   Alterada MsMm() para Destravar os    Registros
                      travados com RecLock() quando Exclusao de Memo
27.06.02xxxxxxNaldo   Alterada fDesc() para utilizar MsSeek() ao  in
                      ves de dbSeek() e passagem de novo   parametro
                      p/ a Selecao de Ordem						  
03.09.02xxxxxxNaldo   Retirada do Teste da Variavel Inclui em fDesc 
08.09.02xxxxxxBruno   Desconsiderar Remitso SCM/SCN na xCalcEst().  
23.12.02xxxxxxNaldo   Exclusao da Variavel Local lNovo em fDesc().  
03.04.03MelhorNaldo   fDesc() podera retornar o conteudo de Qualquer
                      Campo independente do Tipo.					  
                      fDesc() nao precisara mais restaurar a Area de
                      entrada uma vez que a pesquisa e feita por  re
                      ferencia de Alias ( cAlias )->( Exp. )		  
17.10.03MelhorNaldo   Alterada MsMm para Utilizar Soma1() para obter
                      a sequencia a  sergravada, utilizar FieldPos()
                      para verificar a Existencia dos campos,  utili
                      lizacao de Begin/End Sequence para  padronizar
                      o retorno, e otimizacao do processo de  verifi
                      cacao da filial evitando chamada desnecessaria
                      a xFilial() ( A macro cFilial foi  substituida
                      por uma variavel que chama a xFilial() uma uni
                      ca vez), gravar a chave do Memo somente apos a
                      gravacao de todas as Linhas					  
17.10.03AcertoNaldo   Alterada MsMm para Utilizar Soma1() para  veri
                      ficar corretamente a Linha conforme nLin	  
20.03.04MelhorNaldo   Verificar xFilial() em fDesc() apenas para  ar
                      quivos que possuam _FILIAL                 	  
26.03.04AcertoNaldo   Garantir o posicionamento no SX3 na fDesc     
04.05.07122616Norbert Incluido tratamento de desconto no calculo de 
                      juros do titulo na rotina FA070Juros().       
15.10.12TFTRE0Luis    Ajuste para verificar se sera gerada (ou nao) 
        024091Artuso  linha em branco no arquivo magnetico (CNAB2)  
          2012        de liquidos.                                  
ٱ


*/


/*

Ŀ
Array 	   aProcedure  Autor  Vicente Sementilli  Data  27.07.98 
Ĵ
Descrio  O array aProcedure foi criado para armazenar os nomes de   
			  procedures para evitar a checagem constante de sua existen-
			  cia no Banco de Dados                                      
Ĵ
 Uso		  Generico                                                   
ٱ


*/
Static aProcedures := {}

/*


Ŀ
Funo	 A330GRAVASB6 Autor  Marcos Bregantim     Data  07/07/95 
Ĵ
Descrio  Grava Custo do Poder de Terceiros                          
Ĵ
Sintaxe	  A330GRAVASB6(xPar1,xPar2)                                  
Ĵ
 Uso		  MATA330                                                    
ٱ


*/
Function A330GRAVASB6(cAlias,aCusto,aCustoFF,lCusFIfO,lCstPart,aRegraCP,aRetPartes,lCusRep,aCMRep)
    Local lEof
    Local cMoedaCM := SuperGetMv('MV_MOEDACM',.F.,"2345")

    lCusFIfO := IIf(lCusFIfO==Nil,.F.,lCusFIfO)

    DEFAULT lCstPart := .F.
    DEFAULT lCusRep  := .F.
    DEFAULT aCMRep   := {0,0,0,0,0}

    If cAlias == "SD1"
        DbSelectArea("SB6")
        DbSetOrder(3)
        DbSeek ( xFilial() + SD1->D1_IDENTB6 + SD1->D1_COD + "R")
        lEof := .t.
        While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD1->D1_IDENTB6 + SD1->D1_COD
            If SB6->B6_TIPO == "D"
                lEof := .f.
                Exit
            EndIf
            DbSkip()
        End
        If !lEof
            Reclock("SB6",.F.)
            SB6->B6_QUANT		:= SD1->D1_QUANT
            If lCusFIfO
                SB6->B6_CUSFF1 := aCusto[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCusto[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        Else
            Reclock("SB6",.T.)
            SB6->B6_QUANT	:= SD1->D1_QUANT
            SB6->B6_FILIAL := xFIlial("SB6")
            SB6->B6_PRODUTO:= SD1->D1_COD
            SB6->B6_CLIfOR := SD1->D1_FORNECE
            SB6->B6_LOJA	:= SD1->D1_LOJA
            SB6->B6_IDENT := SD1->D1_IDENTB6
            SB6->B6_TPCF := Iif(SD1->D1_TIPO $"DB","C","F")
            SB6->B6_TIPO := "D"
            If lCusFIfO
                SB6->B6_CUSFF1 := aCusto[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCusto[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        EndIf
    Else
        DbSelectArea("SB6")
        DbSetOrder(3)
        DbSeek ( xFilial() + SD2->D2_IDENTB6 + SD2->D2_COD + "R" )
        lEof := .t.
        While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD2->D2_IDENTB6 + SD2->D2_COD
            If SB6->B6_TIPO == "E"
                lEof := .f.
                Exit
            EndIf
            DbSkip()
        End
        If !lEof
            Reclock("SB6",.F.)
            SB6->B6_QUANT		:= SD2->D2_QUANT
            If lCusFIfO
                SB6->B6_CUSFF1 := aCustoFF[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCustoFF[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCustoFF[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCustoFF[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCustoFF[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        Else
            Reclock("SB6",.t.)
            SB6->B6_QUANT		:= SD2->D2_QUANT
            SB6->B6_FILIAL := xFIlial("SB6")
            SB6->B6_PRODUTO := SD2->D2_COD
            SB6->B6_CLIfOR := SD2->D2_CLIENTE
            SB6->B6_LOJA := SD2->D2_LOJA
            SB6->B6_IDENT := SD2->D2_IDENTB6
            SB6->B6_TPCF := Iif(SD2->D2_TIPO $"DB","F","C")
            SB6->B6_TIPO := "E"
            If lCusFIfO
                SB6->B6_CUSFF1 := aCustoFF[1]
                SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCustoFF[2],0)
                SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCustoFF[3],0)
                SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCustoFF[4],0)
                SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCustoFF[5],0)
            Else
                SB6->B6_CUSTO1 := aCusto[1]
                SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
                SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
                SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
                SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
                If lCusRep
                    SB6->B6_CUSRP1 := aCMRep[1]
                    SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
                    SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
                    SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
                    SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
                EndIf
            EndIf
            MsUnlock()
        EndIf
    EndIf
    GravaCusCP(lCstPart,aRegraCP,aCusto,"SB6",SB6->B6_PRODUTO,aRetPartes,NIL,NIL,ACLONE(aCusto))
Return (aCusto)

	/*
	
	
	Ŀ
	Funo	 CheckCols    Autor  Juan Jose Pereira    Data  27/03/96 
	Ĵ
	Descrio  VerIfica se linha do aCols foi preenchido 					  
	Ĵ
	Sintaxe	 lRet:=CheckCols(n,aCols) 											  
	Ĵ
	 Uso		 LinOk																		  
	ٱ
	
	
	*/
Function CheckCols(n,aCols)

    Local lRet:=.T.,lVazio:=.T.

    If n==Len(aCols)
        Aeval(aCols[n],{|x|If(lVazio,lVazio:=Empty(x),lVazio)})
        If lVazio
            lRet:=.F.
            Help(" ",1,"CHECKCOLS")
        EndIf
    EndIf

Return (lRet)

	/*
	
	
	Ŀ
	Funo	  EvalMacro	 Autor  Juan Jose Pereira	 Data 08/04/97 
	Ĵ
	Descrio  Executa Macro															  
	ٱ
	
	
	*/
FUNCTION EvalMacro(cMacro)
Return(If(Empty(cMacro),NIL,&(cMacro)))

    #ifdef TOP
Function MSFILTER(cFiltro)
    Local cExpress, nAt, cNewFilter := ""

    Set Filter To &(cFiltro)
    DbGoTop()
Return

#endif


	/*
	
	
	Ŀ
	Funo	  NumImp	 Autor  Alessandro B. Freire   Data  19.05.97 
	Ĵ
	Descrio  Retorna o numero correto de impressao							  
	Ĵ
	Sintaxe	  Cabec(titulo,cabec1,cabec2,tamanho,NumImp()) 				  
	Ĵ
	Parametros 																			  
				  																			  
	Ĵ
	 Uso		  Generico 																  
	ٱ
	
	
	*/
Function NumImp()
    //Ŀ
    // Esta funcao somente deve ser usada como parametro de impressao da funcao	 
    // cabec.																							 
    // Retornos:																						 
    // 15 - Comprimido ( Cabec nao imprime o caractere 15, a funcao utiliza este  
    //		numero apenas como referencia ao tipo de impressao )						 
    //																									 
    // 18 - Normal ( O mesmo acima )															 
    //
    Local nTipo := Iif( aReturn[4] == 1, 15, 18 )
Return( nTipo )

	/*
	
	Ŀ
	Funo	 AcessaPerg Autor  Mauricio Pequim Jr	   Data  19/08/97 
	Ĵ
	Descrio Acessa a funo pergunte a partir de uma chave				  
	Ĵ
	 Uso		  Generico 																  
	ٱ
	
	
	*/
Function AcessaPerg(cPergunta,lModo)
    lModo := Iif(lModo=Nil,.T.,lModo)
    pergunte(cPergunta,lModo)
Return (.T.)
	/*
	
	Ŀ
	Funo	   MSMM 	 Autor  Gilson Nascimento	  	 Data  09/07/96 
	Ĵ
	Descrio  Pesquisa especial para campo MEMO da integracao SIGAEIC/Adv
				  (AVERAGE/MICROSIGA)										  
	Ĵ
	Sintaxe	  MSMM(ExprC1,ExprN1,ExprN2,ExprC2,ExprN3)					  
	Ĵ
	Retorno	  Retorna String pesquisada								  
	Ĵ
	Uso		  SIGAEIC													  
	ٱ
	*/
Function MSMM( cChave , nTam , nLin , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias, lSoInclui )
	Local nPos, nTexto
	Local cAliasOld := Alias() , cFilSYP
	Local uRet      := " "
	Local lUsaSx8   := (cChave == NIL .Or. Empty(cChave))
	Local cLine     := ""
	Local lField    := .F.
	Local nLen1
	Local nLen2
	Local cSeq
	Local lGrv := .F.
	Local nPos2
	Local nTamSeq
	Local cPrefixo
	Local nLenSYP

	Local nYP_TEXTO
	Local nYP_CHAVE
	Local nYP_FILIAL
	Local nYP_SEQ

	DEFAULT cChave := StrZero(0,6)
	DEFAULT	nLin := 0
	DEFAULT cString := ""
	DEFAULT nOpc := 3
	DEFAULT cRealAlias := "SYP"
	DEFAULT lSoInclui := .F.

	cPrefixo := PrefixoCpo(cRealAlias)
	cFilSYP := xFilial(cRealAlias)
	nTamSeq := TamSx3(cPrefixo+"_SEQ")[1]
	//Ponto de entrada exclusivo para uso interno do SSIM
	//NAO DIVULGAR PARA CLIENTE
    If VALTYPE(__lUMSMM) <> "L"
		__lUMSMM := FindFunction( "U_UMSMM" )
    EndIf

    If __lUMSMM .AND. ProcName(1) <> "U_UMSMM"		//Tratamento para caso no consiga resolver, poder executar a MSMM original de dentro do Ponto.
		///PONTO DE ENTRADA "UMSMM"
		uRet := U_UMSMM(cChave , nTam , nLin , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias, lSoInclui )
    Else

        Begin Sequence
            If nOpc == 3 // Ler Memo
                If nLin > 0 // Linha especficia
					uRet := MSMM( cChave , nTam , 0 , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias )

					// Atribui valores defaults
					nTabSize := IF(ValType(nTabSize)=="N",nTabSize,nil)
					lWrap := IF(ValType(lWrap)=="L",lWrap,nil)

					uRet := MemoLine(uRet,nTam,nLin,nTabSize,lWrap)

                    If !Empty(cAliasOld)
						dbSelectArea(cAliasOld)
                    EndIf
					Return uRet
                Endif
            Else
				//Se no Possuir Chave e String Vazia Abandona
                IF ( Empty( cChave ) .and. Empty( cString ) )
					Break
                EndIF
				//verifica se o campo existe na tabela
                If ( cCpoChave <> NIL )
					cCpoChave := Trim(cCpoChave)
                    IF !( lField := ( ( cAlias )->( FieldPos( cCpoChave  ) ) > 0.00 ) )
						Break
                    EndIF
                EndIf
            EndIf

			DbSelectArea(cRealAlias)
			DbSetOrder(1)
			DbSeek(cFilSYP + cChave, .T.)

			nYP_TEXTO := FieldPos(cPrefixo+"_TEXTO")
			nYP_CHAVE := FieldPos(cPrefixo+"_CHAVE")
			nYP_FILIAL := FieldPos(cPrefixo+"_FILIAL")
			nYP_SEQ := FieldPos(cPrefixo+"_SEQ")
			nLenSYP := Len(FieldGet(nYP_TEXTO))

			DEFAULT nTam    := nLenSYP

			// Ler campo MEMO
            If nOpc == 3
				//cSeqAux := Replicate( "9" , nTamSeq )
                While !Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilSYP == FieldGet(nYP_FILIAL) )
					/* contornado com a utilizao da funo MemoLine()
                    If nLin > 0
						nPos := At("\13\10",Subs(FieldGet(nYP_TEXTO),1,nTam+6))
                        If ( nPos == 0 )
							cLine := RTrim(Subs(FieldGet(nYP_TEXTO),1,nTam))
                            If ( nPos2 := At("\14\10", cLine) ) > 0
								cString += StrTran( cLine, "\14\10", Space(6) )
                            Else
								cString += cLine
                            EndIf
                        Else
							cString += Subs(FieldGet(nYP_TEXTO),1,nPos-1)
                        EndIf
						Exit
                    EndIf
					*/

                    nPos := At("\13\10",Subs(FieldGet(nYP_TEXTO),1,nTam+6))
                    If ( nPos == 0 )
                        cLine := RTrim(Subs(FieldGet(nYP_TEXTO),1,nTam))
                        If ( nPos2 := At("\14\10", cLine) ) > 0
                            cString += StrTran( cLine, "\14\10", Space(6) )
                        Else
                            cString += cLine
                        EndIf
                    Else
                        cString += Subs(FieldGet(nYP_TEXTO),1,nPos-1) + CRLF
                    EndIf
                    DbSkip()
                End While
                uRet := cString

            ElseIf nOpc == 2

                // Excluir campo MEMO
                uRet := .F.
                While !Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilSYP == FieldGet(nYP_FILIAL) )
                    RecLock(cRealAlias,.F.,.T.)
                    DbDelete()
                    MsUnLock()
                    uRet := .T.
                    DbSkip()
                End While

            Else

                // Incluir/Alterar campo MEMO
                If ( lUsaSx8 ) .and. ( nOpc == 1 )
                    cChave := GetSX8Num(cRealAlias,cPrefixo+"_CHAVE")
                EndIf

                if !lSoInclui  //default
                    cSeq 	:= Space( nTamSeq )
                else
                    dbseek(cFilSYP+cChave+'ZZZ',.T.)
                    dbSkip(-1) //Posiciono na ltima sequncia
                    if ( cChave == FieldGet(nYP_CHAVE) .And.  cFilSYP == FieldGet(nYP_FILIAL) )
                        cSeq:=FieldGet(nYP_SEQ)
                    else
                        cSeq 	:= Space( nTamSeq )
                    endif
                endif

                cString	:= Trim(cString)
                If nTam >= nLenSYP .or. nTam > (nLenSYP - 6)
                    nTam := nLenSYP - 6
                EndIf

                While !Empty(cString)

                    nTexto := At(CRLF,cString)
                    If nTexto == nTam
                        cLine := Subs(cString,1,nTam+1)
                    Else
                        cLine := Subs(cString,1,nTam)
                    EndIf
                    nTexto := At(CRLF,cLine)

                    If nTexto > 0

                        cLine := Subs(cLine,1,nTexto-1)+"\13\10"
                        nTexto += 2

                    Else

                        If !Empty(cLine)

                            nTexto := nTam+1
                            nLen1 := Len(cLine)
                            nLen2 := Len(Trim(cLine))

                            //verifica se tem espaco no final da linha para colocar no inicio do proximo registro
                            If nLen1 <> nLen2
                                cLine := Trim(cLine)
                                nTexto -= (nLen1 - nLen2)
                            EndIf

                        Else

                            cLine := Subs( cLine, 1, nTam-6 ) + '\14\10'
                            nTexto += nTam + 1

                        EndIf

                    EndIf

                    cString := Subs(cString,nTexto)

                    cSeq := Soma1( cSeq , nTamSeq )

                    lGrv := .T.
                    GrvMemo( cFilSYP , cChave , cSeq , cLine , cCpoChave, cRealAlias )

                End While

                cSeq := IF( Empty( cSeq ) , Soma1( Space( nTamSeq ) , nTamSeq ) , cSeq )

                IF ( lGrv )
                    DbSelectArea(cAlias)
                    RecLock( cAlias , .F. )
                    Eval( FieldWBlock( cCpochave,Select(cAlias) ),cChave)
                    MsUnLock()
                    FkCommit()
                    DbSelectArea(cRealAlias)
                    DbSeek( cFilSYP + cChave + Soma1( cSeq , nTamSeq ) , .T. )
                Else
                    DbSeek( cFilSYP + cChave , .T. )
                Endif

                While !Eof() .and. ( FieldGet(nYP_FILIAL) == cFilSYP ) .and. ( FieldGet(nYP_CHAVE) == cChave )
                    RecLock( cRealAlias , .F. )
                    DbDelete()
                    MsUnlock()
                    DbSkip()
                End While

                uRet := cChave
                IF ( ( lUsaSx8 ) .and. ( nOpc == 1 ) )
                    ConfirmSX8()
                EndIF

            EndIF

        End Sequence
    EndIf
    dbSelectArea( cAliasOld )

Return( uRet )

Static Function GrvMemo( cFilSYP , cChave , cSeq , cLine , cCpoChave, cRealAlias )
    Local nYP_CAMPO
    Local cPrefixo := PrefixoCpo(cRealAlias)

    DbSelectArea(cRealAlias)
    RecLock( cRealAlias , !DbSeek( cFilSYP + cChave + cSeq ) )
    FieldPut(FieldPos(cPrefixo+"_FILIAL"),cFilSYP)
    FieldPut(FieldPos(cPrefixo+"_CHAVE"),cChave)
    FieldPut(FieldPos(cPrefixo+"_SEQ"),cSeq)
    FieldPut(FieldPos(cPrefixo+"_TEXTO"),cLine)
    IF (nYP_CAMPO := FieldPos(cPrefixo+"_CAMPO")) > 0
        FieldPut(nYP_CAMPO,cCpochave)
    EndIF
    MsUnlock()
    FkCommit()
Return( NIL )

	/*
	
	Ŀ
	Funo    E_MsMM     Autor  AVERAGE/MJBARROS       Data  22.07.97 
	Ĵ
	Descrio Inicializacao de campos memo para visualizacao              
	                                                                      
	Ĵ
	Sintaxe e                                                             
	Ĵ
	Parametros idem parametros da MsMM                                    
	Ĵ
	Uso        SIGAEIC/SIGACOM                                            
	ٱ
	
	
	*/
Function E_MsMM(cChave,nTam,nLin,cString,nOpc,nTabSize,lWrap,cAlias,cCpochave)
Return If(Inclui,"",MsMM(cChave,nTam,If(GetStartMod1(),nLin,1),cString,nOpc,nTabSize,lWrap,cAlias,cCpochave))

	/*
	
	Ŀ
	Funo	 PrefixoCpo Autor  Gilson					   Data  08.10.97 
	Ĵ
	Descrio Devolve prefixo do campo para o Alias Apontado				  
				  																			  
	Ĵ
	Parametros cAlias																	  
	Ĵ
	Uso		  Generico 																  
	ٱ
	
	
	*/
Function PrefixoCpo(cAlias)
    Local cRet
    If cAlias == Nil
        cAlias := Alias()
    EndIf
    If Subs(cAlias,1,1) != "S" .and. Len(cAlias) == 3
        cRet := Subs(cAlias,1,3)
    Else
        cRet := Subs(cAlias,2,2)
    EndIf
Return cRet

	/*
	
	
	Ŀ
	Funo	 SomaIt 	 Autor   Marcos Simidu	      Data  19/05/97
	Ĵ
	Descrio  Soma um no item											  
	Ĵ
	 Uso		  Generico 												  
	ٱ
	
	
	*/
Function SomaIt(cItem)
Return(Soma1(cItem))

	/*
	
	Ŀ
	Funo	 DtMovFin	 Autor  Mauricio Pequim Jr	   Data  06/11/97 
	Ĵ
	Descrio Data limite para realizao de Movimento no Financeiro 	  
	Ĵ
	 Uso		  Generico 																  
	ٱ
	
	
	*/
Function DtMovFin(dData,lHelp)

    Local FADTMOV := ExistBlock("FADTMOV")
    Local lRet := .T.

    lHelp := Iif(lHelp==NIL,.T.,lHelp)
    dData := Iif(dData==NIL,dDatabase,dData)
    If dData < GetMv("MV_DATAFIN") .And. !FADTMOV
        If lHelp
            Help ( " ", 1, "DTMOVFIN")
        EndIf
        lRet:=.F.
    EndIf
    // TRECHO RETIRADO A PEDIDOS DO VP WILSON
	/*If !empty(SM0->M0_DTVLD) .and. dData > SM0->M0_DTVLD .And. !FADTMOV
    IF lHelp
		F080Help() // funo no fonte FINA080.PRX
		Help( " ", 1, "DTINVALSM0",, "",1,0 ) //"Data no pode ser maior do que a data limite autorizada no SIGAMAT utilizado.
    Endif
	lRet := .F.
Endif*/

/*Ponto de entrada para controlar datas diferentes para movimento bancario,
contas a pagar entre outras funcionalidades em que  aplicado a DtMovFin*/
If FADTMOV
	lRet :=	ExecBlock("FADTMOV",.F.,.F.,{dData})
EndIf

Return lRet


/*

Ŀ
Funo	 InverteSi1 Autor  Alice Yaeko Yamamoto   Data  12/11/97 
Ĵ
Descrio Cria codigo invertido da Conta 									  
Ĵ
 Uso		  Generico 																  
ٱ


*/
Function InverteSi1(cCodigo)
    Local j
    Local cCodInv:=""
    Local nFator

    //Ŀ
    // 0  - 9		 Exemplos de contas Invertidas			  
    // 1  - 8		 1 		- 8zzzzzzzzzzzzzz 				  
    // 2  - 7		 11		- 88zzzzzzzzzzzzz 				  
    // 3  - 6		 1110208 - 8889791zzzzzzzz 				  
    // 4  - 5															  
    // 5  - 4															  
    // 6  - 3															  
    // 7  - 2															  
    // 8  - 1															  
    // 9  - 0															  
    //" " - z                                             
    //

    For j := 1 To 20
        If Subs(cCodigo,j,1) = " "
            cCodInv += "z"
        Else
            nFator  := 9-Int(Val(Subs(cCodigo,j,1)))
            cCodInv += Str(nFator,1)
        EndIf
    Next
Return cCodInv

	/*
	
	Ŀ
	Funo	 A460NumIt  Autor  Rosane Luciane Chene   Data  23.10.95 
	Ĵ
	Descrio VerIfica conforme o numero de serie , qual a quantidade	  
				 de maxima de itens por nota fiscal								  
	Ĵ
	Uso		  MATA460	e MATA100													  
	ٱ
	
	
	*/
Function A460NumIt(cSerie, lEntrada)
    Local  cAlias :=Alias()
    Local  nItens :=0
    Local  cParam :=""

    DEFAULT lEntrada := .F.

    nItens:=GETMV("MV_NUMITEN")
    cParam := "MV_ITEM" + cSerie
    nItens:=GetNewPar(cParam,nItens)

    If lEntrada
        If ExistBlock("MTAITNFE")
            nItens := ExecBlock("MTAITNFE",.F.,.F.,{nItens,cSerie})
        EndIf
    Else
        If ExistBlock("MTAITNFS")
            nItens := ExecBlock("MTAITNFS",.F.,.F.,{nItens,cSerie})
        EndIf
    EndIf

    DbSelectArea(cAlias)
Return( nItens )

	/*
	
	
	Ŀ
	Funo	 IsTriangul Autor  Ben-Hur M Castilho	   Data  15/01/98 
	Ĵ
	Descrio VerIfica se utiliza operacao triangular.						  
	ٱ
	
	
	*/
Function IsTriangular( lNewValue )

    Static lTriangular := .F.

    If ((PCount() == 1) .And. (ValType( lNewValue ) == "L"))
        lTriangular := lNewValue
    EndIf

Return( lTriangular )

	/*/
    
    
    Ŀ
    Funo	  fC010Venc Autor  Vinicius S. Barreira   Data  31/10/94 
    Ĵ
    Descrio  Retorna a data de vencimento. 									  
    Ĵ
    Sintaxe	  fC010Venc() 															  
    Ĵ
     Uso		  Generico 																  
    ٱ
    
    
	/*/
Function fC010Venc()

    Local dData := dDataBase

    If DataValida(SE1->E1_VENCTO,.T.) <= dDataBase
        dData := SE1->E1_VENCTO
    Else
        dData := DataValida(SE1->E1_VENCTO,.t.)
    EndIf
Return dData

	/*/
    
    
    Ŀ
    Funo	 fa070juros Autor  Wagner Xavier 		   Data  06/05/92 
    Ĵ
    Descrio Calcula o juros de um determinado titulo.						  
    Ĵ
    Sintaxe	 fa070juros(ExpN1)														  
    Ĵ
    ParametrosExpN1		: Moeda														  
    			 ExpN2		: Valor do Titulo a ser considerado Def.:E1_SALDO 
    			 dBaixa 	: Data em que o juros sera pago. 					  
    			 nJuros 	: Valor do Juros do Titulo 							  
    Ĵ
    ObservacaoOs parametros dBaixa e nJuros devem ser variaveis Privates  
    			 declaradas antes da chamada da funcao. E o titulo deve estar
    			 posicionado. 															  
    Ĵ
     Uso		  FINA070																	  
    ٱ
    
    
	/*/
Function fa070Juros(nMoeda,nVlrTit,cAlias,dUltBaixa)
    Local nTxMoeda
    Local aArea    := GetArea()
    Local aAreaSE1 := SE1->(GetArea())
    Local aAreaSE5 := SE5->(GetArea())

    If cAlias == NIL
        cAlias := "SE1"
    Endif

    nMoeda := If(nMoeda==Nil,1,nMoeda)
    nVlrTit:= If(nVlrTit==Nil,(cAlias)->E1_SALDO,nVlrTit)
    dBaixa := If(Type("dBaixa")=="U",dDataBase,dBaixa)
    nTxMoeda := If(cPaisLoc=="BRA",(cAlias)->E1_TXMOEDA,0)

    DEFAULT dUltBaixa := (cAlias)->E1_BAIXA

    dbSelectArea("SE5")
    dbSetOrder(7)//E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
    If dbSeek(xFilial("SE5")+(cAlias)->E1_PREFIXO+(cAlias)->E1_NUM+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO)
        If SE5->E5_MOTBX $ "CMP" //Se o ttulo tiver sofrido compensao, considero a data de vencimento original e no a data da ltima baixa
            dUltBaixa := StoD("")
        EndIf
    EndIf

    //Calculo de Juros e Multas: SIGALOJA x SIGAFIN
    nJuros := faJuros((cAlias)->E1_VALOR,nVlrTit,(cAlias)->E1_VENCTO,(cAlias)->E1_VALJUR,(cAlias)->E1_PORCJUR,(cAlias)->E1_MOEDA,(cAlias)->E1_EMISSAO,dBaixa,nTxMoeda,dUltBaixa,(cAlias)->E1_VENCREA ,cAlias, , , , )

    //Aplica desconto nos juros do titulo
    If (cAlias)->(FieldPos("E1_DESCJUR")) > 0
        If !Empty((cAlias)->E1_LIDESCF) .AND. (dBaixa <= (cAlias)->E1_LIDESCF)
            nJuros := nJuros - Round((((cAlias)->E1_DESCJUR / 100) * nJuros),2)
        EndIf
    EndIf

    // Converte o valor dos juros para moeda solicitada
    nJuros := xMoeda(nJuros,(cAlias)->E1_MOEDA,nMoeda,dDataBase,,nTxMoeda)

    //
    // Template GEM
    //
    // Executa os calculos das variaveis private:
    //		nCM1
    //		nProRata
    //		nMulta
    //		nJuros
    //
    //
    Default __lGEMJUROS  := ExistTemplate("GEMJUROS")
    Default __lE1_NCONTR := ((cAlias)->(FieldPos("E1_NCONTR")) > 0)
    If __lGEMJUROS .And. __lE1_NCONTR .And. !Empty((cAlias)->E1_NCONTR)
        ExecTemplate("GEMJUROS",.F.,.F.,{cAlias ,dBaixa ,dUltBaixa ,nVlrTit})
    EndIf

    RestArea(aAreaSE5)
    RestArea(aAreaSE1)
    RestArea(aArea)
Return(nJuros)

	/*/
    
    
    Ŀ
    Funo	 faJuros    Autor Eduardo Riera  		 Data 31/12/1999
    Ĵ
    Descrio Calcula o juros de um determinado titulo.	                  
    Ĵ
    Sintaxe	 FaJuros()         										  
    Ĵ
    ParametrosExpN1		: Valor do Titulo                                 
    			 ExpN2		: Saldo do Titulo a ser considerado Def.:E1_SALDO 
    			 ExpD3  	: Data de vencimento do Titulo.  				  
    			 ExpN4  	: Valor do Juros do Titulo 						  
    			 ExpN5  	: Taxa de Permanencia.                            
    			 ExpN6  	: Moeda em que se encontra o Titulo         	  
    			 ExpD7  	: Data de Emissao.                                
    			 ExpD8  	: Data de Baixa.                                  
    Ĵ
     Uso		  FINA070													  
    ٱ
    
    
	/*/
Function faJuros(nVlrTit,nSaldo,dVencto,nValJur,nPerJur,nMoeda,dEmissao,dBaixa,nTxMoeda,dUltBaixa,dVencRea,cAliasSe1,cPrefixo,cNum,cParcela,cTipo)

    Local aAreaSE1	:= {}
    Local nAtraso 	:= 0
    Local nTxPer  	:= 0
    Local nJuros  	:= 0
    Local nAtrSimp	:= 0
    Local nSaldoC 	:= 0
    Local cMvJurTipo:= GetMv("MV_JURTIPO")
    Local nMVFINJRTP:= SuperGetMv("MV_FINJRTP",,1)
    Local nDiasAtraso:=0
    // calculo juros do loja se TipoJur = L
    Local lLojxRJur		:= FindFunction("LojxRJur")
    Local lSE1 			:= .F.
    Local lRestSE1 		:= .F.

    DEFAULT dUltBaixa 	:= dVencto
    DEFAULT	cNum        := ""
    DEFAULT	cPrefixo  	:= ""
    DEFAULT	cParcela  	:= ""
    DEFAULT	cTipo     	:= ""
    Default __lNewJuros := Existblock("NEWJUROS")
    Default __lFJURREC  := Existblock("FJURREC")

    //Ŀ
    // Se funo que chamar a faJuros tiver posicionada no SE1         
    // dever passar apenas o ALIAS do SE1, caso contrrio no         
    // passar o alias e apenas a Chave do SE1 para o faJuros posicionar  
    //

    nTxMoeda := If(nTxMoeda == Nil, 0, nTxMoeda)
    dBaixa   := If(dBaixa==Nil,dDataBase,dBaixa)
    nVlrTit	:= If(nVlrTit==Nil,nSaldo,nVlrTit)
    dVencto := IIf(Day(dUltBaixa)== 0,dVencto,If(dUltBaixa > dVencto, dUltBaixa, dVencto))
    dVencRea := If(dVencRea==Nil,dVencto,dVencRea)

    If ( DataValida(dVencto,.T.) >= dBaixa )
        dVencto := DataValida(dVencto,.T.)
    EndIf

    nAtraso := dBaixa - dVencto

    //Se a data de pagamento for menor ou igual que o vencimento real nao calculo juros
    If dBaixa <= dVencRea
        nAtraso := 0
    EndIf

    If ( Dow(dVencto) == 1 .Or. Dow(dVencto) == 7 )
        If Dow(dBaixa) == 2 .and. nAtraso <= 2
            nAtraso := 0
        EndIf
    EndIf
    If __lNewJuros
        nAtraso := Execblock("NEWJUROS",.f.,.f.,{dBaixa,dVencto,nAtraso})
    Endif

    nAtraso:=Iif(nAtraso<0,0,nAtraso)
    //Ŀ
    // Compara dias de atraso com o parametro tolerancia de atraso  
    //
    If nAtraso <= GetMv("MV_TOLER")
        nAtraso := 0
    EndIf

    //Ponto de entrada para clculo de juros
    Default __lFJURCST := Existblock("FJURCST")
    If !__lFJURCST
        //Ŀ
        // Quando no houver percentual de juros no ttulo deve-se cal- 
        // cular pela taxa de permanencia. Quando ha percentual ou ele  
        // se refere a taxa de permanencia ou ele foi informado manual- 
        // mente na inclusao do titulo a receber.							  
        //
        If ( nAtraso != 0 .And. (!Empty(nValJur) .Or. !Empty(nPerJur)) )
            If !Empty( nValJur ) .and. nMVFINJRTP == 1 		//  MV_FINJRTP = 1.Tx Perm
                nJuros := nValJur * nAtraso
            Else //MV_FINJRTP = 2.Juros ou 3.Ambos
                nTxPer := nPerJur
                //Ŀ
                // Calcula os juros compostos caso o parmetro seja "C";     
                // Calcula os juros simples caso o parametro seja "S"  ;     
                // Calcula os juros mistos  caso o parametro seja "M".       
                //
                If cMvJurTipo == "M" .Or. cMvJurTipo == "S"
                    //Ŀ
                    // Calcula os juros simples											  
                    //
                    If ( cMvJurTipo == "M")
                        nAtrSimp := If( nAtraso > 30 , 30 , nAtraso )
                    Else
                        nAtrSimp := nAtraso
                    EndIf
                    nJuros := nSaldo*(1+(nAtrSimp*(nTxPer/100)))
                    nDiasAtraso := nAtraso
                    nAtraso := Iif(cMvJurTipo == "M", nAtraso-30, nAtraso )
                EndIf
                If ( cMvJurTipo=="M" .And. nAtraso > 0 ) .Or. cMvJurTipo=="C"
                    //Ŀ
                    // Calcula os juros compostos										  
                    //
                    If cMvJurTipo == "C"
                        nSaldoC := nSaldo
                    Else
                        nSaldoC := nJuros
                    EndIf
                    nJuros := nSaldoC *( (1+( nTxPer/100 ) ) ** nAtraso )
                EndIf
                nJuros := nJuros - nSaldo
                If nMVFINJRTP == 3 .and. !Empty( nValJur )  // MV_FINJRTP = 3.Ambos
                    nJuros := nJuros + (nValJur * nDiasAtraso)
                EndIf
            EndIf
        EndIf

        //Calculo de Juros e Multas: SIGALOJA x SIGAFIN - Inicio
        If cMvJurTipo == "L"      //Calculo de Juros e dias de atraso, segundo o controle de Lojas

            nJuros := 0

            If cAliasSE1 == NIL .and. !Empty(cPrefixo+cNum+cParcela+cTipo)

                cAliasSE1 := "SE1"
                aAreaSE1 := GetArea(cAliasSE1)
                lRestSE1 := .T.
                (cAliasSE1)->(dbSetOrder(1))   // E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
                If !Empty(cPrefixo+cNum+cParcela+cTipo)
                    lSE1 := (cAliasSE1)->(DbSeek(xFilial(cAliasSe1)+cPrefixo+cNum+cParcela+cTipo))
                Endif
            Else
                lSE1 := !Empty(cAliasSE1)
            EndIf

            If lSE1
                //Ŀ
                //|  calcula o Juros Funo: LojxRJur - Lojxrec         
                //
                If lLojxRJur
                    nJuros := LojxRJur(, , , ,  (cAliasSe1)->E1_SALDO,;
                        (cAliasSe1)->E1_ACRESC  , cAliasSe1, ,   (cAliasSe1)->E1_MOEDA, dBaixa,(cAliasSE1)->E1_VENCREA, ,(cAliasSE1)->E1_JUROS)

                EndIf
            EndIf

            If lRestSE1
                RestArea(aAreaSE1)
            EndIf

        EndIf
        //Calculo de Juros e Multas: SIGALOJA x SIGAFIN  - Final
    Else
        nJuros := Execblock("FJURCST",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur})
    EndIf

    // Ponto de entrada para recalculo do Juros
    If __lFJURREC
        nJuros := Execblock("FJURREC",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur,nJuros})
    Endif

Return(nJuros)


	/*
	
	Ŀ
	Funo	  CalcEst	    Autor  Vicente Sementilli  Data  27.07.98 
	Ĵ
	Descrio  A Rotina padrao foi renomeada para xCalcEst(), para os ca- 
				  sos que utilizam banco de dados disparem uma Stored Proce- 
				  dure CalcEst.SQL. Se a procedure nao existir a rotina pa-  
				  drao xCalcEst() sera executada.							  
				  Motivo basico da alteracao e a Otimizacao e Performance	  
	Ĵ
	Sintaxe	  ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  
	Ĵ
	Parametros ExpA1 = Array com o Saldo Inicial para o Produto/Local.	  
				  ExpC1 = Codigo do Produto								  
				  ExpC2 = Local (AlmoxarIfado)								  
				  ExpD1 = Data para obter o Saldo Inicial.					  
	Ĵ
	 Uso		  SIGACUS													  
	ٱ
	
	
	*/
Function CalcEst(cCod,cLocal,dData,cFilAux,lConsTesTerc,lCusRep)

    #ifdef TOP
        Local cxFilial       := ""
        Local cProcNam       := IIF(FindFunction("GetSPName"), GetSPName("MAT006","14"), "MAT006")
        Local lD3Servico     := GetMV('MV_D3SERVI', .F., 'N')=='S'
        Default lConsTesTerc := .F.
        Default dData        := dDataBase
        dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)
        If ExistProc( cProcNam, VerIDProc())  .and. ( TcSrvType() <> "AS/400" )
            aResult := {}
            aResult := TCSPExec( xProcedures(cProcNam),	cCod,;											// 01. Codigo do Produto
            cLocal,;										// 02. Codigo do Armazem
            DTOS(dData),;									// 03. Data de Processamento
            If(cFilAux=nil,Subst("-@@-",2,2),cFilAux),;  	// 04. Colocado os tracos antes e depois do @@ para nao ocorrer erro no geracao de ch
                GetMv("MV_LOCPROC"),;							// 05. Armazem de Processo
                cFilAnt,;										// 06. Codigo da Filial
                If(lD3Servico,'1','0'),;						// 07. Considera o parametro MV_D3SERVI
                    If(IntDL(cCod),'1','0'),;						// 08. Verifica a integracao com WMS
                        GetMv("MV_CQ"))									// 09. Armazem de CQ
                        If aResult == Nil
                            Final(STR0091) //"RE-INSTALAR AS STORED PROCEDURES"
                        EndIf
                        Return (aResult)
                    Elseif ExistProc( cProcNam, VerIDProc()) .and. ( TcSrvType() == "AS/400" )
                        cxFilial := BuildStrFil("SD1,SD2,SD3,SF4,SB9,SF5")
                        aResult  := {}
                        aResult  := TCSPExec( xProcedures(cProcNam), cxFilial, cCod, cLocal,;
                            DTOS(dData), If(cFilAux=nil,"@@",cFilAux),;
                            GetMv("MV_LOCPROC"), cFilAnt,;
                            Substr(cUsuario,7,15), DTOS(dDataBase))
                        Return (aResult)
                    Else
                        Return xCalcEst(@cCod,@cLocal,@dData,@cFilAux,lConsTesTerc,lCusRep)
                    EndIf

					/*/
                    
                    
                    Ŀ
                    Funo     xCalcEst  Autor  Wilson Junior          Data  28.03.94 
                    Ĵ
                    Descrio  Retorna o Saldo inicial por Produto/Local do arquivo SB9 - 
                               Saldos Iniciais.                                           
                    Ĵ
                    Sintaxe    ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1)                        
                    Ĵ
                    Parametros ExpA1 = Array com o Saldo Inicial para o Produto/Local.    
                               ExpC1 = Codigo do Produto                                  
                               ExpC2 = Local (AlmoxarIfado)                               
                               ExpD1 = Data para obter o Saldo Inicial.                   
                    Ĵ
                     Uso       SIGACUS                                                    
                    ٱ
                    
                    
					/*/
Function xCalcEst(cCod,cLocal,dData,cFilAux,lConsTesTerc,lCusRep)
#endif

#define F_SB9  1
#define F_SD1  2
#define F_SD2  3
#define F_SD3  4
#define F_SF4  5
#define F_SF5  6

Local nReg,nReg1,nOrd,nOrd1,dDtVai

#ifdef TOP
    Local lHasRec := .F.
#endif

Local aSaldo     := { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
Local cLocProc   := GETMV("MV_LOCPROC")
Local cArq       := Alias()
Local nCnt01     := 0

Local aFilial  := { xFilial( "SB9" ),;
    xFilial( "SD1" ),;
    xFilial( "SD2" ),;
    xFilial( "SD3" ),;
    xFilial( "SF4" ),;
    xFilial( "SF5" ) }

Local lRemInt  := SuperGetMv("MV_REMINT",.F.,.F.)
Local nSizeFil := 2
Local cFiltroSF5 :=	SF5->(DbFilter())

DEFAULT lConsTesTerc := .F.
DEFAULT lCusRep      := .F.
DEFAULT dData        := dDataBase
SF5->(DBClearFilter())

dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)

If !(cFilAux == NIL)
    If FindFunction("FWSizeFilial")
        nSizeFil := FWSizeFilial()
    EndIf
    For nCnt01 := 1 To Len( aFilial )
        If !(aFilial[ nCnt01 ] == Space(nSizeFil))
            aFilial[ nCnt01 ] := cFilAux
        EndIf
    Next
EndIf

//Ŀ
// Ponto de partida para compor o saldo inicial.        
//
DbSelectArea( "SB9" )

#ifndef TOP
    DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
#else
    If TCSrvType() == "AS/400"
        DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
    Else
        DbSeek(aFilial[ F_SB9 ]+cCod+cLocal)
        lHasRec := .f.
        While !Eof() .and. (aFilial[ F_SB9 ]+cCod+cLocal == B9_FILIAL + B9_COD+B9_Local)
            If B9_DATA >= dData .and. lHasRec
                Exit
            Else
                lHasRec := .t.
            EndIf
            DbSkip()
        End
        If lHasRec
            DbSkip(-1)
        EndIf
    End
#endif

If ((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
        (SB9->B9_DATA < dData))

    aSaldo[01] := SB9->B9_QINI
    aSaldo[02] := SB9->B9_VINI1
    aSaldo[03] := SB9->B9_VINI2
    aSaldo[04] := SB9->B9_VINI3
    aSaldo[05] := SB9->B9_VINI4
    aSaldo[06] := SB9->B9_VINI5
    aSaldo[07] := SB9->B9_QISEGUM
    If SB9->(FieldPos("B9_CM1")) <> 0 .And. SB9->(FieldPos("B9_CM2")) <> 0 .And. ;
            SB9->(FieldPos("B9_CM3")) <> 0 .And. SB9->(FieldPos("B9_CM4")) <> 0 .And. ;
            SB9->(FieldPos("B9_CM5")) <> 0
        aSaldo[08] := SB9->B9_CM1
        aSaldo[09] := SB9->B9_CM2
        aSaldo[10] := SB9->B9_CM3
        aSaldo[11] := SB9->B9_CM4
        aSaldo[12] := SB9->B9_CM5
    EndIf
    If lCusRep
        aSaldo[13] := SB9->B9_CMRP1
        aSaldo[14] := SB9->B9_CMRP2
        aSaldo[15] := SB9->B9_CMRP3
        aSaldo[16] := SB9->B9_CMRP4
        aSaldo[17] := SB9->B9_CMRP5
        aSaldo[18] := SB9->B9_VINIRP1
        aSaldo[19] := SB9->B9_VINIRP2
        aSaldo[20] := SB9->B9_VINIRP3
        aSaldo[21] := SB9->B9_VINIRP4
        aSaldo[22] := SB9->B9_VINIRP5
    EndIf
    dDtVai    := SB9->B9_DATA+1
Else
    dDtVai    := Ctod( "01/01/80","ddmmyy" )
EndIf

//Ŀ
// Correr SD1, SD2 e SD3 para  obter o saldo na Data desejada. 
//
DbSelectArea( "SF4" )
nReg1 := Recno()
nOrd1 := Indexord()

DbSelectArea( "SD1" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD1 ]+cCod+cLocal+Dtos(dDtVai),.T. )

While (!Eof() .And. ;
        (aFilial[ F_SD1 ]+cCod+cLocal) == (SD1->D1_FILIAL+SD1->D1_COD+SD1->D1_Local) .And.;
        (SD1->D1_DTDIGIT < dData))

    #ifdef SHELL
        If SD1->D1_CANCEL == "S"
            SD1->(DbSkip())
            Loop
        EndIf
    #endif

    If cPaisLoc != "BRA"
        //Ŀ
        // Desconsiderar notas de remito e notas geradas pelo EIC       
        //| com excecao da nota de FOB.									 |
        //
        If !Empty(SD1->D1_REMITO) .Or. SD1->D1_TIPO_NF $ '6789AB'
            SD1->(DbSkip())
            Loop
        EndIf

        //Ŀ
        // Desconsiderar notas de entrada tipo 10 quando o cliente uti_ |
        //| lizar o conceito de remito interno com importacao (SIGAEIC)  |
        //
        If lRemInt
            If !Empty(SD1->D1_CONHEC) .And. SD1->D1_TIPO_NF $ '5' .And. SD1->D1_TIPODOC $ '10'
                SD1->(DbSkip())
                Loop
            EndIf
        EndIf

    EndIf

    //Ŀ
    // Somente Notas Fiscais Nao Lancadas No Modulo do Livro Fiscal 
    //
    If !(SD1->D1_ORIGLAN == "LF")
        DbSelectArea( "SF4" )
        //		If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD1->D1_TES ) .Or. ;
            //			DbSeek( aFilial[ F_SF4 ]+SD1->D1_TES,.F. ))
        If (iif (FWModeAccess("SF4") == "E",(SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD1->D1_TES ), ;
                (SF4->F4_FILIAL+SF4->F4_CODIGO == substr(aFilial[ 4 ],1,len(SF4->F4_FILIAL)-len(FWFilial("SF4")))+FWFilial("SF4")+SD1->D1_TES)).Or. ;
                DbSeek( aFilial[ F_SF4 ]+SD1->D1_TES,.F. ))
            //Ŀ
            // Somente TES Que Movimenta Estoque Deve Ser Considerada 
            // ou TES de poder de terceiros com parametro ligado      
            //
            If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
                aSaldo[1] += SD1->D1_QUANT
                aSaldo[2] += SD1->D1_CUSTO
                aSaldo[3] += SD1->D1_CUSTO2
                aSaldo[4] += SD1->D1_CUSTO3
                aSaldo[5] += SD1->D1_CUSTO4
                aSaldo[6] += SD1->D1_CUSTO5
                aSaldo[7] += SD1->D1_QTSEGUM
                If lCusRep
                    aSaldo[18] += SD1->D1_CUSRP1
                    aSaldo[19] += SD1->D1_CUSRP2
                    aSaldo[20] += SD1->D1_CUSRP3
                    aSaldo[21] += SD1->D1_CUSRP4
                    aSaldo[22] += SD1->D1_CUSRP5
                EndIf
            EndIf
        EndIf
        DbSelectArea( "SD1" )
    EndIf
    DbSkip(1)
End

DbSetOrder( nOrd ) ; DbGoTo( nReg )

DbSelectArea( "SD2" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 6 )

DbSeek( aFilial[ F_SD2 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
        (aFilial[ F_SD2 ]+cCod+cLocal == SD2->D2_FILIAL+SD2->D2_COD+SD2->D2_Local) .And. ;
        (SD2->D2_EMISSAO < dData))

    #ifdef SHELL
        If SD2->D2_CANCEL == "S"
            SD2->(DbSkip())]
            Loop
        EndIf
    #endif

    If !Empty(SD2->D2_REMITO) .And. !(SD2->D2_TPDCENV $ "A1")
        SD2->(DbSkip())
        Loop
    EndIf

    //Ŀ
    // Despreza Notas Fiscais Lancadas Pelo Modulo do Livro Fiscal  
    //
    If !(SD2->D2_ORIGLAN == "LF")
        DbSelectArea("SF4")
        If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD2->D2_TES ) .Or. ;
                DbSeek( aFilial[ F_SF4 ]+SD2->D2_TES,.F. ))
            //Ŀ
            // Somente TES Que Movimenta Estoque Deve Ser Considerada 
            // ou TES de poder de terceiros com parametro ligado      
            //
            If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
                aSaldo[1] -= SD2->D2_QUANT
                aSaldo[2] -= SD2->D2_CUSTO1
                aSaldo[3] -= SD2->D2_CUSTO2
                aSaldo[4] -= SD2->D2_CUSTO3
                aSaldo[5] -= SD2->D2_CUSTO4
                aSaldo[6] -= SD2->D2_CUSTO5
                aSaldo[7] -= SD2->D2_QTSEGUM
                If lCusRep
                    aSaldo[18] -= SD2->D2_CUSRP1
                    aSaldo[19] -= SD2->D2_CUSRP2
                    aSaldo[20] -= SD2->D2_CUSRP3
                    aSaldo[21] -= SD2->D2_CUSRP4
                    aSaldo[22] -= SD2->D2_CUSRP5
                EndIf
            EndIf
        EndIf
        DbSelectArea( "SD2" )
    EndIf
    DbSkip(1)
End

DbSetOrder( nOrd ) ; DbGoTo( nReg )


DbSetOrder( nOrd ) ; DbGoTo( nReg )

DbSelectArea( "SF4" )
DbSetOrder( nOrd1 ) ; DbGoTo( nReg1 )

DbSelectArea( "SF5" )
nReg1 := Recno()
nOrd1 := IndexOrd()

DbSelectArea( "SD3" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD3 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
        (aFilial[ F_SD3 ]+cCod+cLocal == SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_Local) .And. ;
        (SD3->D3_EMISSAO < dData))
    If !D3Valido()
        DbSkip()
        Loop
    EndIf
    DbSelectArea( "SF5" )
    If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
            (SD3->D3_TM == "499") .Or. ;
            (SD3->D3_TM == "999") .Or. ;
            DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))
        If SD3->D3_TM >"500"
            aSaldo[1] -= SD3->D3_QUANT
            aSaldo[2] -= SD3->D3_CUSTO1
            aSaldo[3] -= SD3->D3_CUSTO2
            aSaldo[4] -= SD3->D3_CUSTO3
            aSaldo[5] -= SD3->D3_CUSTO4
            aSaldo[6] -= SD3->D3_CUSTO5
            aSaldo[7] -= SD3->D3_QTSEGUM
            If lCusRep
                aSaldo[18] -= SD3->D3_CUSRP1
                aSaldo[19] -= SD3->D3_CUSRP2
                aSaldo[20] -= SD3->D3_CUSRP3
                aSaldo[21] -= SD3->D3_CUSRP4
                aSaldo[22] -= SD3->D3_CUSRP5
            EndIf
        Else
            aSaldo[1] += SD3->D3_QUANT
            aSaldo[2] += SD3->D3_CUSTO1
            aSaldo[3] += SD3->D3_CUSTO2
            aSaldo[4] += SD3->D3_CUSTO3
            aSaldo[5] += SD3->D3_CUSTO4
            aSaldo[6] += SD3->D3_CUSTO5
            aSaldo[7] += SD3->D3_QTSEGUM
            If lCusRep
                aSaldo[18] += SD3->D3_CUSRP1
                aSaldo[19] += SD3->D3_CUSRP2
                aSaldo[20] += SD3->D3_CUSRP3
                aSaldo[21] += SD3->D3_CUSRP4
                aSaldo[22] += SD3->D3_CUSRP5
            EndIf
        EndIf
    EndIf
    DbSelectArea( "SD3" ) ; DbSkip(1)
End

If AllTrim(cLocal) == AllTrim(cLocProc)

    DbSetOrder( 7 )

    DbSeek( aFilial[ F_SD3 ]+cCod,.T. )

    While (!Eof() .And. ;
            (aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD))

        If SD3->D3_EMISSAO >= dData
            SD3->(dbSkip())
            Loop
        EndIf

        While (!Eof() .And. ;
                (aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD) .And. ;
                (SD3->D3_EMISSAO < dData))

            If ((SD3->D3_EMISSAO <  dData)      .And. ;
                    (SD3->D3_EMISSAO >= dDtVai)     .And. ;
                    (SubS( SD3->D3_CF,2 ) == "E3")  .And. ;
                    !(alltrim(SD3->D3_Local) == alltrim(cLocProc)))

                If !D3Valido()
                    DbSkip()
                    Loop
                EndIf

                DbSelectArea( "SF5" )
                If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
                        (SD3->D3_TM == "499") .Or. ;
                        (SD3->D3_TM == "999") .Or. ;
                        DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))

                    If SD3->D3_CF = "RE3"

                        aSaldo[1] += SD3->D3_QUANT
                        aSaldo[2] += SD3->D3_CUSTO1
                        aSaldo[3] += SD3->D3_CUSTO2
                        aSaldo[4] += SD3->D3_CUSTO3
                        aSaldo[5] += SD3->D3_CUSTO4
                        aSaldo[6] += SD3->D3_CUSTO5
                        aSaldo[7] += SD3->D3_QTSEGUM
                        If lCusRep
                            aSaldo[18] += SD3->D3_CUSRP1
                            aSaldo[19] += SD3->D3_CUSRP2
                            aSaldo[20] += SD3->D3_CUSRP3
                            aSaldo[21] += SD3->D3_CUSRP4
                            aSaldo[22] += SD3->D3_CUSRP5
                        EndIf
                    ElseIf SD3->D3_CF = "DE3"
                        aSaldo[1] -= SD3->D3_QUANT
                        aSaldo[2] -= SD3->D3_CUSTO1
                        aSaldo[3] -= SD3->D3_CUSTO2
                        aSaldo[4] -= SD3->D3_CUSTO3
                        aSaldo[5] -= SD3->D3_CUSTO4
                        aSaldo[6] -= SD3->D3_CUSTO5
                        aSaldo[7] -= SD3->D3_QTSEGUM
                        If lCusRep
                            aSaldo[18] -= SD3->D3_CUSRP1
                            aSaldo[19] -= SD3->D3_CUSRP2
                            aSaldo[20] -= SD3->D3_CUSRP3
                            aSaldo[21] -= SD3->D3_CUSRP4
                            aSaldo[22] -= SD3->D3_CUSRP5
                        EndIf
                    EndIf
                EndIf
            EndIf

            DbSelectArea("SD3")
            DbSkip()
        End
    End
EndIf

DbSetOrder( nOrd ) ; DbGoTo( nReg )


DbSelectArea("SF5")
DbSetOrder( nOrd1 ) ; DbGoTo( nReg1 )
If !Empty (cFiltroSF5)
    dbSetFilter({||&cFiltroSF5},cFiltroSF5)
EndIf

DbSelectArea( cArq )

Return( aSaldo )

				/*
				
				
				Ŀ
				Funo	 CalcEstFF  Autor  Ben-Hur M. Castilho    Data  03.03.98 
				Ĵ
				Descrio  Retorna o Saldo Inicial por Produto/Local do arquivo SB9 - 
							  Saldos Iniciais. (Custo FIfO) 							  
				Ĵ
				Sintaxe	  ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  
				Ĵ
				Parametros ExpA1 = Array com o Saldo Inicial para o Produto/Local.	  
							  ExpC1 = Codigo do Produto								  
							  ExpC2 = Local (AlmoxarIfado)								  
							  ExpD1 = Data para obter o Saldo Inicial.					  
				           ExpC3 = Lote FIFO                                          
				           ExpL1 = Forca uso do saldo inicial padrao                  
				Ĵ
				 Uso		  SIGACUS													  
				ٱ
				
				
				*/
Function CalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFiFO,lForcaSB9)

    #ifdef F_SB9
        #undef F_SB9
    #endif

    #define F_SB9	1
    #define F_SD8	2

    #ifdef TOP
        Local lHasRec
    #endif

    Local aSaldo  := { 0,0,0,0,0,0,0 }
    Local cArq    := Alias()
    Local nOrdD8  := 0
    Local nCnt01  := 0
    Local dDtVai  := NIL

    Local aFilial	 := { xFilial( "SB9" ), xFilial( "SD8" ) }
    Local nMultiplic := 1
    Local lSaldoIni  :=.T.
    Local nSizeFil   := 2

    Default cLoteFIFO    := CriaVar('D8_SEQ', .F.)
    Default lConsTesTerc := .F.
    Default lForcaSB9    := .F.

    If AliasInDic("SCC")
        dbSelectArea("SCC")
    Endif
    //Ŀ
    // Verifica a NAO utilizacao da tabela SCC referente ao fechamento Fifo 
    //
    If !(Findfunction("IsFechFifo") .And. IsFechFifo()) .Or. lForcaSB9

        If !(cFilAux == NIL)
            If FindFunction("FWSizeFilial")
                nSizeFil := FWSizeFilial()
            EndIf
            For nCnt01 := 1 To Len( aFilial )
                If !(aFilial[ nCnt01 ] == Space(nSizeFil))
                    aFilial[ nCnt01 ] := cFilAux
                EndIf
            Next
        EndIf

        If Empty(cLoteFIFO)
            //Ŀ
            // Ponto de partida para compor o saldo inicial.        
            //
            DbSelectArea( "SB9" )
            #ifndef TOP
                DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
            #else
                If TCSrvType() == "AS/400"
                    DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)
                Else
                    DbSeek( aFilial[ F_SB9 ]+cCod+cLocal,.F. )
                    lHasRec := .F.
                    While !Eof() .And. (aFilial[ F_SB9 ]+cCod+cLocal == B9_FILIAL+B9_COD+B9_LOCAL)
                        If (B9_DATA >= dData) .And. lHasRec
                            Exit
                        Else
                            lHasRec := .T.
                        EndIf
                        DbSkip()
                    End
                    If lHasRec
                        DbSkip(-1)
                    EndIf
                End
            #endif
        EndIf

        If Empty(cLoteFIFO) .And. ;
                ((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
                (SB9->B9_DATA < dData))

            If Empty(SB9->B9_DATA)
                lSaldoIni := .F.
            Else
                aSaldo[1] := SB9->B9_QINI
                aSaldo[2] := SB9->B9_VINIfF1
                aSaldo[3] := SB9->B9_VINIfF2
                aSaldo[4] := SB9->B9_VINIfF3
                aSaldo[5] := SB9->B9_VINIfF4
                aSaldo[6] := SB9->B9_VINIfF5
                aSaldo[7] := SB9->B9_QISEGUM
                dDtVai	  := SB9->B9_DATA+1
            EndIf
        Else
            lSaldoIni := .F.
            dDtVai	 := Ctod( "01/01/80","ddmmyy" )
        EndIf

        //Ŀ
        // Correr SD8 para	obter o saldo na Data desejada.  
        //
        DbSelectArea( "SD8" )
        nRecSD8:= Recno()
        nOrdD8 := IndexOrd()
        DbSetOrder( 4 )
        DbSeek( aFilial[ F_SD8 ]+cCod+cLocal)
        Do While (!Eof() .And.	(aFilial[ F_SD8 ]+cCod+cLocal) == (SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL))
            //Ŀ
            // Filtra movimentos com data anterior a saldo inicial
            //
            If lSaldoIni .And. SD8->D8_DATA < dDtVai .Or. ;
                    (!Empty(cLoteFIFO) .And. !(SD8->(D8_SEQ)==cLoteFIFO))
                DbSkip()
                Loop
            EndIf
            //Ŀ
            // Filtra movimentos com data posterior a data solicitada
            //
            If SD8->D8_DATA < dData .And. (SD8->D8_TIPONF # "E" .Or. (SD8->D8_TIPONF == "E" .And. !lSaldoIni))
                If SD8->D8_TM > "500"
                    nMultiplic:= -1
                Else
                    nMultiplic:= 1
                EndIf
                aSaldo[1] += (SD8->D8_QUANT  * nMultiplic)
                aSaldo[2] += (SD8->D8_CUSTO1 * nMultiplic)
                aSaldo[3] += (SD8->D8_CUSTO2 * nMultiplic)
                aSaldo[4] += (SD8->D8_CUSTO3 * nMultiplic)
                aSaldo[5] += (SD8->D8_CUSTO4 * nMultiplic)
                aSaldo[6] += (SD8->D8_CUSTO5 * nMultiplic)
                aSaldo[7] += (SD8->D8_QT2UM  * nMultiplic)
            EndIf
            DbSkip()
        End
        DbSetOrder( nOrdD8 )
        DbGoTo(nRecSD8)
        DbSelectArea( cArq )
    Else

        DbSelectArea( cArq )
        Return xCalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo)

    EndIf

Return( aSaldo )

				/*
				
				
				Ŀ
				Funo	 xCalcEstFF  Autor  Marcos V. Ferreira    Data  22.11.06 
				Ĵ
				Descrio  Retorna o Saldo Inicial por Produto/Local do arquivo SCC - 
							  Saldos Iniciais. (Custo FIfO) 							  
				Ĵ
				Sintaxe	  ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  
				Ĵ
				Parametros ExpC1 = Codigo do Produto								  
							  ExpC2 = Local (AlmoxarIfado)								  
							  ExpD1 = Data para obter o Saldo Inicial.					  
				           ExpC3 = Filial Auxiliar                                    
				           ExpL1 = Considera Tes Terceiros                            
				           ExpC4 = Lote FIFO                                          
				Ĵ
				 Uso		  SIGACUS													  
				ٱ
				
				
				*/
Function xCalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo)

    #ifdef F_SCC
        #undef F_SCC
    #endif

    #define F_SCC	1
    #define F_SD8	2

    #ifdef TOP
        Local lHasRec
    #endif

    Local aSaldo  := { 0,0,0,0,0,0,0 }
    Local cArq    := Alias()
    Local nOrdD8  := 0
    Local nCnt01  := 0
    Local dDtVai  := Ctod( "01/01/80","ddmmyy" )
    Local dDtIni  := Nil

    Local aFilial	 := { xFilial( "SCC" ), xFilial( "SD8" ) }
    Local nMultiplic := 1
    Local lSemLtFifo := Empty(cLoteFifo)
    Local nSizeFil   := 2

    Default cLoteFIFO    := CriaVar('D8_SEQ', .F.)
    Default lConsTesTerc := .F.

    If !(cFilAux == NIL)
        If FindFunction("FWSizeFilial")
            nSizeFil := FWSizeFilial()
        EndIf
        For nCnt01 := 1 To Len( aFilial )
            If !(aFilial[ nCnt01 ] == Space(nSizeFil))
                aFilial[ nCnt01 ] := cFilAux
            EndIf
        Next
    EndIf

    //Ŀ
    // Ponto de partida para compor o saldo inicial.        
    //
    dbSelectArea( "SCC" )
    If lSemLtFifo
        dbSetOrder( 1 ) //-- CC_PRODUTO+CC_LOCAL+CC_DATA
    Else
        dbSetOrder( 2 ) //-- CC_PRODUTO+CC_LOCAL+CC_SEQ+CC_DATA
    EndIf

    #ifndef TOP
        DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DtoS( dData ),.T. ) ; DbSkip(-1)
    #else
        If TCSrvType() == "AS/400"
            DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DtoS( dData ),.T. ) ; DbSkip(-1)
        Else
            DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo),.F. )
            lHasRec := .F.
            While !Eof() .And. (aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo) == CC_FILIAL+CC_PRODUTO+CC_LOCAL+IIf(lSemLtFifo,"",SCC->CC_SEQ))
                If (CC_DATA >= dData) .And. lHasRec
                    Exit
                Else
                    lHasRec := .T.
                EndIf
                DbSkip()
            End
            If lHasRec
                DbSkip(-1)
            EndIf
        End
    #endif

    //Ŀ
    // Busca Saldo Inicial                                
    //
    lHasRec:=.F. // Utiliza como sinalizador de leitura do SCC

    dDtIni := SCC->CC_DATA

    While !Bof() .And. DTOS(SCC->CC_DATA) <= DTOS(dData) .And. ;
            (aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DTOS(dDtIni) == ;
            SCC->CC_FILIAL+SCC->CC_PRODUTO+SCC->CC_LOCAL+IIf(lSemLtFifo,"",SCC->CC_SEQ)+DTOS(SCC->CC_DATA))
        lHasRec:=.T.
        aSaldo[1] += SCC->CC_QFIM
        aSaldo[2] += SCC->CC_VFIMFF1
        aSaldo[3] += SCC->CC_VFIMFF2
        aSaldo[4] += SCC->CC_VFIMFF3
        aSaldo[5] += SCC->CC_VFIMFF4
        aSaldo[6] += SCC->CC_VFIMFF5
        aSaldo[7] += SCC->CC_QFIM2UM
        dDtVai    := SCC->CC_DATA+1
        dbSkip(-1)
    End

    //Ŀ
    // Se nao leu nenhum registro na tabela SCC forcar a composicao |
    //| do saldo inicial atraves da metodologia anterior             |
    //
    If !lHasRec
        aSaldo:=CalcEstFF(cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo,.T.)
    Else
        //Ŀ
        // Correr SD8 para	obter o saldo na Data desejada.  
        //
        DbSelectArea( "SD8" )
        nRecSD8:= Recno()
        nOrdD8 := IndexOrd()
        DbSetOrder( 4 )
        DbSeek( aFilial[ F_SD8 ]+cCod+cLocal)
        Do While (!Eof() .And.	(aFilial[ F_SD8 ]+cCod+cLocal) == (SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL))
            //Ŀ
            // Filtra movimentos com data anterior a saldo inicial 
            //
            If SD8->D8_DATA < dDtVai .Or. SD8->D8_TIPONF == "E"
                DbSkip()
                Loop
            EndIf
            //Ŀ
            // Filtra movimentos que nao estao no lote informado   
            //
            If !Empty(cLoteFIFO) .And. !(SD8->(D8_SEQ)==cLoteFIFO)
                DbSkip()
                Loop
            EndIf

            //Ŀ
            // Filtra movimentos com data posterior a data solicitada
            //
            If SD8->D8_DATA < dData
                If SD8->D8_TM > "500"
                    nMultiplic:= -1
                Else
                    nMultiplic:= 1
                EndIf
                aSaldo[1] += (SD8->D8_QUANT  * nMultiplic)
                aSaldo[2] += (SD8->D8_CUSTO1 * nMultiplic)
                aSaldo[3] += (SD8->D8_CUSTO2 * nMultiplic)
                aSaldo[4] += (SD8->D8_CUSTO3 * nMultiplic)
                aSaldo[5] += (SD8->D8_CUSTO4 * nMultiplic)
                aSaldo[6] += (SD8->D8_CUSTO5 * nMultiplic)
                aSaldo[7] += (SD8->D8_QT2UM  * nMultiplic)
            EndIf
            DbSkip()
        End
        DbSetOrder( nOrdD8 )
        DbGoTo(nRecSD8)
    EndIf

    DbSelectArea( cArq )
Return( aSaldo )

				/*
				
				
				Ŀ
				Funo	 BlqInvent  Autor  Marcelo Pimentel       Data  27/01/98 
				Ĵ
				Descrio  Verifica se o produto esta sendo inventariado.			  
				Ĵ
				 Uso		  Generico 									              
				ٱ
				
				
				*/
Function BlqInvent(cCod,cLocal,dData,cLocaliz,nRecno)

    Local lBloq   := .F.
    Local aArea   := GetArea()
    Local aAreaSB2:= SB2->(GetArea())
    Local aAreaSBE:= SBE->(GetArea())
    Local aAreaSC9:= SC9->(GetArea())
    Local aAreaSDC:= SDC->(GetArea())
    Local nw      := 0
    Local aSDC    := {}
    Local cChave  := ""


    Local lAcd    := SuperGetMV("MV_INTACD",.F.,"0") == "1"


    DEFAULT dData   := dDataBase
    DEFAULT cLocal  := ""
    DEFAULT cLocaliz:= ""
    DEFAULT nRecno  := ""

    DbSelectArea("SB2")
    DbSetOrder(1)
    If MsSeek(xFilial("SB2")+cCod+cLocal)
        If !Empty(B2_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',(B2_DTINV <= dData .And. dData <= B2_DINVFIM),.T.)
            lBloq := .T.
        EndIf
    EndIf

    //--Efetua validacao integrado com ACD quando informa o endereco
    If lAcd .And. Localiza(cCod) .And. !Empty(cLocaliz)
        DbSelectArea("SBE")
        DbSetOrder(1)
        If DbSeek(xFilial("SBE")+cLocal+cLocaliz)
            If !Empty(BE_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',BE_DTINV <= dData,.T.)
                lBloq := .T.
            EndIf
        EndIf
    EndIf

    //--Efetua validacao integrado com ACD quando "NAO" informa o endereco(FATURAMENTO)
    If lAcd .And. Localiza(cCod) .And. !Empty(nRecno)
        dbSelectArea("SC9")
        dbSetOrder(1)
        MSGoto(nRecno)
        cChave:=(xFilial('SC9')+SC9->C9_PRODUTO+SC9->C9_LOCAL+"SC6"+SC9->C9_PEDIDO+SC9->C9_ITEM)
        DbSelectArea("SDC")
        dbSetOrder(1)
        If MSSeek(cChave)
            While cChave == SDC->DC_FILIAL+SDC->DC_PRODUTO+SDC->DC_LOCAL+SDC->DC_ORIGEM+SDC->DC_PEDIDO+SDC->DC_ITEM .And. !EoF()
                AADD(aSDC,SDC->DC_LOCALIZ)
                dbSkip()
            EndDo
            For nw:=1 to Len(aSDC)
                DbSelectArea("SBE")
                DbSetOrder(1)
                If DbSeek(xFilial("SBE")+SDC->DC_LOCAL+aSDC[nw])
                    If !Empty(BE_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',BE_DTINV <= dData,.T.)
                        lBloq := .T.
                        Help(" ",1,"BLQINVENT",,STR0106+aSDC[nw]+STR0107,1,5)
                    EndIf
                EndIf
            Next nw
        EndIf
    EndIf

    RestArea(aAreaSB2)
    RestArea(aAreaSBE)
    RestArea(aAreaSC9)
    RestArea(aAreaSDC)

    RestArea(aArea)
Return (lBloq)

				/*
				
				Ŀ
				Funo	  ASC2SLD	 Autor  Edson Maricate	     Data  02.02.98 
				Ĵ
				Descrio  Efetua o calculo do Saldo Real da Ordem de Producao.		  
				Ĵ
				Sintaxe	  ExpN1 = ASC2SLD(ExpC1)   								  
				       	  ExpN1 = Retorno do Saldo da OP                       	  
				       	  ExpC1 = Alias do arquivo da OP                       	  
				Ĵ
				 Uso		  ASC2SLD()												  
				ٱ
				
				
				*/
FUNCTION ASC2SLD(cAliasSQL)
    LOCAL nDecs := TamSX3("C2_QUANT")[2]
    LOCAL nSalop := NoRound(0, nDecs) // Forar valor zero com casa decimais do SX3
    LOCAL lPerdInf := SuperGetMV("MV_PERDINF",.F.,.F.)
    DEFAULT cAliasSQL := "SC2"
    If (cAliasSQL)->C2_DATRF == CTOD("  /  /   ")
        nSalop := Max(0,NoRound((cAliasSQL)->C2_QUANT - (cAliasSQL)->C2_QUJE - If(lPerdInf,0,(cAliasSQL)->C2_PERDA), nDecs))
    EndIf
Return nSalop

				/*/
    
    Ŀ
    Funo     InVerte   Autor  Wilson                 Data  17.02.98 
    Ĵ
    Descrio  Inverte qualquer campo.                                    
    Ĵ
    Sintaxe    ExpC1 = Inverte(ExpC2,ExpN1,ExpN2)                         
    Ĵ
    Parametros ExpC1 - Campo invertido (sempre caracter)                  
               ExpC2 - Campo a ser convertido                             
               ExpN1 - Tamanho do campo                                   
               ExpN2 - Numero de casas decimais                           
    Ĵ
     Uso       Generico                                                   
    ٱ
    
    
				/*/
Function Inverte(uCpo,nPos,nNumDec)
    Local cCpo	:= uCpo
    Local cRet	:= ""
    Local cByte	:= ""
    Local nAsc	:= 0
    Local nI		:= 0
    Local aChar	:= {}
    Local nDiv	:= 0

    nNumDec := IIF(nNumDec == Nil,0,nNumDec)

    Aadd(aChar,	{" ", "Z"})	// Asc(" ")=0  ->  Asc("Z")=90
    Aadd(aChar,	{"0", "Y"})
    Aadd(aChar,	{"1", "X"})
    Aadd(aChar,	{"2", "W"})
    Aadd(aChar,	{"3", "V"})
    Aadd(aChar,	{"4", "U"})
    Aadd(aChar,	{"5", "T"})
    Aadd(aChar,	{"6", "S"})
    Aadd(aChar,	{"7", "R"})
    Aadd(aChar,	{"8", "Q"})
    Aadd(aChar,	{"9", "P"})
    Aadd(aChar,	{"A", "O"})
    Aadd(aChar,	{"B", "N"})
    Aadd(aChar,	{"C", "M"})
    Aadd(aChar,	{"D", "L"})
    Aadd(aChar,	{"E", "K"})
    Aadd(aChar,	{"F", "J"})
    Aadd(aChar,	{"G", "I"})
    Aadd(aChar,	{"H", "H"})
    Aadd(aChar,	{"I", "G"})
    Aadd(aChar,	{"J", "F"})
    Aadd(aChar,	{"K", "E"})
    Aadd(aChar,	{"L", "D"})
    Aadd(aChar,	{"M", "C"})
    Aadd(aChar,	{"N", "B"})
    Aadd(aChar,	{"O", "A"})
    Aadd(aChar,	{"P", "9"})
    Aadd(aChar,	{"Q", "8"})
    Aadd(aChar,	{"R", "7"})
    Aadd(aChar,	{"S", "6"})
    Aadd(aChar,	{"T", "5"})
    Aadd(aChar,	{"U", "4"})
    Aadd(aChar,	{"V", "3"})
    Aadd(aChar,	{"W", "2"})
    Aadd(aChar,	{"X", "1"})
    Aadd(aChar,	{"Y", "0"})
    Aadd(aChar,	{"Z", "!"})	// Asc("Z")=90  ->  Asc("!")=33

    // Se for campo data, primeiro transforma em dtos
    If ValType(uCpo) == "D"
        cCpo := Dtos(uCpo)

    ElseIf ValType(uCpo) == "N"
        nPos := IIF(nPos == Nil,Len(uCpo),nPos)
        cCpo := StrZero(uCpo,nPos,nNumDec)
    EndIf

    nPos := IIF(nPos == Nil,Len(cCpo),nPos)

    For nI:= 1 to Len(cCpo)
        cByte := Upper(Subs(cCpo,nI,1))
        If (Asc(cByte) >= 48 .And. Asc(cByte) <= 57) .Or. ;	// 0 a 9
            (Asc(cByte) >= 65 .And. Asc(cByte) <= 90) .Or. ;	// A a Z
            Empty(cByte)	// " "
            nAsc	:= Ascan(aChar,{|x| x[1] == cByte})
            If nAsc > 0
                cRet := cRet + aChar[nAsc,2]	// Funcao Inverte e chamada pelo rdmake de conversao
            EndIf
        Else
            // Caracteres <> letras e numeros: mantem o caracter
            cRet := cRet + cByte
        EndIf
    Next
    If Len(cRet) > nPos
        cRet := Right(cRet,nPos)
    EndIf
Return(cRet)

				/*
				Obs.: Esta funcao perdeu a validade em 21/02/2000,
				por nao ser compativel com o ambiente Informix/Linux.
				As instalacoes com executaveis do Siga Quality
				a partir desta data, devem ser realizadas apos a
				execucao do conversor, para que os campos invertidos
				sejam regravados com a nova funcao, a partir do campo origem.

Function Inverte(uCpo,nPos)
				Local cCpo := uCpo, cRet := "", nByte , nDiv
    If ValType(uCpo) == "D"
					cCpo := Dtos(uCpo)
    ElseIf ValType(uCpo) == "N"
					nDiv := 1
					nByte := uCpo
        While nByte > 1
						nDiv++
						nByte := Round((nByte / 10),5)
        End
					cCpo := StrZero(uCpo,nDiv,0)
    EndIf
				nPos := Iif(nPos == Nil,Len(cCpo),nPos)
    For ni:= 1 to Len(cCpo)
					nByte := Asc(Subs(cCpo,ni,1))
        If  nByte > 0
						cRet += Chr(255-nByte)
        EndIf
    Next
    If Len(cRet) > nPos
					cRet := Right(cRet,nPos)
    EndIf
				Return cRet
				*/


				/*/
    
    
    Ŀ
    Funo	  SomaAbat  Autor  Eduardo Riera 		   Data  17.03.98 
    Ĵ
    Descrio  Soma todos os titulos de abatimento ate uma data limite	  
    Ĵ
    Sintaxe e  SomaAbat()																  
    Ĵ
    Parametros Prefixo,Numero,Parcela,Carteira,Moeda,Data,ClIfor,Loja	  
    Ĵ
     Uso		  Generico 																  
    ٱ
    
    
				/*/
Function SomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat,dDataRef,cTipo)
    #ifdef TOP
        Local cProcedure := IIF(FindFunction("GetSPName"), GetSPName("FIN001","08"), "FIN001") //'SUMABAT'
        Local aResult
        Default cTipo:= ""

        Default __lProcFIN001 := ExistProc ( cProcedure, VerIDProc2() )
        nMoeda :=Iif( nMoeda==NIL,1,nMoeda )
        dData  :=Iif( dData==NIL,dDataBase,dData )
        cFilAbat:=Iif( cFilAbat==NIL, Iif(cCart=="R",xFilial("SE1"),xFilial("SE2")), cFilAbat)
        cFornCli := If(cFornCli = Nil, If( cCart=="R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cFornCli)
        cLoja    := If(cLoja		= Nil, If( cCart=="R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
        dDataRef := Iif( dDataRef==NIL,dDataBase,dDataRef )
        cTipo	:=If(cTipo		= Nil, If( cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO), cTipo)

        If Funname()!="FINR340" .And. __lProcFIN001 .and. !Empty(cNumero) .and. ( TcSrvType() <> "AS/400" )
            aResult := TCSPEXEC(xProcedures(cProcedure), cPrefixo,;
                cNumero, cParcela, cCart,nMoeda,DTOS(dData),cFornCli,cLoja,cFilAbat,;
                DTOS(dDataRef),cTipo,'')
            Return aResult[1]
        Else
            Return xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)
        EndIf
Static Function xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)
#endif
Local nTotAbat := 0
Local cAlias   := Alias()
Local nOrdem   := indexord()
Local lUniao := .F.             // Utilizada para considerar titulos antigos, onde cliente era UNIAO
//controle de abatimento pelo titpai
Local lTitpaiSE1 := (SE1->(FieldPos("E1_TITPAI")) > 0 )
Local nOrdTitPai:=0
Local bWhile := {|| !Eof() .And. &cArea._FILIAL==cFilAbat .And. &cArea._PREFIXO=cPrefixo .And. &cArea._NUM==cNumero .and. &cArea._PARCELA==cParcela }

Default cTipo:= ""

cArea    := Iif(cCart="R","E1","E2")
nMoeda   := Iif( nMoeda==NIL,1,nMoeda )
dData    := Iif( dData==NIL,dDataBase,dData )
cFilAbat := Iif( cFilAbat==NIL, Iif(cCart=="R",xFilial("SE1"),xFilial("SE2")), cFilAbat)
cFornCli := If(cFornCli = Nil, If( cCart=="R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cFornCli)
cLoja    := If(cLoja		= Nil, If( cCart=="R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
cTipo	:=If(cTipo		= Nil, If( cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO), cTipo)
dDataRef := Iif( dDataRef==NIL,dDataBase,dDataRef )

If cCart == "R"
    If Select("__SE1") == 0
        ChkFile("SE1",.F.,"__SE1")
    Else
        DbSelectArea("__SE1")
    EndIf
ElseIf Select("__SE2") == 0
    ChkFile("SE2",.F.,"__SE2")
Else
    DbSelectArea("__SE2")
EndIf
DbSetOrder(1)
DbSeek(cFilAbat+cPrefixo+cNumero+cParcela)

If lTitpaiSE1 .AND. cCart == "R"
    If FindFunction("OrdTitpai") .and. (nOrdTitPai:= OrdTitpai()) > 0
        DbSetOrder(nOrdTitPai)
        If	DbSeek(cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja)
            bWhile := {|| !Eof() .And. Alltrim(cFilAbat+&cArea._TITPAI) ==  cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja }
        Else
            DbSetOrder(1)
            DbSeek(cFilAbat+cPrefixo+cNumero+cParcela)
        Endif
    Endif
Endif

While Eval(bWhile)
    If ( cCart == "R" )
        If ( cFornCli != Nil  )
            If E1_CLIENTE == "UNIAO "          //antigos
                lUniao := .T.
            EndIf
            If ( E1_CLIENTE != cFornCli ) .and. !lUniao
                DbSkip()
                Loop
            ElseIf ( cLoja != Nil )
                If ( E1_LOJA != cLoja ) .and. !lUniao
                    DbSkip()
                    Loop
                Elseif lTitpaiSE1
                    If !Empty(SE1->E1_TITPAI) .and. !lUniao .AND. (Alltrim(E1_TITPAI)!= Alltrim(cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja))
                        DbSkip()
                        Loop
                    EndIf
                EndIf
            EndIf
        EndIf
    EndIf
    If ( cCart == "P" )
        If ( cFornCli != Nil )
            If ( E2_FORNECE!=cFornCli )
                DbSkip()
                Loop
            ElseIf ( cLoja != Nil )
                If ( E2_LOJA != cLoja )
                    DbSkip()
                    Loop
                EndIf
            EndIf
        EndIf
    EndIf
    If ( (&cArea._TIPO $ MVABATIM .OR. IIF(funname()=="FINR340" ,&cArea._TIPO $ MVIRF,.F.) ) .And. &cArea._EMISSAO <= dDataRef )
        //----------------------------------------------------------------------
        // Validacao inserida para o processo de baixa parcial da Ordem de Pago
        // evitando que o titulo de abatimento seja descontado mais de uma vez
        //----------------------------------------------------------------------
        If &cArea._SALDO > 0 .Or. !(IsInCallStack("FINA085A") .Or. IsInCallStack("FINA850"))
            nTotAbat+=xMoeda(&cArea._VALOR,&cArea._MOEDA,nMoeda,dData,,If(cPaisLoc=="BRA",&cArea._TXMOEDA,0))
        EndIf
    EndIf
    dbSkip()
End
DbSelectArea(cAlias)
DbSetOrder(nOrdem)
Return(nTotAbat)

				/*
				
				
				Ŀ
				Funo	  SaldoI4	 Autor  Alessandro B. Freire   Data  26.03.98 
				Ĵ
				Descrio  Calcula o saldo atual de uma determinada conta at um deter
							  minado periodo utilizando o SI4 ao inves do SI1 			  
							  Obs.: Deve-se estar posicionado para utilizar esta funcao  
				Ĵ
				Sintaxe	  CalcSaldo(ExpN1)														  
				Ĵ
				Parametros Numero do Periodo, Moeda											  
				Ĵ
				 Uso		  Generico 																  
				ٱ
				
				
				*/
Function SaldoI4(nPer)

    Local nSaldo
    Local cAlias:= Alias()
    Local nOldSx3	:= Sx3->(recno())
    Local nOldOrd	:= Sx3->(indexord())
    Local nC

    DbSelectArea("SX3")
    DbSetOrder(2)

    DbSeek( "I4_SALANT" )
    nDecimais := X3_DECIMAL

    DbSetOrder(nOldOrd)
    DbGoTo(nOldSx3)

    DbSelectArea("SI4")
    DbSetOrder(1)

    nSaldo := I4_SALANT

    For nC=1 TO nPer

        cSuf	:= Strzero(nC,2)
        nSaldo:= nSaldo-I4_DEBM&cSuf+I4_CRDM&cSuf

    Next nC

    DbSelectArea(cAlias)
Return Round(nSaldo,nDecimais)

				/*
				
				Ŀ
				Funao	 E_RetField Autor  AVERAGE/MJBARROS 	   Data  19.03.98 
				Ĵ
				Descriao Retorna a descricao de campos chave de cadastro. Funcao que 
							 complementa a RetField do Siga a fim de economizar espaco e 
							 caber no campo X3_Relacao											  
				Ĵ
				Sintaxe e  .................... 												  
				Ĵ
				Parametros ................................... 							  
				Ĵ
				Uso		  SIGAEIC-Somente para versao Windows - Importacao			  
				ٱ
				
				*/
Function E_Field(cChave,cCampoDesc,cOrigem,lChave,nOrder)

    Local nPos := At("_",cCampoDesc)
    Local cArea:= If(nPos>3,Left(cCampoDesc,3),"S"+Left(cCampoDesc,2))
    Local nRec := (cArea)->(RecNo())
    Local nOrd := (cArea)->(IndexOrd())
    Local bDesc:= FieldWBlock(cCampoDesc,Select(cArea))
    Local bVar, cAreaAux
    Local cRet := ""
    Local cChvLoja:= ""
    Begin Sequence

        nPos:=AT("_",cChave)
        cAreaAux:=If(nPos>3,Left(cChave,3),"S"+Left(cChave,2))

        nOrder:=Iif(nOrder==Nil,1,nOrder)
        lChave:=Iif(lChave==Nil,.F.,lChave)
        cOrigem:=Iif(cOrigem==Nil,"G",cOrigem)

        If bDesc = NIL
            MsgStop("Campo "+cCampoDesc+" nao encontrado para o arquivo "+cArea,"Ateno")
            Break
        EndIf

        If (nModulo == 17 .Or. nModulo == 29) .And. EicLoja() .And. AllTrim(cAreaAux) == "SA5"

            If cChave == "A5_FORNECE"
                cChvLoja:= "A5_LOJA"
            ElseIf cChave == "A5_FABR"
                cChvLoja:= "A5_FALOJA"
            EndIf

            If TYPE("M->"+cChave) == "U"
                cRet:= If(!INCLUI,Posicione("SA2",1,xFilial("SA2")+SA5->(&cChave+&cChvLoja),cCampoDesc)," ")
            Else
                cRet:= If(!INCLUI,Posicione("SA2",1,xFilial("SA2")+M->(&cChave+&cChvLoja),cCampoDesc)," ")
            EndIf


            Break
        EndIf

        If cOrigem = "G" // Gatilho/Enchoice  ou Browse se For U
            If TYPE("M->"+cChave) != "U"
                bVar := MemVarBlock(cChave)
                cChave:=Eval(bVar)
            Else
                cChave:= Eval(FieldWBlock(cChave,Select(cAreaAux)))
            EndIf
        Else
            // Browse
            cChave:=Eval(FieldWBlock(cChave,Select(cAreaAux)))
        EndIf

        If Empty(cChave)
            Break
        EndIf

        (cArea)->(DbSetOrder(nOrder))
        (cArea)->(DbSeek(xFilial()+cChave))
        cCampoDesc:=Eval(bDesc)

        If nRec > 0
            (cArea)->(DbGoTo(nRec))
            (cArea)->(DbSetOrder(nOrd))
        EndIf

        cRet := If(!lChave,cCampoDesc,cChave+" "+cCampoDesc)
    End Sequence

Return cRet

				/*
				
				Ŀ
				Funo	  EspOrder 	 Autor  Ana Claudia		   Data  23/06/98 
				Ĵ
				Descrio  Substitui a funcao DbSetOrder() devido a fusao dos Sistemas
							 EspecIficos e Padrao, evitando problemas no acesso ao Sindex
							  - Esta funcao deve ser usada apenas nos programas proprios.
							  Para o padrao permanece os mesmos indices 					  
				Ĵ
				Sintaxe	  EspOrder(ExpC1,ExpN2)												  
				Ĵ
				Parametros ExpC1 = Alias a ser colocada a ordem							  
							  ExpN2 = Ordem da Shell												  
				Ĵ
				 Uso		  Generico 																  
				ٱ
				
				
				*/
Function EspOrder(cAlias,nOrdem)
    Local nIndice := 1, nAT
    Local cText

    If Len( __aCache ) == 0
        cText := ' *****  W a r n i n g  ***** ' + CRLF
        cText += ' Function ESPORDER' + CRLF
        cText += ' This function is accepted only for compatibility with old versions.' + CRLF
        cText += ' Please Change to Nickname in index.' + CRLF
        ConOut( cText )
    EndIf

    cAlias := If(cAlias==NIL,Alias(),cAlias)
    nOrdem := If(nOrdem==NIL,1,nOrdem)

    If ( nAt:= ASCAN(__aCache, { |x| x[1] == cAlias+StrZero(nOrdem,2,0) } ) ) > 0
        dbSetOrder(__aCache[nAT,2])
        Return .t.
    EndIf

    nAT:=1
    If SIX->(DbSeek(cAlias))
        While ! SIX->(Eof()) .and. SIX->INDICE == cAlias
            If SIX->PROPRI == "T"   // T serve de exemplo pq e maior que S
                // usado no SIX->PROPRI
                If nOrdem == nIndice
                    If Empty(Val(SIX->ORDEM))
                        (cAlias)->( DbSetOrder(Asc(SIX->ORDEM)-55))
                        nAT := Asc(SIX->ORDEM)-55
                    Else
                        (cAlias)->( DbSetOrder(Val(SIX->ORDEM)) )
                        nAT := Val(SIX->ORDEM)
                    EndIf
                    Exit
                EndIf
                nIndice ++
            EndIf
            SIX->(DbSkip())

        End
    EndIf
    AADD(__aCache,{cAlias+StrZero(nOrdem,2,0),nAT})
Return .T.

				/*
				
				Ŀ
				Funo	  BuildStrFil  Autor  Wilson Jr. 		   Data  08.07.98 
				Ĵ
				Descrio  Retorna a xFilial dos arquivos que serao usados na chamada 
							  da stored procedure													  
				Ĵ
				Sintaxe	  BuildStrFil(cString) 												  
				Ĵ
				Parametros 																			  
				Ĵ
				 Uso		  Generico 																  
				ٱ
				
				
				*/
Function BuildStrFil(cString)
    Local cRet,cStr,ni
    Local nSizeFil := 2

    If cString == Nil
        cString := Alias()
    EndIf
    cString := Upper(cString)
    cRet := ""
    cStr := ""

    If FindFunction("FWSizeFilial")
        nSizeFil := FWSizeFilial()
    EndIf

    For ni:= 1 to Len(cString)
        If Subs(cString,ni,1) == ","
            cRet += FWModeAccess(cStr,3)
            cStr := ""
        Else
            cStr += Subs(cString,ni,1)
        EndIf
    Next
    If !Empty(cStr)
        cRet += FWModeAccess(cStr,3)
    EndIf

Return cRet

				/*
				
				Ŀ
				Funo	  xProcedures  Autor  Vicente Sementilli  Data  27.07.98 
				Ĵ
				Descrio  Para cada Empresa existira uma Stored Procedure. Portanto  
							  esta rotina recebe o nome da Stored Procedure e concatena  
							  a empresa corrente ao nome (<nome>+_+<empresa>))			  
							  Ex. SP_01																  
				Ĵ
				Sintaxe	  ExpA1 := xProcedures(ExpC1)										  
				Ĵ
				Parametros ExpA1 = String com o nome concatenado com a Empresa.		  
							  ExpC1 = String com o nome da Procedure 						  
				Ĵ
				 Uso		  Generico 																  
				ٱ
				
				
				*/
Function xProcedures (cProcedure)

    #IFDEF TOP
        Local cUnion := If( (TCSrvType() == "AS/400"),"F","_")
    #ELSE
        Local cUnion := "_"
    #ENDIF

    cProcedure := iif(cProcedure = nil, 'NENHUMA', Upper(cProcedure+cUnion+cEmpAnt) )

Return (cProcedure)

				/*/
    
    
    Ŀ
     Funo	  RetTitle   Autor  Pilar Sanchez Albalade Data  02/06/98 
    Ĵ
     Descrio  Retorna o titulo do campo cadastrado no SX3.					
    Ĵ
     Sintaxe    RetTitle																	
    Ĵ
     Uso		   SIGACON																	   
    ٱ
    
    
				/*/
Function RetTitle(cCampo,nTamanho,lRestSX3)
    Local cAlias	 := Alias()
    Local nSx3Order  := SX3->(IndexOrd())
    Local cTitulo	 := " "
    Local aArea		:=	SX3->(GetArea())
    DEFAULT lRestSX3	:=	.F.

    DbSelectArea("SX3")
    DbSetOrder(2)

    If ( MSSeek(cCampo) )
        cTitulo := X3Titulo()+Space(50)
    EndIf
    nTamanho := Iif(nTamanho == Nil,Len(X3Titulo()),nTamanho)
    cTitulo := Substr(cTitulo,1,nTamanho)
    If lRestSX3
        RestArea(aArea)
    Else
        DbSetOrder(nSX3Order)
    Endif
    DbSelectArea(cAlias)
    cTitulo := OemToAnsi(cTitulo)

Return cTitulo

				/*/
    
    
    Ŀ
     Funo			ValorContab Autor  Pilar S. Albaladejo		  Data  23/09/98 
    Ĵ
     Descrio  Imprime saldos contabeis com sinal de acordo com parametro 
    Ĵ
     Sintaxe    ValorContab(nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal, 	
    			   lEstrang,cTipo,cConta) 												
    			   Onde:																		
    			   nSaldo	= Valor a ser impresso										
    			   nLin 	= Linha onde sera impresso 								
    			   nCol 	= Coluna onde sera impresso								
    			   nTamanho= Tamanho maximo disponivel para impressao				
    			   nDecimais = Numero de decimais a serem impressas				
    			   lSinal	= Valor sera impresso com sinal ou nao (Os sinais	
    			  			  poderao ser D/C ou - ou ()								
    			   lEstrang= Considera ou nao picture de lingua estrangeira	
    			   cTipo	= Indica se o tipo de dado sera D/C (quando nao 	
    			  			  existe registro para identIfica-lo=final de arqui
    			  			  vo e impressao dos totais -> devera ser usado 	
    			  			  somente com lSinal = .F. 																					 
    			   cConta	= Indica o deve posicionar registro no SI1			
    Ĵ
     Uso				 SIGACON																																												 
    ٱ
    
    
				/*/
Function ValorContab( nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal,lEstrang,cTipo,cConta)

    Local cOldAlias := ALIAS()
    Local nReg
    Local nOrder := SI1->(IndexOrd())
    Local nCol1
    Local cPict

    //Ŀ
    // VerIfica se os tamanhos foram passados ou encontrados		  
    //
    If nTamanho == Nil
        nTamanho 		 := 14
        nDecimais		 := 2
    EndIf

    nSaldo			 := Iif(nSaldo == NIl, 0, nSaldo)
    lEstrang 					:= Iif(lEstrang == Nil, .F., lEstrang)
    cTipo 			 := Iif(cTipo==Nil, Space(1), cTipo)

    DbSelectArea("SI1")
    DbSetOrder(1)
    nReg := Recno()

    If !Empty(cConta)
        DbSeek(cFilial+cConta)
    EndIf

    //Ŀ
    // Tipo D -> Default (D/C)												  
    // Tipo S -> Imprime saldo com sinal									  
    // Tipo P -> Imprime saldo entre parenteses (qdo. negativo)	  
    //
    cTipoSinal := GetMV("MV_TPVALOR")       // Assume valor default

    //Ŀ
    // Retorna a picture. Caso nao exista espaco, retira os pontos  
    // separadores de dezenas, centenas e milhares 					  
    //
    cPicture := TmContab(nSaldo,nTamanho,nDecimais)

    //Ŀ
    //* Alguns valores, apesar de  terem sinal devem ser impressos  
    // sem sinal (lSinal). Ex: valores de colunas Debito e Credito  
    //* Se estiver com a opcao de lingua estrangeira (lEstrang) a   
    // picture sera invertida para exibir valores: 999,999,999.99   
    //* O tipo de sinal "D" - default nao leva em consideracao a    
    // a natureza da conta. Dessa forma valores negativos serao	  
    // impressos sem sinal, e ao seu lado "D" (Devedor) e valores   
    // positivos terao um "C" (Credito) impresso ao seu lado.       
    //* O tipo de Sinal "P" - Parenteses, imprimira valores de saldo
    //  invertidos da condicao normal da conta entre parenteses.	  
    //* O tipo de Sinal "S" - Sinal, imprimira valores de saldo in- 
    //  vertidos da condicao normal da conta com sinal - 			  
    //OBS: Se a conta for ANORMAL (I1_ESTOUR == "S"), os sinais se- 
    //rao invertidos.															  
    //EXEMPLOS  -  EXEMPLOS  -  EXEMPLOS	-	EXEMPLOS  - EXEMPLOS   
    //Cond Normal 			Saldo 			 Default 		  Sinal				Parenteses					  
    //	  D			  -1000	  1000 D 		1000		1000				 
    //	D				 1000 	1000 C		-1000 	(1000)			  
    //	C				-1000 	1000 D		-1000 	(1000)			  
    //	C				 1000 	1000 C		 1000 	 1000 			  
    //CONTA "ANORMAL" ou "REDUTORA"                                 
    //Cond Normal 	Saldo 	Default		Sinal 	Parenteses		  
    //  D				-1000 		  1000 D 	  -1000	  (1000) 			 
    //  D				 1000 	1000 C		 1000 	 1000 			  
    //  C				-1000 	1000 D		 1000 	 1000 			  
    //  C				 1000 	1000 C		-1000 	(1000)			  
    //

    //Ŀ
    // Neste caso (Default), nao importa a natureza da conta! Saldos
    // devedores serao impressos com "D" e credores com "C".        
    //
    // Neste caso, nao importa a natureza da conta!!
    If cTipoSinal == "D"                                    //      DC (Default)
        If !lEstrang
            cPict := "@E " + cPicture
        Else
            cPict		:= cPicture
        EndIf
        @ nLin, nCol pSay Abs(nSaldo) Picture cPict
        nCol1 := nCol + Len(cPicture) + 1
        If lSinal
            If nSaldo < 0
                @ nLin, nCol1 pSay "D"
            ElseIf nSaldo > 0
                @ nLin, nCol1 pSay "C"
            EndIf
        EndIf
    Else
        If SI1->I1_ESTOUR != "S"
            If cTipo == "D" .Or. SI1->I1_NORMAL == "D"                      // Conta Devedora
                If (cTipoSinal) == "S"                  //      Sinal
                    If lSinal
                        nSaldo := nSaldo * (-1)
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If lSinal
                        nSaldo := nSaldo * (-1) 		  // a Picture so exibe parenteses para numeros negativos
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            ElseIf cTipo == "C" .Or. SI1->I1_NORMAL == "C"          // Conta Credora
                If (cTipoSinal) == "S"                  //      Sinal
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            EndIf
        ElseIf SI1->I1_ESTOUR == "S"                    // CONTA REDUTORA
            If cTipo == "D" .Or. SI1->I1_NORMAL == "D"                      // Conta Devedora
                If (cTipoSinal) == "S"                  //      Sinal
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If !lSinal
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            ElseIf cTipo == "C" .Or. SI1->I1_NORMAL == "C"          // Conta Credora
                If (cTipoSinal) == "S"                  //      Sinal
                    If lSinal
                        nSaldo := nSaldo * (-1)
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E " + cPicture
                    EndIf
                    @ nLin, nCol PSAY nSaldo Picture cPicture
                ElseIf (cTipoSinal) == "P"              //      Parenteses
                    If lSinal
                        nSaldo := nSaldo * (-1)
                    Else
                        nSaldo := Abs(nSaldo)
                    EndIf
                    If !lEstrang
                        cPicture := "@E( " + cPicture
                    Else
                        cPicture := "@( " + cPicture
                    EndIf
                    @ nLin, nCol pSay nSaldo Picture cPicture
                EndIf
            EndIf
        EndIf
    EndIf

    DbSelectArea("SI1")
    DbGoTo(nReg)
    DbSetOrder(nOrder)

    DbSelectArea( cOldAlias )

Return

				/*/
    
    
    Ŀ
     Funo	  TmContab   Autor  Pilar S. Albaladejo	 Data  23/09/98 
    Ĵ
     Descrio  Retorna a picture a ser impressa e corta pontos se nao ti- 
    			   ver espaco 																
    Ĵ
     Sintaxe    TmContab(cCampo,nTamanho,nDecimais)								
    			   Onde:																		
    			   cCampo	= Campo a ser impresso										
    			   nTamanho= Tamanho maximo disponivel para impressao			
    			   nDecimais = Numero de decimais a serem impressas				
    Ĵ
     Uso		   SIGACON 																	
    ٱ
    
    
				/*/
Function TMContab(cCampo,nTamanho,nDecimais)

    Local cCpo

    nDecimais:= Iif(nDecimais==Nil,GetMv("MV_CENT"),nDecimais)

    cDecimais:= Iif(nDecimais==0,"","."+Replicate("9",nDecimais))
    cPicture := Iif(GetMv("MV_MILHAR"),"999,999,999,999,999",;
        "999999999999999")+cDecimais
    cCpo	:= Transform(cCampo,cPicture)

    //Ŀ
    // VerIfica se ha tamanho suficiente para imprimir. Se nao 	  
    // existir tamanho suficiente, serao cortados pontos e virgulas 
    // para caber.																  
    //
    While  (Len(AllTrim(cCpo)) > nTamanho ) .And. ( AT(",",cPicture) > 0 )
        cPicture := Substr(cPicture,1,AT(",",cPicture)-1)+;
            Substr(cPicture,AT(",",cPicture)+1,20)
        cCpo	:= (Transform(cCampo,cPicture))
    End

    cPicture 		 :=		Right(cPicture,nTamanho)
    cPicture 		 :=		Iif(Substr(cPicture,1,1)=',',"9"+Substr(cPicture,2),cPicture)
    If Len(LTrim(cCpo)) > nTamanho
        cPicture 		 :=		""+Substr(cPicture,2,20)
    EndIf

Return cPicture

				/*
				
				
				Ŀ
				Funo	 fDesc 	 Autor Mauro(1a. Versao)	     Data 14/10/1998
				                	 Autor Marinaldo(2a.Versao)    Data 03/04/2003
				Ĵ
				Descrio Funcao para Trazer a Descricao/Conteudo de Campos			  
				Ĵ
				Sintaxe	 <Vide Parametros Formais >								  
				Ĵ
				Uso		 Genrico 												  	  
				ٱ
				
				*/
Function fDesc( cAlias , cChave , cCampoRet , nBytes , cFil , nOrder , lPosSx3 )

				Local cAliasfDesc	:= ""
				Local cFieldFil		:= ""
				Local cContextFil	:= ""
				Local lChkBytes		:= ( ValType( nBytes ) == "N" )
				Local lChkOrder		:= ( ValType( nOrder ) == "N" )
				Local lChkSX5		:= ( SubStr( cAlias , 1 , 1 ) == "X" )
				Local lIsChar		:= .F.
				Local lFound		:= .F.
				Local nSvOrder		:= 1
				Local nSx3Rec		:= 0
				Local uRet			:= NIL

				DEFAULT lPosSx3		:= .T.

    IF ( lChkSX5 )
					cAliasfDesc := "SX5"
    Else
					cAliasfDesc := cAlias
    EndIF

				cFieldFil	:= ( PrefixoCpo( cAliasfDesc ) + "_FILIAL" )
    IF ( lPosSx3 )
					nSx3Rec		:= SX3->( Recno() )
    EndIF
				cContextFil	:= GetSx3Cache( cFieldFil , "X3_CONTEXT" )
    IF ( lPosSx3 )
					SX3->( MsGoto( nSx3Rec ) )
    EndIF
    IF ( ( cContextFil <> NIL ) .and. !( cContextFil $ "Vv" ) )
					cFil := xFilial( cAliasfDesc , cFil )
    Else
					cFil := ""
    EndIF

    IF ( lChkOrder )
					nSvOrder := ( cAliasfDesc )->( IndexOrd() )
					( cAliasfDesc )->( dbSetOrder( nOrder ) )
    EndIF

				lFound	:= ( cAliasfDesc )->( MsSeek( cFil + cChave , .F. ) )
				uRet 	:= ( cAliasfDesc )->( &( cCampoRet ) )
				lIsChar	:= ( ValType( uRet ) == "C" )
    IF ( ( lChkBytes ) .and. ( lIsChar ) )
					uRet := SubStr( uRet , 1 , nBytes )
    ElseIF ( !( lFound ) .and. ( lIsChar ) )
					/*
					10        20
					12345678901234567890
					*/
        uRet := "                    "
    EndIF

    IF ( ( lChkOrder ) .and. !( nSvOrder == nOrder ) )
        ( cAliasfDesc )->( dbSetOrder( nSvOrder ) )
    EndIF

Return( uRet )

				/*/
    
    Ŀ
    Funo	 CriaCtaSup Autor  Pilar S. Albaladejo    Data  23/03/98 
    Ĵ
    Descrio Gera a conta pai da conta atual									  
    Ĵ
     Uso		  Generico 																  
    ٱ
    
    
				/*/
Function CriaCtaSup(cCodigo)

    Local cCod
    Local cAlias	 := Alias()
    Local nOrder	 := IndexOrd()
    Local nReg					:= Recno()
    Local nCont     := 0

    cCodigo						:= AllTrim(cCodigo)
    DbSelectArea("SI1")
    DbSetOrder(1)

    For nCont := 1 to Len(cCodigo)
        cCod	  := Substr(cCodigo,1,Len(cCodigo)-nCont)
        cCod	:= cCod + Space(20-Len(cCod))
        If DbSeek(xFilial()+cCod,.f.)
            Exit
        EndIf
    Next nCont

    DbSelectArea(cAlias)
    DbSetOrder(nOrder)
    DbGoTo(nReg)
Return cCod

				/*/
    
    Ŀ
    Funo	 HeadCnab2  Autor  Eduardo Riera 		  		 16/04/98 
    Ĵ
    Descrio Cria o Arquivo padrao Cnab Modelo 2								  
    Ĵ
    Sintaxe	 HeadCnab2 ( cArquivo, cLayOut )									  
    Ĵ
    Parametro  ExpC1 : Nome do arquivo a ser gerado							  
    			  ExpC2 : Nome do arquivo de configuracao						  
    Ĵ
    Retorno	  Handle do arquivo gerado.											  
    Ĵ
     Uso		  GENERICO 																  
    ٱ
    
    
				/*/

Function HeadCnab2(cArquivo,cLayOut)

    Local nHandle	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := ""
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHandle := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHandle,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,3,1) == "H" )
                        aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,30),;
                            SubStr(cBuffer,35,255)})
                    EndIf
                Else
                    If ( SubStr(cBuffer,3,1) == "H" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHandle)
    EndIf
    nHandle := FCreate(cArquivo)
    If nHandle > 0
        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(AllTrim(aLayOut[nCntFor,3]))
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
                    cBuffer := ""
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                        EndIf
                    Next nCntFor2
                    cBuffer += Chr(13)+Chr(10)
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                EndIf
            End Sequence
        Next nCntFor
        ErrorBlock(bBlock)
    Endif
Return(nHandle)

				/*/
    
    Ŀ
    Funo	 HeadLote2  Autor  Claudio Donizete		  		 27/12/05 
    Ĵ
    Descrio Cria Header do lote de registro no arq Cnab Modelo 2		  
    Ĵ
    Sintaxe	 HeadLote2 ( nHdlSaida, cLayOut )									  
    Ĵ
    Parametro  ExpN1 : Handle do arquivo de saida								  
    			  ExpC2 : Nome do arquivo de configuracao						  
    Ĵ
    Retorno	  Handle do arquivo gerado.											  
    Ĵ
     Uso		  GENERICO 																  
    ٱ
    
    
				/*/

Function HeadLote2(nHdlSaida,cLayOut)

    Local nHdlLay	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := ""
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,2,1)=="1" )
                        If ( SubStr(cBuffer,3,1) == "H" )
                            aadd(aLayOut, {SubStr(cBuffer,02,03), SubStr(cBuffer,05,30), SubStr(cBuffer,35,255) } )
                        EndIf
                    Endif
                Else
                    If ( SubStr(cBuffer,3,1) == "H" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    For nCntFor := 1 To Len(aLayOut)
        Begin Sequence
            lFormula := &(AllTrim(aLayOut[nCntFor,3]))
            If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
                cBuffer := ""
                For nCntFor2 := 1 To Len(aDetalhe)
                    If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                        xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
                        If ( Empty(xConteudo) )
                            xConteudo := ""
                        Else
                            xConteudo := &(AllTrim(xConteudo))
                        EndIf
                        nPosIni   := Val(aDetalhe[nCntFor2,3])
                        nPosFim   := Val(aDetalhe[nCntFor2,4])
                        nDecimal  := Val(aDetalhe[nCntFor2,5])
                        nTamanho  := nPosFim-nPosIni+1
                        Do Case
                        Case ValType(xConteudo) == "D"
                            xConteudo := GravaData(xConteudo,.F.)
                        Case ValType(xConteudo) == "N"
                            xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                        EndCase
                        xConteudo := SubStr(xConteudo,1,nTamanho)
                        xConteudo := PadR(xConteudo,nTamanho)
                        cBuffer += xConteudo
                    EndIf
                Next nCntFor2
                cBuffer += Chr(13)+Chr(10)
                Fwrite(nHdlSaida,cBuffer,Len(cBuffer))
            EndIf
        End Sequence
    Next nCntFor
    ErrorBlock(bBlock)
Return(nHdlSaida)

				/*/
    
    Ŀ
    Funo	 DetCnab2	 Autor  Eduardo Riera 		  		 16/04/98 
    Ĵ
    Descrio Inseri as linhas de detalhe do CNAB Modelo 2. 				  
    Ĵ
    Sintaxe	 DetCnab2( nHandle , cLayOut )										  
    Ĵ
    Parametro  ExpC1 : Handle do Arquivo Criado pela HeadCnab2 			  
    			  ExpC2 : Nome do arquivo de configuracao						  
    Ĵ
    Retorno	  Void																		  
    Ĵ
     Uso		  GENERICO 																  
    ٱ
    
    
				/*/
Function DetCnab2(nHandle,cLayOut,lIdCnab,cAlias)

    Local nHdlLay	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := ""
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )
    Local aGetArea  := GetArea()
    Local cIdCnab
    Local aArea
    Local nOrdem

    DEFAULT cAlias 	:= ""
    DEFAULT lIdCnab 	:= .F.
    Private xConteudo := ""

    nQtdLinLote := If(Type("nQtdLinLote") != "N",0,nQtdLinLote)

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,3,1) == "D" )
                        aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,30),;
                            SubStr(cBuffer,35,255)})
                    EndIf
                Else
                    If ( SubStr(cBuffer,3,1) == "D" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    If nHandle > 0
        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(AllTrim(aLayOut[nCntFor,3]))
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="D" )
                    cBuffer := ""
                    // So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
                    If !Empty(cAlias) .And. lIdCnab .And. Empty((cAlias)->&(Right(cAlias,2)+"_IDCNAB"))
                        // Gera identificador do registro CNAB no titulo enviado
                        nOrdem := If(Alltrim(Upper(cAlias))=="SE1",16,11)
                        cIdCnab := GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
                        // Garante que o identificador gerado nao existe na base
                        dbSelectArea(cAlias)
                        aArea := (cAlias)->(GetArea())
                        dbSetOrder(nOrdem)
                        While (cAlias)->(MsSeek(xFilial(cAlias)+cIdCnab))
                            ConOut("Id CNAB " + cIdCnab + " j existe para o arquivo " + cAlias + ". Gerando novo nmero ")
                            If ( __lSx8 )
                                ConfirmSX8()
                            EndIf
                            cIdCnab := GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
                        EndDo
                        (cAlias)->(RestArea(aArea))
                        Reclock(cAlias)
                        (cAlias)->&(Right(cAlias,2)+"_IDCNAB") := cIdCnab
                        MsUnlock()
                        ConfirmSx8()
                        lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no
                        // titulo enviado
                    Endif
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := aDetalhe[nCntFor2,6]
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                        EndIf
                    Next nCntFor2
                    cBuffer += Chr(13)+Chr(10)
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                    nQtdLinLote++
                EndIf
            End Sequence
        Next nCntFor
        ErrorBlock(bBlock)
    Endif
    RestArea(aGetArea)
Return(.T.)

				/*/
    
    Ŀ
    Funo	 RodaCnab2  Autor  Eduardo Riera 		  		 16/04/98
    Ĵ
    Descrio Fecha o arquivo CNAB Modelo 2								  
    Ĵ
    Sintaxe	 RodaCnab2( nHandle , cLayOut ) 							  
    Ĵ
    Parametro  ExpC1 : Handle do Arquivo Criado pela HeadCnab2 			  
    			  ExpC2 : Nome do arquivo de configuracao					  
    Ĵ
    Retorno	  Void														  
    Ĵ
     Uso		  GENERICO 												  
    ٱ
    
    
				/*/
Function RodaCnab2(nHandle,cLayOut,lQuebra)

    Local nHdlLay	:= 0
    Local lContinua	:= .T.
    Local cBuffer	:= ""
    Local aLayOut	:= {}
    Local aDetalhe  := {}
    Local nCntFor	:= 0
    Local nCntFor2  := 0
    Local lFormula  := .F.
    Local nPosIni	:= 0
    Local nPosFim	:= 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	:= ErrorBlock()
    Local bErro 	:= ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    //-- Variaveis para tratamento de geracao de Chr(10) + Chr(13) para ultima linha gerada
    Local nLHead 	:= nCntFor
    Local nLDet		:= nCntFor2
    Local nLUltLin	:= nCntFor2

    //-- Determina se gera Chr(10) + Chr(13) para as linhas geradas
    DEFAULT	lQuebra	:= .T.

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,3,1) == "T" )
                        aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,30),;
                            SubStr(cBuffer,35,255)})

                    EndIf
                Else
                    If ( SubStr(cBuffer,3,1)=="T" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    aSort(aLayOut,,,{|x,y| x[1]>y[1]})
    If nHandle > 0

        //-- Obtem a ultima posicao da linha gerada no arquivo
        IF !lQuebra
            For nCntFor := 1 To Len(aLayOut)
                Begin Sequence
                    lFormula := &(aLayOut[nCntFor,3])
                    If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
                        cBuffer := ""
                        For nCntFor2 := 1 To Len(aDetalhe)
                            If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                                xConteudo := (aDetalhe[nCntFor2,6])
                                If ( Empty(xConteudo) )
                                    xConteudo := ""
                                Else
                                    xConteudo := &(AllTrim(xConteudo))
                                EndIf
                                nPosIni   := Val(aDetalhe[nCntFor2,3])
                                nPosFim   := Val(aDetalhe[nCntFor2,4])
                                nDecimal  := Val(aDetalhe[nCntFor2,5])
                                nTamanho  := nPosFim-nPosIni+1
                                Do Case
                                Case ValType(xConteudo) == "D"
                                    xConteudo := GravaData(xConteudo,.F.)
                                Case ValType(xConteudo) == "N"
                                    xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                                EndCase
                                xConteudo := SubStr(xConteudo,1,nTamanho)
                                xConteudo := PadR(xConteudo,nTamanho)
                                cBuffer += xConteudo
                                //- Obtem a ultima posicao da linha gerada no arquivo
                                nLDet	:= nCntFor2
                                nLHead 	:= nCntFor
                            EndIf
                        Next nCntFor2

                    EndIf
                End Sequence
            Next nCntFor
        Endif

        nLUltLin:= 0

        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(aLayOut[nCntFor,3])
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
                    cBuffer := ""
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := (aDetalhe[nCntFor2,6])
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                            nLUltLin:= nCntFor2
                        EndIf

                    Next nCntFor2

                    //-- Gera Chr(13)+Chr(10) para todas as linhas ou para as N-1 linhas
                    If ( lQuebra ) .OR. ( !lQuebra .AND. !( (nLUltLin == nLDet) .and. (nCntFor == nLHead)) )
                        cBuffer += Chr(13)+Chr(10)
                    EndIf
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                EndIf
            End Sequence
        Next nCntFor

        ErrorBlock(bBlock)
        FClose(nHandle)
    Endif
Return(.T.)

				/*/
    
    Ŀ
    Funo	 RodaLote2  Autor  Claudio Donizete 	  		 27/12/05 
    Ĵ
    Descrio Gera Trailler de Lote CNAB Modelo 2								  
    Ĵ
    Sintaxe	 RodaLote2( nHandle , cLayOut ) 									  
    Ĵ
    Parametro  ExpC1 : Handle do Arquivo Criado pela HeadCnab2 			  
    			  ExpC2 : Nome do arquivo de configuracao						  
    Ĵ
    Retorno	  Void																		  
    Ĵ
     Uso		  GENERICO 																  
    ٱ
    
    
				/*/
Function RodaLote2(nHandle,cLayOut)

    Local nHdlLay	 := 0
    Local lContinua := .T.
    Local cBuffer	 := ""
    Local aLayOut	 := {}
    Local aDetalhe  := {}
    Local nCntFor	 := 0
    Local nCntFor2  := 0
    Local lFormula  := .F.
    Local nPosIni	 := 0
    Local nPosFim	 := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local bBlock	 := ErrorBlock()
    Local bErro 	 := ErrorBlock( { |e| ChecErr260(e,xConteudo) } )

    Private xConteudo := ""

    If ( File(cLayOut) )
        nHdlLay := FOpen(cLayOut,64)
        While ( lContinua )
            cBuffer := FreadStr(nHdlLay,502)
            If ( !Empty(cBuffer) )
                If ( SubStr(cBuffer,1,1)=="1" )
                    If ( SubStr(cBuffer,2,1) != "0" )		 //	If ( SubStr(cBuffer,2,1)=="1" )
                        If ( SubStr(cBuffer,3,1) == "T" )
                            aadd(aLayOut,{ SubStr(cBuffer,02,03),;
                                SubStr(cBuffer,05,30),;
                                SubStr(cBuffer,35,255)})
                        EndIf
                    Endif
                Else
                    If ( SubStr(cBuffer,3,1)=="T" )
                        aadd(aDetalhe,{SubStr(cBuffer,02,03),;
                            SubStr(cBuffer,05,15),;
                            SubStr(cBuffer,20,03),;
                            SubStr(cBuffer,23,03),;
                            SubStr(cBuffer,26,01),;
                            SubStr(cBuffer,27,255)})
                    EndIf
                EndIf
            Else
                lContinua := .F.
            EndIf
        End
        FClose(nHdlLay)
    EndIf
    aSort(aLayOut,,,{|x,y| x[1]>y[1]})
    If nHandle > 0
        For nCntFor := 1 To Len(aLayOut)
            Begin Sequence
                lFormula := &(aLayOut[nCntFor,3])
                If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
                    cBuffer := ""
                    For nCntFor2 := 1 To Len(aDetalhe)
                        If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
                            xConteudo := (aDetalhe[nCntFor2,6])
                            If ( Empty(xConteudo) )
                                xConteudo := ""
                            Else
                                xConteudo := &(AllTrim(xConteudo))
                            EndIf
                            nPosIni   := Val(aDetalhe[nCntFor2,3])
                            nPosFim   := Val(aDetalhe[nCntFor2,4])
                            nDecimal  := Val(aDetalhe[nCntFor2,5])
                            nTamanho  := nPosFim-nPosIni+1
                            Do Case
                            Case ValType(xConteudo) == "D"
                                xConteudo := GravaData(xConteudo,.F.)
                            Case ValType(xConteudo) == "N"
                                xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
                            EndCase
                            xConteudo := SubStr(xConteudo,1,nTamanho)
                            xConteudo := PadR(xConteudo,nTamanho)
                            cBuffer += xConteudo
                        EndIf
                    Next nCntFor2
                    cBuffer += Chr(13)+Chr(10)
                    Fwrite(nHandle,cBuffer,Len(cBuffer))
                EndIf
            End Sequence
        Next nCntFor
        ErrorBlock(bBlock)
    Endif
Return(.T.)

				/*/
    
    Ŀ
    Funo    ReadCnab2  Autor  Eduardo Riera                16/04/98 
    Ĵ
    Descrio Realiza a Leitura da configuraao CNAB Modelo 2             
    Ĵ
    Sintaxe   ReadCnab2( nHandle , cLayOut )                              
    Ĵ
    Parametro  ExpC1 : Handle do Arquivo a ser lido                       
               ExpC2 : Nome do arquivo de configuracao                    
               ExpN3 : Tamanho maximo da linha                            
               ExpA4 : Atributos do arquivo de configuracao               
    Ĵ
    Retorno    Matriz                                                     
    Ĵ
     Uso       GENERICO                                                   
    ٱ
    
    
				/*/
Function ReadCnab2(nHandle,cLayOut,nMaxLn,aLayOut)

    Local nHdlLay   := 0
    Local lContinua := .T.
    Local cBuffer   := ""
    Local nCntFor   := 0
    Local nPosIni   := 0
    Local nPosFim   := 0
    Local nTamanho  := 0
    Local nDecimal  := 0
    Local nPosSeg   := 0
    Local aSegmento := {}
    Local aDetalhe  := {}
    Local cLinUlt   := ""
    Local cLinAtu   := ""
    Local nCntFor2  := 0
    Local cIdent    := ""
    Local xTITULO   := ""
    Local xTIPO     := ""
    Local xOCORRENCI:= ""
    Local xDATA     := "000000"
    Local xVALOR    := 0.00
    Local xDESPESA  := 0.00
    Local xDESCONTO := 0.00
    Local xABATIMENT:= 0.00
    Local xJUROS    := 0.00
    Local xMULTA    := 0.00
    Local xNOSSONUM := ""
    Local xRESERVADO:= ""
    Local xValIof   := 0.00
    Local xValCC    := 0.00
    Local xDataCred := "000000"
    Local xMotivo   := ""
    Local xBuffer   := ""
    Local nLeitura  := 0					// Numero de Leituras Efetuadas
    Local lSegValido:= .F.				// Controle de Leitura de segmentos validos
    Local nLidosBco := 0					// Numero de Bytes lidos do Arquivo de Retorno
    Local xAUTENTICA:= ""
    Local aBuffer 	 := {}
    Local xCGC 		 := ""
    Local cChave    := ""
    Local aDirtmp   := {}
    Local xBANCO	 := ""
    Local xAGENCIA  := ""
    Local xCONTA	 := ""
    Local aHeadL	 := Array(3,5)		//Array das posicoes de Banco, Agencia e Conta no Header para a baixa
    Local aBanco	 := Array(3)		//Dados bancarios para a baixa (coletados no header)
    Local lHeadL	 := ( AllTrim( Upper( FunName() ) ) != "FINR650" )
    Local xCGCH		 := ""
    Local xCODBAR	 := ""

    Default nMaxLn 	 := 1000
    Default aLayOut  := {}

    Private xConteudo  := ""

    If ( File(cLayOut) )

        If Len(aLayOut) == 0
            aDirTmp	:= Directory(cLayOut)
        ELse
            aDirTmp := AClone(aLayOut)
        EndIf

        // Inicializa flag que indica se possui dados bancarios para baixa - Header de Lote
        aHeadL[ 1, 5 ] := .F.
        aHeadL[ 2, 5 ] := .F.
        aHeadL[ 3, 5 ] := .F.

        cChave := aDirTmp[1][1]+str(aDirTmp[1][2])+DtoC(aDirTmp[1][3])+aDirTmp[1][4]

        If Empty(__aLayCNAB) .Or. cChave != __aLayCNAB[1]
            nHdlLay := FOpen(cLayOut,64)
            While ( lContinua )
                cBuffer := FreadStr(nHdlLay,502)
                If ( !Empty(cBuffer) )
                    If ( SubStr(cBuffer,1,1)=="1" )
                        If ( SubStr(cBuffer,3,1)=="D" )
                            aadd(aSegmento,{AllTrim(SubStr(cBuffer,02,03)),;
                                AllTrim(SubStr(cBuffer,35,255)),0,0})
                            aadd(aDetalhe,Array(20,4))
                        EndIf
                    Else
                        If ( SubStr(cBuffer,3,1)=="D" )
                            nPosIni  := Val(SubStr(cBuffer,20,03))
                            nPosFim  := Val(SubStr(cBuffer,23,03))
                            nDecimal := Val(SubStr(cBuffer,26,01))
                            nTamanho := nPosFim - nPosIni +1
                            xConteudo:= AllTrim(SubStr(cBuffer,27,255))
                            nPosSeg := AScan(aSegmento,{|x| x[1]==Alltrim(SubStr(cBuffer,02,03))})
                            If ( nPosSeg != 0 )
                                Do Case
                                Case xConteudo=="TITULO"
                                    aDetalhe[nPosSeg,1,1] := "TITULO"
                                    aDetalhe[nPosSeg,1,2] := nPosIni
                                    aDetalhe[nPosSeg,1,3] := nTamanho
                                    aDetalhe[nPosSeg,1,4] := nDecimal
                                Case  xConteudo=="ESPECIE"
                                    aDetalhe[nPosSeg,2,1] := "ESPECIE"
                                    aDetalhe[nPosSeg,2,2] := nPosIni
                                    aDetalhe[nPosSeg,2,3] := nTamanho
                                    aDetalhe[nPosSeg,2,4] := nDecimal
                                Case xConteudo=="OCORRENCIA"
                                    aDetalhe[nPosSeg,3,1] := "OCORRENCIA"
                                    aDetalhe[nPosSeg,3,2] := nPosIni
                                    aDetalhe[nPosSeg,3,3] := nTamanho
                                    aDetalhe[nPosSeg,3,4] := nDecimal
                                Case xConteudo=="DATA"
                                    aDetalhe[nPosSeg,4,1] := "DATA"
                                    aDetalhe[nPosSeg,4,2] := nPosIni
                                    aDetalhe[nPosSeg,4,3] := nTamanho
                                    aDetalhe[nPosSeg,4,4] := nDecimal
                                Case xConteudo=="VALOR"
                                    aDetalhe[nPosSeg,5,1] := "VALOR"
                                    aDetalhe[nPosSeg,5,2] := nPosIni
                                    aDetalhe[nPosSeg,5,3] := nTamanho
                                    aDetalhe[nPosSeg,5,4] := nDecimal
                                Case xConteudo=="DESPESA"
                                    aDetalhe[nPosSeg,6,1] := "DESPESA"
                                    aDetalhe[nPosSeg,6,2] := nPosIni
                                    aDetalhe[nPosSeg,6,3] := nTamanho
                                    aDetalhe[nPosSeg,6,4] := nDecimal
                                Case xConteudo=="DESCONTO"
                                    aDetalhe[nPosSeg,7,1] := "DESCONTO"
                                    aDetalhe[nPosSeg,7,2] := nPosIni
                                    aDetalhe[nPosSeg,7,3] := nTamanho
                                    aDetalhe[nPosSeg,7,4] := nDecimal
                                Case xConteudo=="ABATIMENTO"
                                    aDetalhe[nPosSeg,8,1] := "ABATIMENTO"
                                    aDetalhe[nPosSeg,8,2] := nPosIni
                                    aDetalhe[nPosSeg,8,3] := nTamanho
                                    aDetalhe[nPosSeg,8,4] := nDecimal
                                Case xConteudo=="JUROS"
                                    aDetalhe[nPosSeg,9,1] := "JUROS"
                                    aDetalhe[nPosSeg,9,2] := nPosIni
                                    aDetalhe[nPosSeg,9,3] := nTamanho
                                    aDetalhe[nPosSeg,9,4] := nDecimal
                                Case xConteudo=="MULTA"
                                    aDetalhe[nPosSeg,10,1] := "MULTA"
                                    aDetalhe[nPosSeg,10,2] := nPosIni
                                    aDetalhe[nPosSeg,10,3] := nTamanho
                                    aDetalhe[nPosSeg,10,4] := nDecimal
                                Case xConteudo=="IOF"
                                    aDetalhe[nPosSeg,11,1] := "IOF"
                                    aDetalhe[nPosSeg,11,2] := nPosIni
                                    aDetalhe[nPosSeg,11,3] := nTamanho
                                    aDetalhe[nPosSeg,11,4] := nDecimal
                                Case xConteudo=="OUTROSCREDITOS"
                                    aDetalhe[nPosSeg,12,1] := "OUTROSCREDITOS"
                                    aDetalhe[nPosSeg,12,2] := nPosIni
                                    aDetalhe[nPosSeg,12,3] := nTamanho
                                    aDetalhe[nPosSeg,12,4] := nDecimal
                                Case xConteudo=="DATACREDITO"
                                    aDetalhe[nPosSeg,13,1] := "DATACREDITO"
                                    aDetalhe[nPosSeg,13,2] := nPosIni
                                    aDetalhe[nPosSeg,13,3] := nTamanho
                                    aDetalhe[nPosSeg,13,4] := nDecimal
                                Case xConteudo=="MOTIVO"
                                    aDetalhe[nPosSeg,14,1] := "MOTIVO"
                                    aDetalhe[nPosSeg,14,2] := nPosIni
                                    aDetalhe[nPosSeg,14,3] := nTamanho
                                    aDetalhe[nPosSeg,14,4] := nDecimal
                                Case xConteudo=="NOSSONUMERO"
                                    aDetalhe[nPosSeg,15,1] := "NOSSONUMERO"
                                    aDetalhe[nPosSeg,15,2] := nPosIni
                                    aDetalhe[nPosSeg,15,3] := nTamanho
                                    aDetalhe[nPosSeg,15,4] := nDecimal
                                Case xConteudo=="RESERVADO"
                                    aDetalhe[nPosSeg,16,1] := "RESERVADO"
                                    aDetalhe[nPosSeg,16,2] := nPosIni
                                    aDetalhe[nPosSeg,16,3] := nTamanho
                                    aDetalhe[nPosSeg,16,4] := nDecimal
                                Case xConteudo=="SEGMENTO"
                                    aSegmento[nPosSeg,3] := nPosIni
                                    aSegmento[nPosSeg,4] := nTamanho
                                Case xConteudo=="AUTENTICACAO"
                                    aDetalhe[nPosSeg,17,1] := "AUTENTICACAO"
                                    aDetalhe[nPosSeg,17,2] := nPosIni
                                    aDetalhe[nPosSeg,17,3] := nTamanho
                                    aDetalhe[nPosSeg,17,4] := nDecimal
                                Case xConteudo=="CGC"
                                    aDetalhe[nPosSeg,18,1] := "CGC"
                                    aDetalhe[nPosSeg,18,2] := nPosIni
                                    aDetalhe[nPosSeg,18,3] := nTamanho
                                    aDetalhe[nPosSeg,18,4] := nDecimal
                                Case xConteudo=="CGCH"
                                    aDetalhe[nPosSeg,19,1] := "CGCH"
                                    aDetalhe[nPosSeg,19,2] := nPosIni
                                    aDetalhe[nPosSeg,19,3] := nTamanho
                                    aDetalhe[nPosSeg,19,4] := nDecimal
                                Case xConteudo=="CODBAR"
                                    aDetalhe[nPosSeg,20,1] := "CODBAR"
                                    aDetalhe[nPosSeg,20,2] := nPosIni
                                    aDetalhe[nPosSeg,20,3] := nTamanho
                                    aDetalhe[nPosSeg,20,4] := nDecimal
                                EndCase
                            EndIf
                            //Dados bancarios para a baixa
                        ElseIf ( SubStr(cBuffer,3,1)=="H" )
                            nPosIni  := Val(SubStr(cBuffer,20,03))
                            nPosFim  := Val(SubStr(cBuffer,23,03))
                            nDecimal := Val(SubStr(cBuffer,26,01))
                            nTamanho := nPosFim - nPosIni +1
                            xConteudo:= AllTrim(SubStr(cBuffer,27,255))
                            lHeadL   := .T.
                            Do Case
                            Case xConteudo=="BANCO"
                                aHeadL[1,1] := "BANCO"
                                aHeadL[1,2] := nPosIni
                                aHeadL[1,3] := nTamanho
                                aHeadL[1,4] := nDecimal
                                aHeadL[1,5] := .T.
                            Case xConteudo=="AGENCIA"
                                aHeadL[2,1] := "AGENCIA"
                                aHeadL[2,2] := nPosIni
                                aHeadL[2,3] := nTamanho
                                aHeadL[2,4] := nDecimal
                                aHeadL[2,5] := .T.
                            Case xConteudo=="CONTA"
                                aHeadL[3,1] := "CONTA"
                                aHeadL[3,2] := nPosIni
                                aHeadL[3,3] := nTamanho
                                aHeadL[3,4] := nDecimal
                                aHeadL[3,5] := .T.
                            EndCase
                        EndIf
                    EndIf
                Else
                    lContinua := .F.
                EndIf
            EndDo
            FClose(nHdlLay)
            __aLayCNAB	:=	{}
            Aadd(__aLayCNAB,cChave)
            Aadd(__aLayCNAB,aSegmento)
            Aadd(__aLayCNAB,aDetalhe)
            Aadd(__aLayCNAB,aHeadL)
            Aadd(__aLayCNAB,aBanco)
        Else
            aSegmento	:= aClone(__aLayCNAB[2])
            aDetalhe	:= aClone(__aLayCNAB[3])
            aHeadL		:= aClone(__aLayCNAB[4])
            aBanco		:= aClone(__aLayCNAB[5])
        EndIf

    EndIf

    lContinua := .T.

    While ( lContinua )
        aLinha		:= LerLinha(nHandle,nMaxLn)
        cBuffer 		:= aLinha[1]
        nLidosBco 	:= aLinha[2]
        lSegValido	:= .F.
        nLeitura++
        If (!Empty(cBuffer))
            //Lendo no Header de Lote o Banco, Agencia e Conta para baixa
            If Substr(cBuffer,8,1) == "1" .And. lHeadL
                For nCntFor := 1 To Len(aHeadL)
                    If aHeadL[nCntFor,5]
                        nPosIni := aHeadL[nCntFor,2]
                        nTamanho:= aHeadL[nCntFor,3]
                        nDecimal:= aHeadL[nCntFor,4]
                        Do Case
                        Case aHeadL[nCntFor,1]=="BANCO"
                            xBANCO	:= SubStr(cBuffer,nPosIni,nTamanho)
                            aBanco[1] := xBANCO
                        Case aHeadL[nCntFor,1]=="AGENCIA"
                            xAGENCIA	:= SubStr(cBuffer,nPosIni,nTamanho)
                            aBanco[2] := xAGENCIA
                        Case aHeadL[nCntFor,1]=="CONTA"
                            xCONTA	:= SubStr(cBuffer,nPosIni,nTamanho)
                            aBanco[3] := xCONTA
                        EndCase
                    EndIf
                Next
                __aLayCNAB[5] := aClone( aBanco )
            Else
                //Recarrego os dados bancarios quando estiver processando o detalhe
                //Esses dados estao apenas no header e somente serao trocados quando
                //lido um novo header
                If Empty(xBanco) .and. !Empty(aBanco[1])
                    xBanco	:= aBanco[1]
                    xAgencia := aBanco[2]
                    xConta	:= aBanco[3]
                Endif

                For nCntFor := 1 To Len(aSegmento)
                    //Ŀ
                    //                      Teste de Quebra                         
                    //  1D(n)                                                       
                    //  ------------------------------                              
                    //  |(n)-------------------------  -> Linha Detalhe  =  Conj.   
                    //  | 1 |------------------------A - Identificador    | da      
                    //  | 2 |------------------------B - Identificador    | Linha   
                    //  | 3 |------------------------C - Identificador    | Detalhe 
                    //  |   -------------------------                    =          
                    //  |                                                           
                    //  ------------------------------                              
                    //  2D(n)                                                       
                    //  ------------------------------                              
                    //  |(n)-------------------------  -> Linha Detalhe  =  Conj.   
                    //  | 1 |------------------------A - Identificador    | da      
                    //  | 2 |------------------------B - Identificador    | Linha   
                    //  | 3 |------------------------C - Identificador    | Detalhe 
                    //  |   -------------------------                    =          
                    //  |                                                           
                    //  ------------------------------                              
                    //                                                              
                    //
                    xConteudo := SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4])
                    //Ŀ
                    // Verifica a qual linha detalhe o segmento valido pertence.    
                    //
                    If ( xConteudo $ aSegmento[nCntFor,2] )
                        cLinAtu := SubStr(aSegmento[nCntFor][1],1,1)
                    EndIf
                    //Ŀ
                    // Verifica se houve quebra de linha detalhe, ou se o houve re- 
                    // peticao do mesmo conjunto da linha detalhe. A repeticao ocor-
                    // re quando o identificador de linha repete-se.                
                    //
                    If ( (cIdent == xConteudo .Or. cLinAtu!=cLinUlt ) .And.;
                            !Empty(cIdent) .And. !Empty(cLinUlt) .And. nLeitura > 1 )
                        //Ŀ
                        // Retorna a linha atual para ser relida na proxima interacao.  
                        //
                        FSeek(nHandle,-2*(nLidosBco),1)
                        cBuffer := LerLinha(nHandle,nMaxLn)[1]
                        lContinua := .F.
                        Exit
                    EndIf
                    If ( lContinua )
                        If ( xConteudo $ aSegmento[nCntFor,2] )
                            lSegValido := .T.
                            xBuffer    += cBuffer
                            Aadd(aBuffer,cBuffer)
                            If (Empty(cIdent))
                                nLeitura := 1
                                cIdent 	:= xConteudo
                                cLinUlt  := SubStr(aSegmento[nCntFor][1],1,1)
                            EndIf
                            For nCntFor2 := 1 To Len(aDetalhe[nCntFor])
                                nPosIni := aDetalhe[nCntFor,nCntFor2,2]
                                nTamanho:= aDetalhe[nCntFor,nCntFor2,3]
                                nDecimal:= aDetalhe[nCntFor,nCntFor2,4]
                                Do Case
                                Case aDetalhe[nCntFor,nCntFor2,1]=="TITULO"
                                    xTITULO := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="NOSSONUMERO"
                                    xNOSSONUM := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="ESPECIE"
                                    xTIPO     := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="OCORRENCIA"
                                    xOCORRENCI := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DATA"
                                    xDATA := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="VALOR"
                                    xVALOR := SubStr(cBuffer,nPosIni,nTamanho)
                                    xVALOR := Val(xVALOR)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DESPESA"
                                    xDESPESA := SubStr(cBuffer,nPosIni,nTamanho)
                                    xDESPESA := Val(xDESPESA)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DESCONTO"
                                    xDESCONTO := SubStr(cBuffer,nPosIni,nTamanho)
                                    xDESCONTO := Val(xDESCONTO)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="ABATIMENTO"
                                    xABATIMENT := SubStr(cBuffer,nPosIni,nTamanho)
                                    xABATIMENT := Val(xABATIMENT)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="JUROS"
                                    xJUROS := SubStr(cBuffer,nPosIni,nTamanho)
                                    xJUROS := Val(xJUROS)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="MULTA"
                                    xMULTA := SubStr(cBuffer,nPosIni,nTamanho)
                                    xMULTA := Val(xMULTA)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="OUTROSCREDITOS"
                                    xValCC := SubStr(cBuffer,nPosIni,nTamanho)
                                    xValCC := Val(xValCC)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="IOF"
                                    xValIof := SubStr(cBuffer,nPosIni,nTamanho)
                                    xValIof := Val(xValIof)/(Val("1"+Repl("0",nDecimal)))
                                Case aDetalhe[nCntFor,nCntFor2,1]=="DATACREDITO"
                                    xDATACRED := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="MOTIVO"
                                    xMOTIVO := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="RESERVADO"
                                    xRESERVADO:= SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="AUTENTICACAO"
                                    xAUTENTICA := SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="CGC"
                                    xCGC:= SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="CGCH"
                                    xCGCH:= SubStr(cBuffer,nPosIni,nTamanho)
                                Case aDetalhe[nCntFor,nCntFor2,1]=="CODBAR"
                                    xCODBAR:= SubStr(cBuffer,nPosIni,nTamanho)
                                EndCase
                            Next
                        EndIf
                    EndIf
                Next nCntFor
                If ( !lSegValido .And. !Empty(cIdent) )
                    lContinua := .F.
                EndIf
            Endif
        Else
            lContinua := .F.
        EndIf
    EndDo
Return({	xTITULO,xTIPO,xOCORRENCI,xDATA,xVALOR,;
        xDESPESA,xDESCONTO,xABATIMENT,xJUROS,xMULTA,;
        xNOSSONUM,xVALIOF,xVALCC,xDATACRED,xMOTIVO,;
        xRESERVADO,xBuffer,xAUTENTICA,aBuffer,xCGC,;
        xBanco,xAgencia,xConta,xCGCH,xCODBAR})

				/*/
    
    
    Ŀ
    Funo	  GravaData Autor  Wagner Xavier 		   Data  26/05/92 
    Ĵ
    Descrio  Determinado forma de gravao para campo data.				  
    Ĵ
    Sintaxe	  GravaData(ExpD1,ExpL1,ExpN1)										  
    Ĵ
    Parametros ExpD1 := Data a ser convertida									  
    			  ExpL1 := Tipo(Se .T. com Barra, se .F., sem Barra			  
    			  ExpN1 := Formato (1,2,3)											  
    			   Formato 1 := ddmmaa 												  
    			  			2 := mmddaa 												  
    			  			3 := aaddmm 												  
    			  			4 := aammdd 												  
    			  			5 := ddmmaaaa												  
    			  			6 := mmddaaaa												  
    			  			7 := aaaaddmm												  
    			  			8 := aaaammdd												  
    Ĵ
     Uso		  Fina150																	  
    ٱ
    
    
				/*/
Function GravaData( dData, lBarra, nFormato )

    Local xData 	:= dData

    dData   := Iif( dData==Nil,dDataBase,dData )
    lBarra  := Iif( lBarra==Nil,.T.,lBarra )
    nFormato:= Iif( nFormato==Nil,1,nFormato )
    cSepar  := Iif( lBarra,"/","" )

    If !lBarra
        Do Case
        Case nFormato == 1
            xData := StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)+cSepar+SubStr(StrZero(Year(dData),4),3,2)
        Case nFormato == 2
            xData := StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)+cSepar+SubStr(StrZero(Year(dData),4),3,2)
        Case nFormato == 3
            xData := SubStr(StrZero(Year(dData),4),3,2)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)
        Case nFormato == 4
            xData := SubStr(StrZero(Year(dData),4),3,2)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)
        Case nFormato == 5
            xData := StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Year(dData),4)
        Case nFormato == 6
            xData := StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Year(dData),4)
        Case nFormato == 7
            xData := StrZero(Year(dData),4)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)
        OtherWise
            xData := StrZero(Year(dData),4)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)
        EndCase
    End
Return xData

				/*/
    
    Ŀ
    Funo	 ChecErr260 Autor  Wagner Xavier 		   Data  10/11/92 
    Ĵ
    Descrio Rotina analizadora do erro											  
    Ĵ
     Uso		 Sigafin Advanced.														  
    ٱ
    
    
				/*/
Function ChecErr260(e,cForm)
    If e:gencode > 0
        Help( " ",1,"ERR_FORM",,e:Description+" : "+Substr(cForm,1,20),3,1 )
        lRet:=.F.
    EndIf
    Break

				/*/
    
    
    Ŀ
    Funo	 Incrementa Autor  Wagner Xavier 		   Data  26/05/92 
    Ĵ
    Descrio Incrementa 1 a um determinado Numero 							  
    Ĵ
    Sintaxe	 Incrementa(Numero) 													  
    Ĵ
     Uso		  Generico 																  
    ٱ
    
    
				/*/
Function Incrementa(cNum)
    If PCOUNT()==0
        cNum:=StrZero(nSeq,6)
    EndIf
Return 1+Val(cNum)
				/*/
    
    
    Ŀ
    Funo	 TesImpInf  Autor  Bruno Sobieski		 Data  17.11.98 
    Ĵ
    Descrio  Retorna um array com os dados dos impostos relacionados com
    			  o tes que  pasado como parametro. Usado para Impostos nas |
    			  Localizacoes no Exterior.								  
    			  aImpFlag[n][1]-> Codigo do Imposto						  
    			  		  [n][2]-> Campo no SD1 ou SD2 onde  gravado o valor |
    			  					  imposto.								  
    			  		  [n][3]-> Se o valor do imposto incide na Nota 	  
    			  		  [n][4]-> Se o valor do imposto incide na Duplicata  
    			  		  [n][5]-> Se o valor do imposto deve ser Creditado   
    			  		  [n][6]-> Campo no SF1 ou SF2 onde  gravado o valor |
    			  					  imposto.								  
    			  		  [n][7]-> Campo no SD1 ou SD2 onde  gravada a base  |
    			  					  do imposto.							  
    			  		  [n][8]-> Campo no SF1 ou SF2 onde  gravada a base  |
    			  					  do imposto.							  
    			  		  [n][9]-> Aliquota do imposto                        
    Ĵ
     Parametro cTes -> Codigo de Entrada-Saida							  
    Ĵ
     Uso		  Generico Localizacoes.									  
    ٱ
    
    
				/*/
Function TesImpInf(cTes)
    Local cAlias
    Local aImpFlag :={}
    cAlias  :=Alias()
    nOrder  :=IndexOrd ()
    nReg	  :=Recno()
    SFB->(DbSetOrder(1))
    DbSelectArea("SFC")
    DbSetOrder(1)
    DbSeek(xFilial("SFC")+cTes)
    While SFC->(!eof()) .and. xFilial("SFC")== FC_FILIAL .and. cTes== FC_TES
        If SFB->(DbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
            If (cTes<="500" )
                If SD1->(FieldPos("D1_ALQIMP"+SFB->FB_CPOLVRO))  > 0
                    Aadd(aImpFlag,{SFB->FB_CODIGO,"D1_VALIMP"+SFB->FB_CPOLVRO,SFC->FC_INCNOTA,SFC->FC_INCDUPL,SFC->FC_CREDITA,"F1_VALIMP"+SFB->FB_CPOLVRO,"D1_BASIMP"+SFB->FB_CPOLVRO,"F1_BASIMP"+SFB->FB_CPOLVRO,SFB->FB_ALIQ,"D1_ALQIMP"+SFB->FB_CPOLVRO,SFC->FC_PROV,SFC->FC_INCIMP})
                EndIf
            Else
                Aadd(aImpFlag,{SFB->FB_CODIGO,"D2_VALIMP"+SFB->FB_CPOLVRO,SFC->FC_INCNOTA,SFC->FC_INCDUPL,SFC->FC_CREDITA,"F2_VALIMP"+SFB->FB_CPOLVRO,"D2_BASIMP"+SFB->FB_CPOLVRO,"F2_BASIMP"+SFB->FB_CPOLVRO,SFB->FB_ALIQ,"D2_ALQIMP"+SFB->FB_CPOLVRO,SFC->FC_PROV,SFC->FC_INCIMP})
            EndIf
        EndIf
        SFC->(DbSkip())
    End
    DbSelectArea(cAlias)
    DbSetOrder(nOrder)
    DbGoTo(nReg)

Return(aImpFlag)

				/*
				
				
				Ŀ
				Funo		  AutoGrLog  Autor  Sandro 					 Data  12/03/98 
				Ĵ
				Descrio  Grava o Log com a descricao do HELP.							  
				Ĵ
				Sintaxe	  AutoGrLog [ cExpr ] )												
				Ĵ
				Parmetros ExpC1 - Texto a ser gravado no arquivo.						  
				Ĵ
				
				
				*/
Function AutoGRLog(cLogErro)
    DEFAULT __cFileLog := CriaTrab(,.f.)+".LOG"

    If ( Type("lMSErroAuto") == "L" )
        lMSErroAuto := .T.
    EndIf

    If ( Type( 'lAutoErrNoFile' ) == 'L' ) .And. ( lAutoErrNoFile )
        Aadd( __aErrAuto, cLogErro )
        Return
    EndIf

    If ! File(__cFileLog)
        If (nHandle2 := MSFCreate(__cFileLog,0)) == -1
            Return
        EndIf
    Else
        If (nHandle2 := FOpen(__cFileLog,2)) == -1
            Return
        EndIf
    EndIf
    FSeek(nHandle2,0,2)
    FWrite(nHandle2,cLogErro+chr(13)+chr(10))
    FClose(nHandle2)
Return

Function GetAutoGRLog ( )
    Local aTemp := AClone( __aErrAuto )
    __aErrAuto := {}
Return( aTemp )

				/*
				
				
				Ŀ
				Funo	 NomeAutoLog  Autor  Sandro 		  		   Data  21/07/00 
				Ĵ
				Descrio  Retorna no nome do arq. de erro automatico  			   	  
				Ĵ
				Sintaxe	  NomeAutoLog()        											     
				Ĵ
				
				
				__cFileLog e'uma variavel estatica
				*/
Function NomeAutoLog()
Return __cFileLog



				/*
				
				
				Ŀ
				Funo	  FormBatch Autor  Juan Jose Pereira	   Data  04/12/98 
				Ĵ
				Descrio  Monta tela generica para processo batch						  
				Ĵ
				Sintaxe	  FormBatch( cTitle, aSays, aButtons, lOk, bValid )			  
				Ĵ
				Parmetros cTitle = Titulo da janela											  
							  aSays  = Array com Says 											  
							  aButtons = Array com bottoes										  
							  aButtons[i,1] = Tipo de botao 									  
							  aButtons[i,2] = Tipo de enabled									  
							  aButtons[i,3] = bAction 											  
							  bValid = Bloco de validacao do Form 							  
							  nAltura= Altura do Form em Pixel (Default 250)				  
							  nLargura = Largura do Form em Pixel (Default 520)			  
				Ĵ
				
				
				*/
    #DEFINE LARGURA_DO_SBUTTON 32

Function FormBatch( cTitle, aSays, aButtons, bValid, nAltura, nLargura )

    Local nButtons:= Len(aButtons),;
        nSays:= Len(aSays),;
        oSay,;
        i,nTop, nType, lEnabled, oFormPai, oFont,;
        nLarguraBox, nAlturaBox, nLarguraSay, cTextSay, oBtn, cCaption

    DEFAULT aSays:={}, aButtons:={}
    DEFAULT nAltura:= 250, nLargura:= 520

    // Numero maximo de linhas //
    If( nSays>7 )
        nSays:=7
    EndIf

    // Numero maximo de botoes //
    If( nButtons>5 )
        nButtons:= 5
    EndIf

    oFormPai:= Atail(aFormBatch)
    If( oFormPai==NIL )
        oFormPai:= oMainWnd
    EndIf

    DEFINE FONT oFont NAME "Arial" SIZE 0, -11

    DEFINE MSDIALOG oDlg TITLE cTitle FROM 0,0 TO nAltura,nLargura OF oFormPai PIXEL

    AADD(aFormBatch,oDlg)

    nAlturaBox:= (nAltura-60)/2
    nLarguraBox:= (nLargura-20)/2
    @ 10,10 TO nAlturaBox,nLarguraBox OF oDlg PIXEL

    //======================================================//
    // monta says (bof)												 //
    //======================================================//
    nTop:=20

    nLarguraSay:= nLarguraBox-30
    for i:=1 to nSays
        cTextSay:= "{||'"+aSays[i]+"'}"
        oSay := TSay():New( nTop, 20, MontaBlock(cTextSay),oDlg,, oFont, .F., .F., .F., .T.,,, nLarguraSay, 10, .F., .F., .F., .F., .F. )
        nTop+= 10
    next
    //======================================================//
    // monta says (eof)												 //
    //======================================================//

    //======================================================//
    // monta bottoes(bof) 											 //
    //======================================================//
    nPosIni:= ((nLargura-20)/2) - (nButtons* LARGURA_DO_SBUTTON )
    nAlturaButton:= nAlturaBox+10

    for i:=1 to nButtons
        nType:= aButtons[i,1]
        If nType == 5
            cCaption := STR0105 //"Param."
        Else
            cCaption := ""
        EndIf
        lEnabled:= aButtons[i,2]

        DEFAULT lEnabled:= .T.

        If lEnabled
            oBtn := SButton():New( nAlturaButton, nPosIni, nType,aButtons[i,3],oDlg,.T.,,)
        Else
            oBtn := SButton():New( nAlturaButton, nPosIni, nType,,oDlg,.F.,,)
        EndIf
        If !Empty(cCaption)
            oBtn:cCaption := cCaption
        EndIf

        nPosIni+= LARGURA_DO_SBUTTON
    next
    //======================================================//
    // monta bottoes(bof) 											 //
    //======================================================//
    oDlg:Activate( ,,,.T.,bValid,,,, )

Return nil

				/*
				
				
				Ŀ
				Funo	 FechaBatch Autor  Juan Jose Pereira	   Data  04/12/98 
				Ĵ
				Descrio  Fecha Ultima tela de batch 										  
				Ĵ
				Sintaxe	  FechaBatch()															  
				Ĵ
				
				
				*/
Function FechaBatch()

    Local oDlg:= Atail( aFormBatch )

    oDlg:End()

    ASize( aFormBatch,Len(aFormBatch)-1 )

Return nil

				/*
				
				
				Ŀ
				Funo	 GetFormBatch Autor  Juan Jose Pereira    Data  04/12/98 
				Ĵ
				Descrio  Retorna um Form de Batch aberto									  
				Ĵ
				Sintaxe	 oDlg:= GetFormBatch(nDialog), se nDialog==0 retorna o ultimo
				Ĵ
				
				
				*/
Function GetFormBatch(nDialog)

    Local oRet:= NIL

    If( nDialog==0 )
        oRet:= Atail(aFormBatch)
    Else
        If( nDialog>0 .and. nDialog<=Len(aFormBatch) )
            oRet:= aFormBatch[nDialog]
        EndIf
    EndIf
Return oRet

				/*
				
				
				Ŀ
				Funo	 MsExectAuto  Autor Alex Sandro Valario   Data  03/02/00 
				Ĵ
				Descrio  Execute rotina de  manutencao automatica	     			  
				Ĵ
				Uso		  Generico 												  
				Ĵ
				Parmetros bRotina = Bloco de codigo com a chamada da rotina          
							  uPar1 ... Uparn = paramentos de cada rotina                
				ٱ
				
				
				Exemplo
				MSExecAuto({|x| mata010(x)},acab)
				MSExecAuto({|x,y| mata140(x,y)},aCab,aItens)
				*/

Function MSExecAuto(bRotina,uPar1,uPar2,uPar3,uPar4,uPar5,uPar6,uPar7,uPar8,uPar9,uPar10)
    LOCAL   ElMsHelpAuto
    LOCAL	EaTela
    LOCAL	EaGets
    LOCAL	EaHeader
    LOCAL	EaCols
    LOCAL	EaRotAuto
    LOCAL	EInclui
    LOCAL	EAltera
    LOCAL	En
    LOCAL	E__cInternet
    LOCAL   E__READVAR
    Local ElMsFinalAuto

    If ( Type('lMsFinalAuto') == 'U' )
        Private lMsFinalAuto := .T.
    EndIf

    ElMsFinalAuto := lMsFinalAuto
    lMsFinalAuto  := .T.

    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto   := .t.
    else
        ElMsHelpAuto :=lMsHelpAuto
    EndIf
    If Type("aTELA") <> "U"
        EaTela := aClone(aTELA)
    EndIf
    If Type("aGETS") <> "U"
        EaGets := aClone(aGETS)
    EndIf
    If Type("aHeader") <> "U"
        EaHeader := aClone(aHeader)
    EndIf
    If Type("aCols")  <> "U"
        EaCols := aClone(aCols)
    EndIf
    If Type("aRotAuto") <> "U"
        EaRotAuto := aClone(aRotAuto)
    EndIf
    If Type("Inclui") <> "U"
        EInclui := Inclui
    EndIf
    If Type("Altera") <> "U"
        EAltera := Altera
    EndIf
    If Type("n") <> "U"
        En := n
    EndIf
    If Type("__cInterNet") <> "U"
        E__cInternet := __cInterNet
    EndIf

    If Type("__READVAR") <> "U"
        E__READVAR := __READVAR
    EndIf


    __cInterNet := "AUTOMATICO"

    eval(bRotina,uPar1,uPar2,uPar3,uPar4,uPar5,uPar6,uPar7,uPar8,uPar9,uPar10)

    lMsHelpAuto := ElMsHelpAuto
    lMsFinalAuto:= ElMsFinalAuto
    aTELA       := EaTela
    aGETS       := EaGets
    aHeader     := EaHeader
    aCols  		:= EaCols
    aRotAuto    := EaRotAuto
    Inclui		:= EInclui
    Altera		:= EAltera
    n			:= En
    __cInterNet := E__cInternet
    __READVAR   := E__READVAR
Return .t.

				/*
				
				
				Ŀ
				Funo	 MsRotAuto  Autor  Alex Sandro Valario    Data  18/08/98 
				Ĵ
				Descrio  Rotina de manutencao automatica									  
				Ĵ
				Uso		  Generico 																  
				Ĵ
				Parmetros nOpcAuto = Numero de opcao da manutencao (3=inclusao) 	  
							  xRotAuto = array contEndo linhas para inclusao				  
							  sAlias	= Alias														  
							  uFunCpo  = Campos a serem editados 								  
				ٱ
				
				
				*/
Function MsRotAuto(nOpcAuto,xRotAuto,sAlias,uFunCpo)
    Local nCnt0,nCnt1, nCnt2, bBlock, aFuncoes,nOrderSX3,nPos
    Local AutoReadVar, lObrigat ,cConteudo,uVar,cErro
    Local lInit := .f.
    Local cAlias

    //Ŀ
    // Parametro utilizado para validar campos obrigatorios      
    //
    Local lVldObrig := SuperGetMv("MV_VLDOBRI",.F.,.F.)

    Private aTELA[0][0],aGETS[0]
    Private aHeader:={},aCols:={}
    Private aRotAuto

    nOpcAuto := if(nOpcAuto==NIL,3,nOpcAuto)
    If type("INCLUI")# "L"
        _SetOwnerPrvt("inclui",nOpcAuto==3)
    EndIf
    If type("ALTERA")# "L"
        _SetOwnerPrvt("altera",nOpcAuto==4)
    EndIf


    If Type("lMSErroAuto") == "U"
        Private lMSErroAuto := .F.
    EndIf
    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto := .t.
    EndIf
    cAlias := sAlias

    aRotAuto := (cAlias)->(MSArrayXDB(xRotAuto,.T.,nOpcAuto,,uFunCpo))
    //Ŀ
    // se funcao retornar vetor com 0 signIfica que gerou arquivo de log 
    //
    If !( Len(aRotAuto) > 0 )
        Return .t.
    EndIf

    If  aRotAuto # NIL
        nOrderSX3:= SX3->(IndexOrd())
        SX3->(DbSetOrder(2))
        For nCnt1 := 1 To Len( aRotAuto )
            If ( aRotAuto[nCnt1,1] = "AUT" )
                Loop
            EndIf
            AutoReadVar  := "M->" + Upper( aRotAuto[nCnt1,1 ] )
            &AutoReadVar := aRotAuto[nCnt1,2 ]
            If aRotAuto[nCnt1,3 ] == NIL
                SX3->(DbSeek( aRotAuto[nCnt1,1 ] ))
                If SX3->(Found()) .And. !Empty(SX3->X3_VALID )
                    aRotAuto[nCnt1,3 ] := Upper(AllTrim( SX3->X3_VALID ))
                EndIf
            EndIf
            If ( Empty(aRotAuto[nCnt1,3 ]) )
                aRotAuto[nCnt1,3 ] := ".t."
            EndIf
        Next

        For nCnt1 := 1 To Len( aRotAuto )
            If ( aRotAuto[nCnt1,1] = "AUT" ) //Variavel serah utilizada dentro dos programas
                Loop
            EndIf
            AutoReadVar := "M->" + Upper( aRotAuto[ nCnt1,1 ] )
            If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. Empty(aRotAuto[ nCnt1,2])
                lInit := .f.
                If ExistIni(Subs(AutoReadVar,4))
                    lInit := .t.
                    &AutoReadVar := InitPad(SX3->X3_RELACAO)
                    If ValType(&AutoReadVar) = "C"
                        &AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
                    EndIf
                    If &AutoReadVar == NIL .or. Empty(aRotAuto[ nCnt1,2])
                        lInit := .f.
                    EndIf
                EndIf
                //Ŀ
                //Manter a variavel de memoria caso uma validacao as atualize e nao tenha   
                //sido mensionada no arquivo texto, somente no caso de inclusao             
                //
                If Empty(aRotAuto[ nCnt1,2]) .and. !Empty(&AutoReadVar) .and. nOpcAuto == 3
                    lInit := .T.
                EndIf
                If !lInit
                    &AutoReadVar := aRotAuto[ nCnt1,2 ]
                EndIf
            EndIf
            //Ŀ
            //Se for alteracao e alguma validacao atualizar a variavel e a mesma
            //nao for um campo que foi passado no array, respeitar a alteracao  
            //
            If nOpcAuto == 4 .and. !aRotAuto[ nCnt1,4 ] .and. (&AutoReadVar != aRotAuto[ nCnt1,2])
                aRotAuto[ nCnt1,2 ] := &AutoReadVar
            EndIf
            //Ŀ
            //Caso alguma validacao atualize a variavel manter o que foi passado
            //
            If ( &AutoReadVar != aRotAuto[ nCnt1,2] .and. !Empty(aRotAuto[ nCnt1,2]) )
                &AutoReadVar := aRotAuto[ nCnt1,2 ]
            EndIf
            __READVAR := Upper(AllTrim(AutoReadVar))
            If !( aRotAuto[ nCnt1,3 ] == NIL )
                SX3->(DbSetOrder(2))
                SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
                lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
                If (lObrigat .or. ! Empty(&AutoReadVar))
                    bBlock := &( "{ || " + AllTrim( aRotAuto[nCnt1,3 ] ) + " }" )
                    If SX3->X3_VISUAL # "V"
                        If ! Eval( bBlock ) .Or.  IIf(lVldObrig, lObrigat .And. Empty(aRotAuto[ nCnt1,2 ]),.F.)
                            AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
                            SX3->(DbSetOrder(2))
                            For nCnt2 := 1 To Len(aRotAuto)
                                uVar := aRotAuto[nCnt2,2]
                                If 	 (ValType(uVar) == "C")
                                    cConteudo := uVar
                                ElseIf (ValType(uVar) == "N")
                                    cConteudo := Str(uVar)
                                ElseIf (ValType(uVar) == "D")
                                    cConteudo := DtoC(uVar)
                                ElseIf (ValType(uVar) == "L")
                                    cConteudo := If(uVar,"True","False")
                                ElseIf (ValType(uVar) == "M")
                                    cConteudo := "Memo"
                                ElseIf (ValType(uVar) == "U")
                                    cConteudo := "Nil"
                                EndIf
                                If (Padr(aRotAuto[nCnt2,1],12) == Padr(Subs(AutoReadVar,4),12))
                                    cErro := " < -- Invalido"
                                Else
                                    cErro := ""
                                EndIf
                                SX3->(DbSeek(Trim(aRotAuto[nCnt2,1])))
                                AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aRotAuto[nCnt2,1],12)+":="+cConteudo+cErro)
                            Next
                            AutoGRLog(Repl("-",80))
                            SX3->(DbSetOrder(nOrderSX3))
                            lMsHelpAuto := .F.
                            Return .t.
                        EndIf
                        SX3->(DbSetOrder(2))
                        SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
                        If SX3->(X3_TRIGGER) == "S"
                            RunTrigger(1)
                        EndIf
                    EndIf
                EndIf
                If ( lMSErroAuto )
                    AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
                    For nCnt2 := 1 To Len(aRotAuto)
                        uVar := aRotAuto[nCnt2,2]
                        If     (ValType(uVar) == "C")
                            cConteudo := uVar
                        ElseIf (ValType(uVar) == "N")
                            cConteudo := Str(uVar)
                        ElseIf (ValType(uVar) == "D")
                            cConteudo := DtoC(uVar)
                        ElseIf (ValType(uVar) == "L")
                            cConteudo := If(uVar,"True","False")
                        ElseIf (ValType(uVar) == "M")
                            cConteudo := "Memo"
                        ElseIf (ValType(uVar) == "U")
                            cConteudo := "Nil"
                        EndIf
                        If (Padr(aRotAuto[nCnt2,1],12) == Padr(Subs(AutoReadVar,4),12))
                            cErro := " < -- Invalido"
                        Else
                            cErro := ""
                        EndIf
                        AutoGRLog(Padr(aRotAuto[nCnt2,1],12)+":="+cConteudo+cErro)
                    Next
                    AutoGRLog(Repl("-",80))
                    SX3->(DbSetOrder(nOrderSX3))
                    lMsHelpAuto := .F.
                    Return .t.
                EndIf
            EndIf
        Next
        nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
        If ( nPos # 0 )
            dbSelectArea(cAlias)
            bBlock := &( "{ |x,y,z,k| " + aRotina[ nPos,2 ] + "(x,y,z,k) }" )  // { |x,y,z| A240Inclui(x,y,z) }
            Eval( bBlock, cAlias, (cAlias)->(Recno()),nOpcAuto)
            lMsHelpAuto := .F.
            SX3->(DbSetOrder(nOrderSX3))
            Return .t.
        EndIf
        SX3->(DbSetOrder(nOrderSX3))
    EndIf
    lMsHelpAuto := .F.
Return .f.

				/*
				
				
				Ŀ
				Funo	 AxIncluiAuto Autor  Alex Sandro Valario  Data  19/08/98 
				Ĵ
				Descrio  Incluisao automatica 												  
				Ĵ
				Uso		  Generico 																  
				Ĵ
				Parmetros cAlias     = Nome do alias                                 
				           cTudoOk    = Nome da Funcao TudoOk                         
				           nOpcaoAuto = Numero da aRotina                             
				           nLinha     = Linha que esta o registro correto             
				ٱ
				
				
				*/
Function AxIncluiAuto(cAlias,cTudoOk,cTransact,nOpcaoAuto,nlinha)
    Local i
    Local lAppEnd
    nOpcaoAuto := If (nOpcaoAuto == Nil,3,nOpcaoAuto)

    If !( nOpcaoAuto == 3 )
        (cAlias)->(DbGoTo(nLinha))
    EndIf

    bCampo := {|nCPO| Field(nCPO) }

    If cTudoOk != NIL
        If ! &cTudoOk
            AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
            AutoGRLog("Processo invalido")
            AutoGRLog(Replicate("-",80))
            Return 3
        EndIf
    EndIf

    Begin Transaction
        lAppEnd := If (nOpcaoAuto == 3,.t.,.f.)
        RecLock(cAlias,lAppEnd)
        For i := 1 TO FCount()
            If "_FILIAL"$Field(i)
                FieldPut(i,xFilial(cAlias))
            Else
                FieldPut(i,M->&(Eval(bCampo,i)))
            EndIf
        Next i
        If cTransact != Nil
            cTransact += Iif("("$cTransact,"","()")
            lX := &cTransact
        EndIf
    End Transaction
Return 1

				/*
				
				
				Ŀ
				Funo	 MSArrayXDB   Autor  Alex Sandro Valario  Data  14/10/98 
				Ĵ
				Descrio  Retorna Array espelhando na Tabela SX3 						  
				Ĵ
				ParametrosaVetor1  = Array contEndo informacoes do arquivo Texto      
				          lVirtual = Se estiver .T. retornara Array espelhado no SX3  
				          nOpcAuto = Numero da operacao a ser executada               
				          lItens   = .T. indica que as validacoes sera feira para     
				                     itens e se nao encontrar o registro acrescemta no
				                     aVetor1 este parametro eh para casos de alteracao
				          cFuncArray = Contera funcao de montagem do Array para os cam
				                       pos que forem validados                        
				Ĵ
				Uso		  Generico 																  
				ٱ
				
				
				*/
Function MsArrayXDB(aVetor1,lVirtual,nOpcAuto,lItens,cFuncArray)
    Local nX,nAchoFilial:=0
    Local ac:={}
    Local nOrderSX3
    Local nPosTemp
    Local cAlias := upper(Alias())
    Local uConteudo := NIL
    Local cValid := ""
    Local nConta, nPosicao
    Local aConteudo := {}
    Local cMontaSeek := "", cPosiciona:= xFilial(Alias())
    Local aArea := {}, aChave := {}
    Local cOrdemSIX, cOriSIX, cString, cPalavra := ""
    Local lIndex := .f. //Verifica se tem que montar procura por campos informados
    Local cVerifica := "", aCpos := {}
    Local lachou := .T.
    lItens := If (lItens == Nil,.F.,lItens)

    nOpcAuto := if(nOpcAuto==NIL,3,nOpcAuto)
    If type("INCLUI")# "L"
        _SetOwnerPrvt("inclui",nOpcAuto==3)
    EndIf
    If type("ALTERA")# "L"
        _SetOwnerPrvt("altera",nOpcAuto==4)
    EndIf

    For nX := 1 To Len(aVetor1)
        If ( aVetor1[nX,3] <> NIL .and. subs(aVetor1[nX,3],1,1) == "#" )
            lIndex := .T.
            Exit
        EndIf
    Next
    nOrderSX3:= SX3->(IndexOrd())
    SX3->(DbSetOrder(1))
    SX3->(DbSeek(cAlias))

    If ( Upper(Alltrim(aVetor1[Len(aVetor1),1])) != "INDEX" )
        aadd(aVetor1,{"INDEX",1})
    EndIf

    // Aceita passagem de filial para manutencao de registros
    If (nAchoFilial:=Ascan(aVetor1,{|x| "_FILIAL" $ Upper(AllTrim(x[1]))})) > 0
        cMontaSeek:=aVetor1[nAchoFilial,2]
        If ValType(cMontaSeek) # "C"
            cMontaSeek:=xFilial(cAlias)
        EndIf
    Else
        cMontaSeek:=xFilial(cAlias)
    EndIf

    cOrdemSIX  := AllTrim(Str(aVetor1[Len(aVetor1),2]))
    cOriSIX    := cOrdemSIX
    cOrdemSIX  := RetAsc(cOrdemSIX,1,.T.)
    aDel(aVetor1,Len(aVetor1))
    aSize(aVetor1,Len(aVetor1)-1)
    aArea := GetArea()
    dbSelectArea("SIX") //Localiza no Sindex
    If dbSeek(cAlias+cOrdemSIX)
        cString := AllTrim(CHAVE)+"+"
        //> para conseguir adicionar o ultimo campo
        For nX := 1 to   Len(cString)
            If ( subs(cString,nX,1) != "+" )
                cPalavra := cPalavra + subs(cString,nX,1)
            Elseif (Subs(cPalavra,3) == "_FILIAL")
                cPalavra := ""
            Else
                If Left(cPalavra,5)=="DTOS("
                    cPalavra:= Subs(cPalavra,6)
                    cPalavra:= StrTran(cPalavra,")","")
                EndIf
                nPosicao := Ascan(aVetor1,{|x| AllTrim(x[1]) == AllTrim(cPalavra)})
                If nPosicao > 0
                    If lIndex .and. aVetor1[nPosicao,3] <> nil .and. subs(aVetor1[nPosicao,3],1,1) == "#"
                        aadd(aChave,cPalavra)
                        cPalavra := ""
                        If Len(aVetor1[nPosicao,3]) > 1
                            If Empty(cVerifica)
                                cVerifica := "AllTrim("+subs(aVetor1[nPosicao,3],2) +") == '"+AllTrim(aVetor1[nPosicao,2])+"'"
                            Else
                                cVerifica := cVerifica +" .AND. AllTrim("+subs(aVetor1[nPosicao,3],2) +") == '"+AllTrim(aVetor1[nPosicao,2])+"'"
                            EndIF
                            aVetor1[nPosicao,3] := Nil
                            cPosiciona := cPosiciona + aVetor1[nPosicao,2]
                        Else
                            aVetor1[nPosicao,3] := Nil
                        EndIf
                    Elseif !lIndex
                        aadd(aChave,cPalavra)
                        cPalavra := ""
                    Else
                        exit
                    EndIf
                Else
                    exit
                EndIf
            EndIf
        End
    Else
        AutoGRLog(Dtoc(MsDate())+' '+Time() )
        AutoGRLog("Nao encontrado o indice "+cAlias+" do alias "+cOrdemSIX)
        AutoGRLog(Repl("-",80))
    EndIf
    RestArea(aArea)

    lVirtual := If (lVirtual == Nil,.T.,lVirtual)
    nOpcAuto := If (nOpcAuto == Nil,3,nOpcAuto)

    //ATENCAOĿ
    //A variavel cVerifica deve estar vazia somente se for alteracao  
    //de cabecalho e itens na mesma tabela. Ex.: SC1 (Solic. de Venda 
    //
    If Empty(cVerifica)
        cVerifica := ".T."
    EndIf

    //Ŀ
    //Se for exclusao ou alteracao primeiro posicionar o registro   
    //
    If ( nOpcAuto == 4 ) .or. ( nOpcAuto == 5 )
        For nConta := 1 To Len(aChave)
            nPosicao := Ascan(aVetor1,{|x| AllTrim(x[1]) == AllTrim(achave[nconta])})
            If ( nPosicao > 0 )
                cMontaSeek := cMontaSeek + If(ValType(aVetor1[nPosicao,2])=="D",Dtos(aVetor1[nPosicao,2]),aVetor1[nPosicao,2])
                aadd(aConteudo,If(ValType(aVetor1[nPosicao,2])=="D",Dtos(aVetor1[nPosicao,2]),aVetor1[nPosicao,2]))
            EndIf
        Next
        If ( ValType(cOriSIX) == "C" )
            nIndAnt := IndexOrd()
            dbsetOrder(val(cOriSIX))
        EndIf
        If !(DbSeek(cMontaSeek))
            lachou := .F.
            If !lItens .or. !&cVerifica
                AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )
                For nConta := 1 To Len(aConteudo)
                    AutoGRLog(aChave[nConta]+" := "+aConteudo[nConta])
                Next
                AutoGRLog("Pesquisa nao encontrada com dados acima")
                AutoGRLog(Repl("-",80))
                Return aC := {}
            EndIf
            //A variavel cPosiciona esta os dados para procura somente dos
            //campos principais (que passaram validacao no array)
            If lItens .and. lIndex
                DbSeek(cPosiciona)
            EndIf
        EndIf
        If ( ValType(cOriSIX) == "C" )
            dbsetOrder(nIndAnt)
        EndIf
    EndIf
    //Ŀ
    //Verifica se deverah validar os campos, somente nos que foram passado 
    //
    If ( cFuncArray <> Nil )
        aCpos := If (valType(cFuncArray) == "A",aClone(cFuncArray),&cFuncArray)
    EndIf
    For nX := 1 To Len(aVetor1)
        If ( Upper(subs(aVetor1[nX,1],1,3)) == "AUT" )
            If Len(aVetor1[nX]) >= 4
                aadd(aC,{aVetor1[nX,1],aVetor1[nX,2],aVetor1[nX,3],aVetor1[nX,4]})
            Else
                aadd(aC,{aVetor1[nX,1],aVetor1[nX,2],aVetor1[nX,3]})
            EndIf
        EndIf
    Next
    While ( ! Sx3->(eof()) .and. Sx3->X3_ARQUIVO == cAlias )
        If ( lVirtual ) .and. (SX3->X3_CONTEXT == "V") .and. nOpcAuto <> 4
            Sx3->(DbSkip())
            Loop
        EndIf
        If 	 ( SX3->X3_TIPO == "C" )
            uConteudo := Space(Sx3->X3_TAMANHO)
        ElseIf ( SX3->X3_TIPO == "D" )
            uConteudo := CToD("")
        ElseIf ( SX3->X3_TIPO == "N" )
            uConteudo := 0
        Elseif ( SX3->X3_TIPO == "L" )
            uConteudo := .F.
        Else
            uConteudo := ""
        EndIf
        nPosTemp := Ascan(aVetor1,{|x| AllTrim(Upper(x[1])) == AllTrim(SX3->X3_CAMPO)})
        //Ŀ
        //se for inclusao validar todos                            
        //se for alteracao validar somente o que pode ser alterado 
        //se for exclusao nao validar nenhum                       
        //
        If (nOpcAuto == 3)
            If Empty(aCpos)
                cValid := Upper(AllTrim( SX3->X3_VALID ))
            Else
                cValid := If ( Ascan(aCpos,{|x|x == Alltrim(SX3->X3_CAMPO)}) > 0,Upper(AllTrim( SX3->X3_VALID )),"")
            EndIf
        Elseif nOpcAuto == 4
            If ( nPosTemp # 0 )
                If Empty(aCpos)
                    cValid := If(!("x" $ SX3->(Substr(FirstBitOff(Bin2Str(x3_usado)),101,1))),Upper(AllTrim( SX3->X3_VALID )),"")
                Else
                    cValid := If ( Ascan(aCpos,{|x|x == Alltrim(SX3->X3_CAMPO)}) > 0,Upper(AllTrim( SX3->X3_VALID )),"")
                EndIf
            Else
                cValid := ""
            EndIf
        else
            cValid := ""
        EndIf

        If ( nPosTemp # 0 )
            uConteudo := aVetor1[nPosTemp,2]
            If (aVetor1[nPosTemp,3] # NIL  )
                cValid	  := aVetor1[nPosTemp,3]
            EndIf
        Elseif (nOpcAuto == 4) .and. (!lItens .or. lachou) // se for cabecalho ou se tiver sucesso na pesquida
            If fieldpos(AllTrim(SX3->X3_CAMPO)) > 0
                uConteudo := FieldGet(fieldpos(AllTrim(SX3->X3_CAMPO)))
            EndIf
        EndIf
        If ( Empty(cValid) )
            cValid := ".t."
        EndIf
        //Ŀ
        //Se uConteudo for do tipo caracter entao colocar a variavel do tamanho do campo do SX3
        //
        If Valtype(uConteudo) == "C"
            IF SX3->X3_TIPO != "M"
                uConteudo := PadR(uConteudo,Sx3->X3_TAMANHO)
            EndIf
        EndIf
        If nPosTemp # 0
            aadd(aC,{SX3->X3_CAMPO,uConteudo,cValid,.T.})
        Else
            aadd(aC,{SX3->X3_CAMPO,uConteudo,cValid,.F.})
        EndIf

        Sx3->(DbSkip())
    End
    SX3->(DbSetOrder(nOrderSX3))
Return aC

				/*
				
				
				Ŀ
				Funo	 MsVldGAuto Autor  Alex Sandro Valario    Data 14/10/1998
				Ĵ
				Descrio Valida os gets Automaticos											  
				Ĵ
				Uso		  																			  
				ٱ
				
				
				*/
Function MsVldGAuto(aValidGet)
    Local nX
    Local bBlock
    Local lObrigat
    Local lObriAuto
    Local nOrderSX3

    Private Inclui := If (Type("Inclui") # "L",.t.,Inclui)
    Private Altera := If (Type("Altera") # "L",.f.,Altera)
    If Type("lMSErroAuto") == "U"
        Private lMSErroAuto := .F.
    EndIf
    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto := .t.
    EndIf
    If ( Empty(aValidGet))
        aValidGet := aClone(aAutoCab)
        For  nX := 1 To Len(aValidGet)
            aadd(aValidGet[nx],.f.)
        Next
    EndIf

    nOrderSX3:= SX3->(IndexOrd())
    SX3->(DbSetOrder(2))
    For nX := 1 to Len(aValidGet)
        If ( aValidGet[nX,1] = "AUT" ) //Variavel serah utilizada dentro dos programas
            Loop
        EndIf
        AutoReadVar  := "M->" +Upper(AllTrim(aValidGet[nX,1]))
        //	If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. ! Empty(aValidGet[nX,2])
        If Type("&AutoReadVar")== "U" .or. Empty(&AutoReadVar) .or. ! Empty(aValidGet[nX,2])
            lInit := .f.
            If ExistIni(Subs(AutoReadVar,4))
                lInit := .t.
                &AutoReadVar := InitPad(SX3->X3_RELACAO)
                If ValType(&AutoReadVar) = "C"
                    &AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
                EndIf
                If &AutoReadVar == NIL .or. !Empty(aValidGet[nX,2]) // aqui foi alterado
                    lInit := .f.
                EndIf
            EndIf
            If !lInit
                &AutoReadVar := aValidGet[nX,2]
            EndIf
        EndIf
        If ( Empty(aValidGet[nX,2]) )
            aValidGet[nX,2] := &AutoReadVar
        EndIf
        If ( Empty(aValidGet[nx,3]) )
            aValidGet[nX,3] := " .t. "
        EndIf
        __READVAR := Upper(AllTrim(AutoReadVar))
        SX3->(DbSetOrder(2))
        IF SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
            lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
            lObriAuto:= aValidGet[nX,4]
            If (lObrigat .or. ! Empty(&AutoReadVar) .or. lObriAuto )
                bBlock := &( "{ || " + AllTrim( aValidGet[nX,3 ] ) + " }" )
                If SX3->X3_VISUAL # "V"
                    If ! Eval( bBlock )
                        MsLogCab(aValidGet,AutoReadVar)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                    SX3->(DbSetOrder(2))
                    SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
                    If SX3->(X3_TRIGGER) == "S"
                        RunTrigger(1)
                    EndIf
                    If lMsErroAuto
                        MsLogCab(aValidGet,AutoReadVar)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                EndIf
            EndIf
        Else
            bBlock := &( "{ || " + AllTrim( aValidGet[nX,3 ] ) + " }" )
            If ! Eval( bBlock )
                MsLogCab(aValidGet,AutoReadVar)
                lMsHelpAuto := .F.
                SX3->(DbSetOrder(nOrderSX3))
                Return .f.
            EndIf
        EndIf
    Next
    SX3->(DbSetOrder(nOrderSX3))
Return .t.

				/*
				
				
				Ŀ
				Funo	 MsVldAcAuto Autor Alex Sandro Valario    Data 14/10/1998
				Ĵ
				ParametrosaValidGet = aCols                                           
				          cLinhaOk  = Dispara a funcao de Linha Ok                    
				          cTudoOk   = Dispara a funcao de Tudo Ok                     
				          cTmpAlias = Se estiver trabalhando com GetDb passar o alias 
				                      do arquivo temporario                           
				          OpcAuto   = n da rotina a ser disparada, baseada no aRotina 
				          cChaPes   = Se for alteracao com cabecalho e itens,passar a 
				                      chave de pesquisa do acols. Ex: "??_ITEM"       
				Ĵ
				Descrio Valida os gets Automaticos (aCols)								  
				Ĵ
				Uso		  																			  
				ٱ
				
				
				*/
Function MsVldAcAuto(aValidGet,cLinhaOk,cTudoOk,cTmpAlias,OpcAuto,cChaPes)
    //Ŀ
    //  A variavel cTmpAlias so sera usada quando se estiver        
    //  trabalhando com a funcao MSGETDB                            
    //

    Local nX,nY
    Local bBlock
    Local nPos
    Local lObrigat
    Local nOrderSX3
    Local nP_aHeader, nP_aCols,nP_aAutoIt
    Private Inclui := .t.
    Private Altera := .f.
    Private n
    //esta variavel simula a cCampo da GetDados
    Private cCampo
    OpcAuto := If (OpcAuto == Nil,3,OpcAuto)
    Private o
    If Type("lMSErroAuto") == "U"
        Private lMSErroAuto := .F.
    EndIf
    If Type("lMsHelpAuto") == "U"
        Private lMsHelpAuto := .t.
    EndIf
    nOrderSX3:= SX3->(IndexOrd())
    SX3->(DbSetOrder(2))
    If GetMV('MV_VEICULO')=='S'
        MsCodVei()  // utilizado para codigos auxiliares
    EndIf
    If !( cTmpAlias == NIL )
        (cTmpAlias)->(dbGoTop())
    EndIf
    For nX := 1 to Len(aCols)
        If ( OpcAuto == 4 .and. ValType(cChaPes) == "C")
            If !( aAutoItens[nX,1,1] == nil )
                nP_aHeader := ascan(aHeader,{|x| Upper(Alltrim(x[2])) == Upper(Alltrim(cChaPes))})
                nP_aAutoI  := ascan(aAutoItens[nX],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(cChaPes))})
                If ( aAutoItens[nX,nP_aAutoI,2]!=aCols[nX,nP_aHeader] )
                    Loop
                EndIf
            Else
                Loop
            EndIf
        EndIf
        n:= nX
        If !( cTmpAlias == NIL )
            If ( OpcAuto != 4 )
                RecLock(cTmpAlias,.t.)
            Elseif (OpcAuto == 4 )
                RecLock(cTmpAlias,.F.)
            EndIf
        EndIf

        For nY := 1 to Len(aCols[nX])- 1
            // criar todas variaveis de memoria
            AutoReadVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))
            &AutoReadVar := aCols[nX,nY]
            If !( cTmpAlias == NIL )
                (cTmpAlias)->(FieldPut(nY,aCols[nX,nY]))
            EndIf
        Next
        For nY := 1 to Len(aCols[nX])- 1
            nPos := Ascan(aAutoItens[nX],{|x| Alltrim(Upper(x[1])) == Alltrim(Upper(aHeader[nY,2]))})
            If nPos == 0
                Loop
            EndIf
            If ( ! Empty(nPos) ) .and. ( aAutoItens[nX,nPos,2] # NIL ) .and. ! Empty(aAutoItens[nX,nPos,2])
                If ( ValType(aAutoItens[nX,nPos,2])=="C")
                    aCols[nX,nY] := Padr(aAutoItens[nX,nPos,2],aHeader[nY,4] )
                Else
                    aCols[nX,nY] := aAutoItens[nX,nPos,2]
                EndIf
            EndIf
            //Ŀ
            //Quando a tabela temporaria for atualizada em alguma validacao       
            //atualizarah tambem o acols                                          
            //
            If !( cTmpAlias == NIL )
                If Empty(aCols[nX,nY]) .and. !Empty((cTmpAlias)->(FieldGet(ny)))
                    aCols[nX,nY] := (cTmpAlias)->(FieldGet(ny))
                EndIf
            EndIf

            AutoReadVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))

            If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. ! Empty(aCols[nX,nY])
                lInit := .f.
                If ExistIni(Subs(AutoReadVar,4))
                    lInit := .t.
                    &AutoReadVar := InitPad(SX3->X3_RELACAO)
                    If ValType(&AutoReadVar) = "C"
                        &AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
                    EndIf
                    If &AutoReadVar == NIL	.or. !Empty(aCols[nX,nY])
                        lInit := .f.
                    EndIf
                EndIf
                //Ŀ
                //Manter a variavel de memoria caso uma validacao as atualize e NAO tenha   
                //sido mensionada no arquivo texto                                          
                //
                If Empty(aCols[nX,nY]) .and. !Empty(&AutoReadVar)
                    lInit := .T.
                EndIf
                //Ŀ
                //Se o inicializador nao estiver ativo volta o valor do aCOLS para a variavel de
                //memoria, mas caso esteja ativo e nao tenha sido mencionado no arquivo texto   
                //entao atualiza o aCOLS                                                        
                //
                If !lInit
                    &AutoReadVar := aCols[nX,nY]
                ElseIf !aAutoItens[nX,nPos,4] .and. Empty(aCols[nX,nY]) .and. !Empty(&AutoReadVar)
                    aCols[nX,nY] := &AutoReadVar
                EndIf
            EndIf
            //Ŀ
            //Caso alguma validacao atualize a variavel manter o que foi passado
            //
            If ( &AutoReadVar != aCols[nX,nY] .and. !Empty(aCols[nX,nY]) )
                &AutoReadVar := aCols[nX,nY]
            EndIf
            If 	 ( ValType(aCols[nX,nY]) =="C")
                &AutoReadVar := Padr(aCols[nX,nY],aHeader[nY,4] )
            EndIf
            //Ŀ
            //Variaveis de sistema       
            //
            If OpcAuto <> 3
                cCampo    :=  aCols[nX,nY]
            Else
                cCampo    := CriaVar(aHeader[nY,2])
            EndIf
            __READVAR := Upper(AllTrim(AutoReadVar))

            If !( cTmpAlias == NIL )
                (cTmpAlias)->(FieldPut(nY,&AutoReadVar))
            EndIf

            SX3->(DbSetOrder(2))
            SX3->(DbSeek(Upper(AllTrim(aHeader[nY,2]))))
            lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
            If (lObrigat .or. ! Empty(&AutoReadVar))
                bBlock := &( "{ || " + AllTrim( aHeader[ny,6 ] ) + " }" )
                If SX3->X3_VISUAL # "V"
                    If ! Eval( bBlock )
                        MsLogCab(aValidGet,AutoReadVar)
                        MSLogItens(aHeader,aCols,AutoReadVar,n)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                    SX3->(DbSetOrder(2))
                    SX3->(DbSeek(Upper(AllTrim(aHeader[nY,2]))))
                    If SX3->(X3_TRIGGER) == "S"
                        RunTrigger(2,nX)
                    EndIf
                    If lMsErroAuto
                        MsLogCab(aValidGet,AutoReadVar)
                        MSLogItens(aHeader,aCols,AutoReadVar,n)
                        lMsHelpAuto := .F.
                        SX3->(DbSetOrder(nOrderSX3))
                        Return .f.
                    EndIf
                EndIf
            EndIf
        Next
        If !( cTmpAlias == NIL )
            (cTmpAlias)->(MSUnLock())
        EndIf


        If !( cTmpAlias == Nil )
            (cTmpAlias)->(dbCommit())
        EndIf

        If cLinhaOk != NIL
            If ! &cLinhaOk
                MsLogCab(aValidGet,"Inconsistencia na Linha de Itens")
                MSLogItens(aHeader,aCols,"Inconsistencia na Linha de Itens",nX)
                lMsHelpAuto := .F.
                SX3->(DbSetOrder(nOrderSX3))
                Return .f.
            EndIf
        EndIf
    Next
    If cTudoOk != NIL
        If ! &cTudoOk
            MsLogCab(aValidGet,"Inconsistencia nos Itens")
            MSLogItens(aHeader,aCols,"Inconsistencia nos Itens ",n)
            lMsHelpAuto := .F.
            SX3->(DbSetOrder(nOrderSX3))
            Return .f.
        EndIf
    EndIf
    SX3->(DbSetOrder(nOrderSX3))
Return .t.

				/*
				
				
				Ŀ
				Funo	 MsAuto2aCols Autor  Alex Sandro Valario  Data 21/10/1998
				Ĵ
				Descrio  Atualiza aCols conforme aAutoItens						  
				Ĵ
				ParametrosnOpcao    = N da rotina a ser executada                    
				          TempAlias = Se for GetDb passar o Alias (temporario)        
				          cChaPes   = Se for alteracao com cabecalho e itens,passar a 
				                      chave de pesquisa do acols. Ex: "??_ITEM"       
				          ExpL5: Indica se o aheader deve ser atualizado              
				Ĵ
				Uso		  Rotina Automatica 										  
				ٱ
				
				
				*/
Function MsAuto2aCols(nOpcao,TempAlias,cChaPes,lChkIni,lAtuHead)
    Local nX         := 0
    Local nY         := 0
    Local nR         := 0
    Local nC         := 0
    Local nPos       := 0
    Local nRecPos    := 0
    Local nPosicao   := 0
    Local nPosDeleta := 0
    Local nLenHead	 := 0
    Local nH         := 0
    Local aPosicao   := {}
    Local aTempVetor := {}

    DEFAULT lChkIni  := .F.
    DEFAULT lAtuHead := .F.
    //Ŀ
    // Validacoes dos Parametros                                    
    //
    nOpcao    := If (nOpcao == NIL,3,nOpcao)
    TempAlias := If (TempAlias == NIL,"",TempAlias)
    cChaPes   := If (cChaPes == nil,"",cChaPes)

    //Ŀ
    // Determina tamanho do aHeader verificando se utiliza campos de WalkThru
    //
    If Ascan(aHeader,{|x| UPPER(x[1]) == "ALIAS WT"}) > 0
        nLenHead:= Len(aHeader)-2
    Else
        nLenHead:= Len(aHeader)
    EndIf

    //Ŀ
    // Para os casos que estiverem usando o MSGETDB                 
    //
    If ( Empty(aCols) )
        If ( nOpcao == 3 )
            aCols := Array(1,Len(aHeader))
            For nH := 1 To Len(aHeader)
                If ( aHeader[nH,8] == "C" )
                    acols[1,nH] := Space(aHeader[nH,4])
                ElseIf ( aHeader[nH,8] == "N" )
                    acols[1,nH] := 0
                ElseIf ( aHeader[nH,8] == "D" )
                    acols[1,nH] := dDataBase
                ElseIf aHeader[nY,8] == "M"
                    acols[1,nH] := ""
                Else
                    acols[1,nH] := .f.
                EndIf
            Next
            aadd(acols[1],.f.) //nH ja tera o numero total do aHeader + 1
        Else
            ntotLin := (TempAlias)->(RecCount())
            nTotCol := (TempAlias)->(fCount())
            aCols := Array(ntotLin,nTotCol)
            For nR := 1 To ntotLin
                RecLock(TempAlias,.F.)
                For nC := 1 To nTotCol
                    nPosicao := Ascan(aAutoItens[1],{|x| AllTrim(x[1]) == AllTrim((TempAlias)->(FieldName(nC)))})
                    If nPosicao > 0
                        //Ŀ
                        //Atualiza tabela temporaria da GetDB, somente se aAutoItens estiver com algum valor
                        //
                        If !Empty(aAutoItens[nR,nPosicao,2])
                            (TempAlias)->(FieldPut(nC,aAutoItens[nR,nPosicao,2]))
                        EndIf
                        aCols[nR,nC] := (TempAlias)->(FieldGet(nC))
                    EndIf
                Next
                (TempAlias)->(MSUnLock())
                (TempAlias)->(DbSkip())
            Next
        EndIf
    Else
        //Ŀ
        //Se for alteracao no caso de cabecalho e itens no mesmo arquivo
        //somente atualizar o acols e sair da funcao                    
        //
        If ( nOpcao == 4 )
            For nR := 1 To Len(aHeader)
                If ( Empty(aHeader[nR,6]) )
                    aHeader[nR,6] := ".t."
                EndIf
                nPos := ascan(aAutoItens[1],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(aHeader[nR,2]))})
                If ( nPos > 0 )
                    aAdd(aPosicao,nPos)
                EndIf
            Next
            nPos     := ascan(aAutoItens[1],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(cChaPes))})
            nPosicao := ascan(aHeader,{|x| Upper(Alltrim(x[2])) == Upper(Alltrim(cChaPes))})
            For nR := 1 To Len(aAutoItens)
                nPos_aCols := aScan(aCols,{|x| Upper(Alltrim(x[nPosicao])) == Upper(Alltrim(aAutoItens[nr,nPos,2]))})
                If ( nPos_aCols > 0 .and. AllTrim(aAutoItens[nR,nPos,2]) == AllTrim(aCols[nPos_aCols,nPosicao]))
                    For nC := 1 To Len(aCols[nPos_aCols])-1
                        If lChkIni
                            If aAutoItens[nR,aPosicao[nC],4]
                                aCols[nPos_aCols,nC] := aAutoItens[nR,aPosicao[nC],2]
                            EndIf
                        Else
                            If nR <= len(aAutoItens) .and. nC <= len(aPosicao) //Sandro
                                aCols[nPos_aCols,nC] := aAutoItens[nR,aPosicao[nC],2]
                            EndIf
                        EndIf
                    Next
                Else
                    aSize(aCols,Len(aCols)+1)
                    aCols[len(aCols)] := {}
                    For nC := 1 To nLenHead
                        aAdd(aCols[len(aCols)],aAutoItens[nR,aPosicao[nC],2])
                    Next
                    aAdd(aCols[len(aCols)],.f.)
                    nPos_aCols := aScan(aCols,{|x| Upper(Alltrim(x[nPosicao])) == Upper(Alltrim(aAutoItens[nr,nPos,2]))})
                EndIf
                nPosDeleta := ascan(aAutoItens[nR],{|x| Upper(Alltrim(x[1])) == "AUTDELETA"})
                If ( nPosDeleta > 0 )
                    aCols[nPos_aCols,nC] := (Upper(aAutoItens[nR,nPosDeleta,2]) == "S")
                EndIf
            Next
            aTempVetor := Array(Len(aCols),Len(aAutoItens[1]),Len(aAutoItens[1,1]))
            For nX := 1 To Len(aAutoItens)
                For nC := 1 To Len(aCols)
                    If ( AllTrim(Upper(aCols[nC,nPosicao])) == AllTrim(Upper(aAutoItens[nX,nPos,2])))
                        aCopy(aAutoItens[nX],aTempVetor[nC],1,Len(aAutoItens[nX]))
                    EndIf
                Next
            Next
            aAutoItens := aClone(aTempVetor)
            Return
        EndIf
    EndIf
    // Atualizando os Valids do aHeader conforme array automatico esta vindo como parametros
    For nX := 1 To Len(aHeader)
        nPos := Ascan(aAutoItens[1],{|x| AllTrim(Upper(x[1])) == AllTrim(Upper(aHeader[nX,2]))})
        If !Empty(nPos) .And. aAutoItens[1,nPos,3] # NIL .And. lAtuHead
            aHeader[nX,6] := aAutoItens[1,nPos,3]
        EndIf
        If ( Empty(aHeader[nX,6]) )
            aHeader[nX,6] := ".t."
        EndIf
    Next
    If ( nOpcao == 3 )
        For nX := 1 To Len(aAutoItens)
            If ( nX > 1 )
                aadd(aCols,aClone(aCols[nX -1]))
                For nY := 1 to Len(aCols[nX])-1
                    If 	 aHeader[nY,8] == "C"
                        aCOLS[nX][nY] := SPACE(aHeader[nY,4])
                    ElseIf aHeader[nY,8] == "N"
                        aCOLS[nX][nY] := 0
                    ElseIf aHeader[nY,8] =="D"
                        aCOLS[nX][nY] := dDataBase
                    ElseIf aHeader[nY,8] == "M"
                        aCOLS[nX][nY] := ""
                    Else
                        aCOLS[nX][nY] := .F.
                    EndIf
                Next
            EndIf
            For nY := 1 To (Len(aCols[1]) - 1)
                nPos := Ascan(aAutoItens[1],{|x| AllTrim(Upper(x[1])) == AllTrim(Upper(aHeader[nY,2]))})
                If ( ! Empty(nPos) ) .and. ( aAutoItens[nX,nPos,2] # NIL  )
                    If ( ValType(aAutoItens[nX,nPos,2])=="C")
                        aCols[nX,nY] := Padr(aAutoItens[nX,nPos,2],aHeader[nY,4] )
                    Else
                        aCols[nX,nY] := aAutoItens[nX,nPos,2]
                    EndIf
                EndIf
            Next
        Next
    EndIf
Return




				/*
				
				
				Ŀ
				Funo	 MsLogCab	   Autor  Alex Sandro Valario  Data 21/10/1998
				Ĵ
				Descrio  Grava no log do Cab													  
				Ĵ
				Uso		  Rotina Automatica 													  
				ٱ
				
				
				*/

Function MsLogCab(aValidGet,AutoReadVar)
    Local nX
    Local cConteudo
    Local uVar
    Local uVar2
    Local nT := 0
    AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )

    For nX := 1 To Len(aValidGet)
        uVar := aValidGet[nX,1]
        uVar2:= aValidGet[nX,2]
        If 	 (ValType(uVar2) == "C")
            cConteudo := uVar2
        ElseIf (ValType(uVar2) == "N")
            cConteudo := Str(uVar2)
        ElseIf (ValType(uVar2) == "D")
            cConteudo := DtoC(uVar2)
        ElseIf (ValType(uVar2) == "L")
            cConteudo := If(uVar2,"True","False")
        ElseIf (ValType(uVar2) == "M")
            cConteudo := "Memo"
        ElseIf (ValType(uVar2) == "U")
            cConteudo := "Nil"
        EndIf
        If (Padr(Upper(aValidGet[nX,1]),12) == Padr(Subs(Upper(AutoReadVar),4),12))
            cErro := " < -- Invalido"
            nT := nT + 1
        Else
            cErro := ""
        EndIf
        SX3->(DbSeek(Trim(aValidGet[nX,1])))
        AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aValidGet[nX,1],12)+":="+cConteudo+cErro)
    Next
    If Empty(nT)
        AutoGRLog("Erro --> "+AutoReadVar)
    EndIf
    AutoGRLog(Repl("-",80))
Return

				/*
				
				
				Ŀ
				Funo	 MsLogItens   Autor  Alex Sandro Valario  Data 21/10/1998
				Ĵ
				Descrio  Grava no log de Itens												  
				Ĵ
				Uso		  Rotina Automatica 													  
				ٱ
				
				
				*/
Function MSLogItens(aHeader,aCols,AutoReadVar,n)
    Local cConteudo
    Local uVar
    Local nT := 0
    Local nY := 0
    AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )
    AutoGRLog("Erro no Item "+str(n,3))
    AutoGRLog(Repl("-",80))
    For nY := 1 To Len(aCols[n]) -1
        uVar := aCols[n,nY]
        If 	 (aHeader[nY,8] == "C")
            cConteudo := uVar
        ElseIf (aHeader[nY,8] == "N")
            cConteudo := Str(uVar)
        ElseIf (aHeader[nY,8] == "D")
            cConteudo := DtoC(uVar)
        ElseIf (aHeader[nY,8] == "L")
            cConteudo := If(uVar,"True","False")
        ElseIf (aHeader[nY,8] == "M")
            cConteudo := "Memo"
        ElseIf (aHeader[nY,8] == "U")
            cConteudo := "Nil"
        EndIf
        If (Padr(Upper(aHeader[nY,2]),12) == Padr(Subs(Upper(AutoReadVar),4),12))
            cErro := " < -- Invalido"
            nT ++
        Else
            cErro := ""
        EndIf
        SX3->(DbSeek(Trim(aHeader[nY,2])))
        AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aHeader[nY,2],12)+":="+cConteudo+cErro)
    Next
    If Empty(nT)
        AutoGRLog("Erro -->  "+AutoReadVar)
    EndIf
    AutoGRLog(Repl("-",80))
Return

				/*
				
				
				ͻ
				Programa  MostraErroAutor  Valdir/Sandro        Data   12/07/00   
				͹
				Desc.     Mostra erros do processo automatico ********.log na Tela    
				                                                                      
				͹
				Uso        AP5                                                        
				ͼ
				
				
				*/
Function MostraErro(cPath,cNome)
    Local oDlg
    Local cMemo
    Local cFile    :=""
    Local cMask    := STR0043 //"Arquivos Texto (*.TXT) |*.txt|"
    Local oFont
    Local cStartPath := GetSrvProfString("Startpath","")

    cPath := If(cPath = Nil, "", cPath)
    cNome := If(cNome = Nil, __cFileLog, cNome)
    DEFAULT __cFileLog := Criatrab(,.f.)+".LOG"
    cMemo :=MemoRead(__cFileLog)

    If Empty(cPath)
        DEFINE FONT oFont NAME "Courier New" SIZE 5,0   //6,15

        DEFINE MSDIALOG oDlg TITLE __cFileLog From 3,0 to 340,417 PIXEL

        @ 5,5 GET oMemo  VAR cMemo MEMO SIZE 200,145 OF oDlg PIXEL
        oMemo:bRClicked := {||AllwaysTrue()}
        oMemo:oFont:=oFont

        DEFINE SBUTTON  FROM 153,175 TYPE 1 ACTION oDlg:End() ENABLE OF oDlg PIXEL //Apaga
        DEFINE SBUTTON  FROM 153,145 TYPE 13 ACTION (cFile:=cGetFile(cMask,OemToAnsi(STR0044)),If(cFile="",.t.,MemoWrite(cFile,cMemo)),oDlg:End()) ENABLE OF oDlg PIXEL //Salva e Apaga //"Salvar Como..."
        DEFINE SBUTTON  FROM 153,115 TYPE 6 ACTION (PrintAErr(__cFileLog,cMemo),oDlg:End()) ENABLE OF oDlg PIXEL //Imprime e Apaga

        ACTIVATE MSDIALOG oDlg CENTER
    Else
        ConOut(STR0046 + cNome)  //"Processo nao concluido. Verificar arquivo "
        Copy File (cStartPath + "\" + __cFileLog) To (cPath + "\" + cNome)
    EndIf
    Ferase(__cFileLog)
    __cFileLog := Nil
Return(cMemo)

Static Function PrintAErr(cFileErro,cConteudo)//Imprime o autoerro.log
    Local nLin := 0
    Local nX   := 0
    Default cConteudo := ""

    CursorWait()
    If IsTelnet() .Or. IsBlind()
        While !IsPrinter()
            If !MsgRetryCancel(OemToAnsi(STR0045),OemToAnsi(STR0001)) //"Impressora no est pronta."###"Ateno"
                Return .T.
            Endif
        Enddo
        RptStatus({|lEnd| __CopyFile(cFileErro,"Lpt1")} )
    Else
        Private aReturn:= {STR0059, 1,STR0060, 1, 2, 1, "",1 }

        SetPrint(,cFileErro,nil ,STR0061,cFileErro,'','',.F.,"",.F.,"M")
        If nLastKey <> 27
            SetDefault(aReturn,"")
            nLinha:= MLCount(cConteudo,132)
            For nX:= 1 To nLinha
                nLin++
                If nLin > 80
                    nLin := 1
                    @ 00,00 PSAY AvalImp(132)
                Endif
                @ nLin,000 PSAY Memoline(cConteudo,132,nX)
            Next nX
            Set device to Screen
            MS_FLUSH()
        EndIf
    EndIf
Return .T.




				/*
				
				
				Ŀ
				Funo    TemBxCanc  Autor  Andreia Santos         Data  09/12/98 
				Ĵ
				Descrio VerIfica se a baixa do titulo foi cancelada                 
				          Caso no seja passada a Chave, o SE5 deve estar posicionado 
				          para a montagem da Chave.                                   
				Ĵ
				Sintaxe   TemBxCanc()                                                 
				Ĵ
				 Uso      Financeiro                                                  
				ٱ
				
				
				*/
Function TemBxCanc(cChave,lBxFut, cFil)
    LOCAL aArea    := GetArea()
    LOCAL aAreaSE5 := SE5->(GetArea())
    LOCAL lRet 	   := .F.
    LOCAL cQuery   := ""
    LOCAL cAlias   := ""
    DEFAULT lBxFut := .F.
    DEFAULT cFil := xFilial("SE5")

    dbSelectArea("SE5")
    cChave := If(cChave==Nil,E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ,cChave)
    If !Empty(cChave)
        // Se o SE5 nao estiver posicionado, posiciona para encontrar os estornos
        // do titulo correto, tanto em SQL como em CDX
        If !(IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL))
            If SE5->&(IndexKey()) != xFilial("SE5")+cChave .And. !Empty(IndexKey(7))
                dbSetOrder( 7 )
                dbSeek(cFil+cChave)
            Endif
        EndIf
    Endif

    #IFDEF TOP
        If ( TcSrvType()!="AS/400" )
            If Select("__NewSe5") == 0
                ChkFile("SE5",.F.,"__NewSe5")
            Endif
            dbSelectArea("__NewSe5")
        Endif
    #ENDIF

    #IFDEF TOP
        If ( TcSrvType()!="AS/400" )
            cQuery := "SELECT Count(*) ESTORNO FROM "+RetSqlName("Se5")+" WHERE "
            If IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL)
                cQuery += "E5_FILIAL='"+SE2->E2_FILIAL+"' AND "
            Else
                cQuery += "E5_FILIAL='"+cFil+"' AND "
            Endif
            cQuery += "E5_PREFIXO='"+SE5->E5_PREFIXO+"' AND "
            cQuery += "E5_NUMERO='"+SE5->E5_NUMERO+"' AND "
            cQuery += "E5_PARCELA='"+SE5->E5_PARCELA+"' AND "
            cQuery += "E5_TIPO='"+SE5->E5_TIPO+"' AND "
            cQuery += "E5_CLIFOR='"+SE5->E5_CLIFOR+"' AND "
            cQuery += "E5_LOJA='"+SE5->E5_LOJA+"' AND "
            cQuery += "E5_SEQ='"+SE5->E5_SEQ+"' AND "
            cQuery += "E5_TIPODOC='ES' AND "
            If !lBxFut
                cQuery += "E5_DATA <= '"+DTOS(dDataBase)+"' AND "
            EndIf
            cQuery += "D_E_L_E_T_<>'*'"
            cQuery := ChangeQuery(cQuery)
            cAlias := "__BXCAN"
            dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

            If ( (cAlias)->(ESTORNO) > 0 )
                lRet := .T.
            EndIf
            dbSelectArea(cAlias)
            dbCloseArea()
            dbSelectArea("__NewSe5")
        Else
        #ENDIF
        While !Eof() .and. cChave ==E5_PREFIXO+E5_NUMERO+;
                E5_PARCELA+E5_TIPO + E5_CLIFOR +E5_LOJA + E5_SEQ
            If ( E5_TIPODOC =="ES" ) .and. Iif (!lBxFut,E5_DATA <= dDataBase,.T.)
                lRet := .T.
                Exit
            EndIf
            dbSkip()
        EndDo
        #IFDEF TOP
        EndIf
    #ENDIF
    RestArea(aAreaSE5)
    RestArea(aArea)
Return lRet

				/*
				
				
				Ŀ
				Funo	  FirstDay  Autor  Cesar C S Prado		   Data  09/02/94 
				Ĵ
				Descrio  Devolve o 1o. dia de um mes.										  
				Ĵ
				 Uso		  Generico 																  
				ٱ
				
				
				*/
Function FirstDay(dData)
    Local cData := Dtos(dData)
    cData := "01/"+SubStr(cData,5,2)+"/"+Substr(cData,1,4)
Return ( Ctod(cData,"ddmmyy") )

				/*
				
				
				Ŀ
				Funo	 A207Um 	 Autor  Rodrigo de A. Sartorio Data  14.01.99 
				Ĵ
				Descrio Gravar no arquivo SAH o conteudo da tabela 62 do SX5		  
				ٱ
				
				
				*/
Function A207Um()
    Local cAlias	:= Alias()

    If AliasInDic("SAH")
        DbSelectArea("SAH")

        If !dbSeek(xFilial("SAH"))
            DbSelectArea("SX5")
            DbSeek(xFilial()+"62")

            While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"62"
                Reclock("SAH",.T.)
                Replace AH_FILIAL With xFilial()
                Replace AH_UNIMED With Substr(SX5->X5_CHAVE,1,Len(AH_UNIMED))
                Replace AH_UMRES  With Substr(X5Descri(),1,Len(AH_UMRES))
                Replace AH_DESCPO With Substr(X5Descri(),1,Len(AH_DESCPO))
                Replace AH_DESCIN With Substr(X5Descri(),1,Len(AH_DESCIN))
                Replace AH_DESCES With Substr(X5Descri(),1,Len(AH_DESCES))
                MsUnlock()
                DbSelectArea("SX5")
                DbSkip()
            End
        EndIf
    Else
        Aviso(OemToAnsi(STR0001),OemToAnsi(STR0058),{"Ok"})  //"O arquivo SAH deve ser incluido neste MNU."
    EndIf
    DbSelectArea(cAlias)
Return .t.

				/*
				
				
				Ŀ
				Funo	 A508Grupo  Autor  Alex Sandro Valario    Data  12.05.00 
				Ĵ
				Descrio Gravar no arquivo SBM o conteudo da tabela 03 do SX5		  
				ٱ
				
				
				*/
Function A508Grupo()
    Local cAlias	:= Alias()
    If AliasInDic("SBM")
        DbSelectArea("SBM")
        If FWModeAccess("SBM",3) == "C" // SBM Compartilhada
            If LastRec() == 0
                DbSelectArea("SX5")
                DbSeek(xFilial()+"03")
                While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"03"
                    Reclock("SBM",.T.)
                    Replace BM_FILIAL With xFilial()
                    Replace BM_GRUPO With Substr(SX5->X5_CHAVE,1,Len(BM_GRUPO))
                    Replace BM_DESC  With Substr(X5Descri(),1,Len(BM_DESC))
                    MsUnlock()
                    DbSelectArea("SX5")
                    DbSkip()
                End
            EndIf
        Else // SBM Exclusiva
            If !dbSeek(xFilial("SBM"))
                DbSelectArea("SX5")
                DbSeek(xFilial()+"03")
                While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"03"
                    Reclock("SBM",.T.)
                    Replace BM_FILIAL With xFilial()
                    Replace BM_GRUPO With Substr(SX5->X5_CHAVE,1,Len(BM_GRUPO))
                    Replace BM_DESC  With Substr(X5Descri(),1,Len(BM_DESC))
                    MsUnlock()
                    DbSelectArea("SX5")
                    DbSkip()
                End
            EndIf
        EndIf
    EndIf
    DbSelectArea(cAlias)
Return .T.

				/*
				
				
				Ŀ
				Funo	 AvalQtdPre Autor Rodrigo de A. Sartorio  Data 21/01/1999
				Ĵ
				Descrio  Funcao generica para avaliar se considera ou nao quantidade
							  prevista de acordo com o parametro MV_QTDPREV			     
				Ĵ
				Sintaxe	  AvalQtdPre(ExpC1,ExpN1,ExpL1,ExpC2)  					        
				Ĵ
				Parametros ExpC1 = Alias a ser pesquisado							        
							  ExpN1 = Tipo da quantidade a ser pesquisada		       	  
							  		  1 = Saldo Empenhado								        
							  		  2 = Saldo Previsto para Entrada		    		     
							  		  3 = 1+2											           
							  ExpL1 = Pesquisa da Segunda Unidade de Medida              
							  ExpC2 = Alias da query a ser utilizada                     
							  ExpL2 = Considera qtd prev independente do parametro       
				Ĵ
				Uso		  GENERICO MATERIAIS									              
				ٱ
				
				
				*/
Function AvalQtdPre(cAlias,nTipo,lSegUM,cQuery,lEmpPrev)
    //Ŀ
    // Variavel utilizada para verIficar se considera qtd prevista ou nao 
    //
    Static lConsPrev:=NIL
    Local nRetorno:=0

    DEFAULT cQuery := cAlias
    DEFAULT lEmpPrev:= .F.

    lSegUM := If(lSegUM==NIL, .F., lSegUM)
    If (lConsPrev == NIL)
        lConsPrev := If(GetMV("MV_QTDPREV")== "S",.T.,.F.)
    EndIf
    If lConsPrev .Or. lEmpPrev
        If nTipo == 1
            If cAlias == "SB2"
                nRetorno := If(lSegUM,(cQuery)->B2_QEPRE2,(cQuery)->B2_QEMPPRE)
            ElseIf cAlias == "SB8"
                nRetorno := If(lSegUM,(cQuery)->B8_QEPRE2,(cQuery)->B8_QEMPPRE)
            ElseIf cAlias == "SBF"
                nRetorno := If(lSegUM,(cQuery)->BF_QEPRE2,(cQuery)->BF_QEMPPRE)
            EndIf
        ElseIf nTipo == 2
            If cAlias == "SB2"
                nRetorno := If(lSegUM, ConvUM((cQuery)->B2_COD,(cQuery)->B2_SALPPRE,0,2),(cQuery)->B2_SALPPRE)
            EndIf
        ElseIf nTipo == 3
            If cAlias == "SB2"
                nRetorno := If(lSegUM,(cQuery)->B2_QEPRE2+ConvUM((cQuery)->B2_COD,(cQuery)->B2_SALPPRE,0,2),(cQuery)->B2_QEMPPRE+(cQuery)->B2_SALPPRE)
            ElseIf cAlias == "SB8"
                nRetorno := If(lSegUM,(cQuery)->B8_QEPRE2,(cQuery)->B8_QEMPPRE)
            ElseIf cAlias == "SBF"
                nRetorno := If(lSegUM,(cQuery)->BF_QEPRE2,(cQuery)->BF_QEMPPRE)
            EndIf
        EndIf
    EndIf
Return nRetorno

				/*
				
				Ŀ
				Funo	  GetArea() Autor  Fernando G/Sergio	   Data  07/10/97 
				Ĵ
				Descrio  Guarda a area de trabalho              						  
							  															              
				Ĵ
				Sintaxe	  ExpA1 := GetArea()										           
				Ĵ
				Parametros ExpC1: Alias da tabela que pode estar em insert.Quando este
							        parametro  informado o sistema nao reposiciona o    
							  		 recno quando a restarea for executada				     
							  NAO SERVE PARA SALVAR A AREA PASSADA COMO PARAMETRO !!!    
				Ĵ
				Retorno	  ExpA1 													              
				ٱ
				
				*/
Function GetArea(cSqlAlias)
    If cSqlAlias<>Nil .And. cSqlAlias==Alias()
        Return( { Alias(), IndexOrd(), Nil } )
    Else
        Return( { Alias() , IndexOrd() , RecNo() })
    EndIf

				/*
				
				Ŀ
				Funo	 RestArea() Autor  Fernando G/Sergio	   Data  07/10/97 
				Ĵ
				Descrio  Restaura a area de trabalho										  
							  																			  
				Ĵ
				Sintaxe	  RestArea( ExpA1 ) 													  
				Ĵ
				Uso		  LOJAXFUN 																  
				Ĵ
				Parametro  ExpA1 -> Vetor contEndo a area ( retornado pela GetArea() )
				ٱ
				
				*/

Function RestArea( aArea )
    If !Empty(aArea[ 1 ] )
        If Select(aArea[ 1 ]) > 0
            DbSelectArea( aArea[ 1 ] )
            If aArea[ 2 ] <> IndexOrd()
                DbSetOrder( aArea[ 2 ] )
            EndIf
            If ( aArea[ 3 ] <> Nil .And. aArea[ 3 ] <> RecNo() ) // Melhoria de Performace para o Top Connect
                DbGoTo( aArea[ 3 ] )
            EndIf
        Endif
    EndIf
Return( nil )

				/*
				
				Ŀ
				Funo	 LjMsgRun	 Autor  Fernando Godoy		   Data  11/03/98 
				Ĵ
				Descrio Executa um Bloco de cdigo e aguarda o retorno.				  
				Ĵ
				Uso		 Sigaloja																	  
				ٱ
				
				*/
function LjMsgRun( cCaption, cTitle, bAction, cCor )

    Local oDlg, nWidth
    Local oFont

    DEFINE FONT oFont NAME "Arial" SIZE 6,14 BOLD

    DEFAULT cCaption := STR0021,;  //"Aguarde por favor...",;
        bAction	:= { || Inkey( 1 ) }

    If cTitle == NIL
        DEFINE DIALOG oDlg ;
            FROM 0,0 TO 3, Len( cCaption ) + 8 ;
            STYLE nOr( DS_MODALFRAME, WS_POPUP )
        oDlg:SetFont(oFont)
        nWidth := oDlg:nRight - oDlg:nLeft
        @ 2,0 Say xPadc(cCaption,nWidth) 	 of oDlg PIXEL
    Else
        DEFINE DIALOG oDlg ;
            FROM 0,0 TO 4, Max( Len( cCaption ), Len( cTitle ) ) + 8 ;
            TITLE cTitle ;
            STYLE DS_MODALFRAME
        oDlg:SetFont(oFont)
        nWidth := oDlg:nRight - oDlg:nLeft
        @ 2,0 Say xPadc(cCaption,nWidth) 	 of oDlg PIXEL
    EndIf

    oDlg:bStart := { || Eval( bAction, oDlg ), oDlg:End()}
    oDlg:cMsg	:= cCaption

    ACTIVATE DIALOG oDlg CENTER
    //	ON PAINT oDlg:Say( 1, 0, xPadC( oDlg:cMsg, nWidth ),CLR_RED )

    oFont:End()

return nil

				/*
				
				Ŀ
				Funo	 Numeral	 Autor  Fernando Godoy		   Data  11/03/98 
				Ĵ
				Descrio Retorna a forma numeral de um nmero inteiro. 				  
							 Nemros de 1 a 100.													  
				Ĵ
				Uso		 Sigaloja																	  
				ٱ
				
				*/
Function Numeral(nNumero)
    Local cRetorno := ""
    Local aNum_1	:= {}
    Local aNum_2	:= {}

    //Ŀ
    // Carrega o Array com os nuemros bsicos 
    //
    Aadd( aNum_1, Oemtoansi(STR0023))  // Primeiro
    Aadd( aNum_1, Oemtoansi(STR0024))  // Segundo
    Aadd( aNum_1, Oemtoansi(STR0025))  // Terceiro
    Aadd( aNum_1, Oemtoansi(STR0026))  // Quarto
    Aadd( aNum_1, Oemtoansi(STR0027))  // Quinto
    Aadd( aNum_1, Oemtoansi(STR0028))  // Sexto
    Aadd( aNum_1, Oemtoansi(STR0029))  // Stimo
    Aadd( aNum_1, Oemtoansi(STR0030))  // Oitvo
    Aadd( aNum_1, Oemtoansi(STR0031))  // Nono

    //Ŀ
    // Carrega Array com os nmeros iniciais de cada dezena 
    //
    Aadd( aNum_2, Oemtoansi(STR0032))  // Dcimo
    Aadd( aNum_2, Oemtoansi(STR0033))  // Vigsimo
    Aadd( aNum_2, Oemtoansi(STR0034))  // Trigsimo
    Aadd( aNum_2, Oemtoansi(STR0035))  // Quatragsimo
    Aadd( aNum_2, Oemtoansi(STR0036))  // Quinquagsimo
    Aadd( aNum_2, Oemtoansi(STR0037))  // Sextoagesimo
    Aadd( aNum_2, Oemtoansi(STR0038))  // Septoagesimo
    Aadd( aNum_2, Oemtoansi(STR0039))  // Octoagesimo
    Aadd( aNum_2, Oemtoansi(STR0040))  // Nonoagesimo
    Aadd( aNum_2, Oemtoansi(STR0041))  // Centsimo
    If nNumero <= 10
        If nNumero == 10
            cRetorno := aNum_2[1]
        Else
            cRetorno := aNum_1[nNumero]
        EndIf
    ElseIf nNumero <= 20
        If nNumero == 20
            cRetorno := aNum_2[2]
        Else
            cRetorno := aNum_2[1] + Space(1) + ( aNum_1[nNumero - 10] )
        EndIf
    ElseIf nNumero <= 30
        If nNumero == 30
            cRetorno := aNum_2[3]
        Else
            cRetorno := aNum_2[2] + Space(1) + ( aNum_1[nNumero - 20] )
        EndIf
    ElseIf nNumero <= 40
        If nNumero == 40
            cRetorno := aNum_2[4]
        Else
            cRetorno := aNum_2[3] + Space(1) + ( aNum_1[nNumero - 30] )
        EndIf
    ElseIf nNumero <= 50
        If nNumero == 50
            cRetorno := aNum_2[5]
        Else
            cRetorno := aNum_2[4] + Space(1) + ( aNum_1[nNumero - 40] )
        EndIf
    ElseIf nNumero <= 60
        If nNumero == 60
            cRetorno := aNum_2[6]
        Else
            cRetorno := aNum_2[5] + Space(1) + ( aNum_1[nNumero - 50] )
        EndIf
    ElseIf nNumero <= 70
        If nNumero == 70
            cRetorno := aNum_2[7]
        Else
            cRetorno := aNum_2[6] + Space(1) + ( aNum_1[nNumero - 60] )
        EndIf
    ElseIf nNumero <= 80
        If nNumero == 80
            cRetorno := aNum_2[8]
        Else
            cRetorno := aNum_2[7] + Space(1) + ( aNum_1[nNumero - 70] )
        EndIf
    ElseIf nNumero <= 90
        If nNumero == 90
            cRetorno := aNum_2[9]
        Else
            cRetorno := aNum_2[8] + Space(1) + ( aNum_1[nNumero - 80] )
        EndIf
    Else
        cRetorno := aNum_2[10]
    EndIf

Return cRetorno


				/*/
    
    Ŀ
    Funo	  Condicao  Autor  Claudinei M. Benzi     Data  11.02.92  
    Ĵ
    Descrio  Rotina para avaliar condicao de pagamento                   
    Ĵ
    Sintaxe	  ExpA1 := Condicao(ExpN1,ExpC1,ExpN2,ExpD1,ExpN3,ExpA2)	   
    Ĵ
    Parametros ExpA1 = Array contEndo os valores e os vencimentos de cada  
    			  		  parcela.                                             
    			  ExpN1 = Valor total a ser parcelado.                        
    			  ExpC1 = Codigo da condicao de pagamento a ser considerada.  
    			  ExpN2 = Valor do IPI destacado para condicao que obrigue o  
    			  		  IPI a entrar na 1a parcela.                          
    			  ExpD1 = Data inicial para considerar desdobramento 		   
    			  ExpN3 = Valor do ICMS Solidario                             
    			  ExpA2 = Array contEndo a sigla e valor dos impostos calcula-
    			  		  dos para os paises Internacionais (MercoSul...)	   
    			  ExpA3 = Array contendo dados semelhantes ao que teria no    
    			  		  SE4 												   
    Ĵ
    Uso		  Generico                                                    
    Ĵ
     ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      
    Ĵ
     PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO                    
    Ĵ
     Rogerio F.G. 18/11/97B.HUR Alt Cond Pagto Tipo 9                    
     Rogerio F.G. 24/11/97B.HUR Ajuste Valor Cond Pagto tipo 8           
     Lucas        29.06.9816770AAdaptacao para os impostos MercoSul...   
     Aline C.Vale 13.09.99xxxxxxConsistencia do ultimo dia da cond. 3    
     Aline C.Vale 20.09.9918368AAcerto na Cond.Pgto.Tipo 7               
     Aline C.Vale 25.10.9924332ATratar Junta IPI na Cond.Pgto.Tipo 8     
     Sandro       02.03.00xxxxxx|funcionamento sem a existencia da codicao
                                |cadastrada no SE4                        
    ٱ
    
    
				/*/
FUNCTION Condicao(nValTot,cCond,nValIpi,dData0,nValSolid,aImpVar,aE4,nAcrescimo,nInicio3,aDias3)

    Local aDados   := {}
    Local aVenc    := {}
    Local aVencTmp := {}

    Local cAliasSEC:= "SEC"

    Local nX       := 0
    Local nY       := 0
    Local nValRat  := 0
    Local nIpiRat  := 0
    Local nSolRat  := 0
    Local nPosScan := 0
    Local nVlrAcum1:= 0
    Local nVlrAcum2:= 0
    Local nVlrParc := 0
    Local nParcRat := 0
    Local nParcIpi := 0
    Local nParcSol := 0
    Local lAgltDup := (SuperGetMv("MV_AGLDUPB",.F.,"2") == "1")    //"1"-AGLUTINA "2"-NAO AGLUTINA
    Local lDataRef := (SuperGetMv("MV_DATDUPB",.F.,"1") == "1")    //"1"-ULTIMA DATA "2"-DATA INICIAL
    Local lCondVenda := .F.

    #IFDEF TOP
        Local cQuery := ""
        Local nCntFor:= 0
    #ENDIF

    Default nValIpi   := 0
    Default nValSolid := 0

    SE4->(dbSetOrder(1))
    If SE4->(MsSeek(xFilial("SE4")+cCond))
        //
        // Template de GEM - Gestao de Empreendimentos Imobiliarios
        //
        // Verifica se a condicao de pagamento tem vinculado com uma condicao de venda
        //
        If ExistTemplate("GMCondPagto")
            lCondVenda := ExecTemplate("GMCondPagto",.F.,.F.,{cCond,} )
        EndIf

        If SE4->E4_TIPO == "B"

            SEC->(DbSetOrder(1))

            #IFDEF TOP

                aStruSEC := SEC->( dbStruct() )

                cAliasSEC := GetNextAlias()

                cQuery := "SELECT * FROM " + RetSqlName( "SEC" ) + " SEC "
                cQuery += "WHERE "
                cQuery += "EC_FILIAL='"    + xFilial( "SEC" )    + "' AND "
                cQuery += "EC_CODIGO='"    + SE4->E4_CODIGO      + "' AND "
                cQuery += "D_E_L_E_T_=' ' "

                cQuery += "ORDER BY "      + SqlOrder( SEC->( IndexKey() ) )

                cQuery := ChangeQuery( cQuery )

                SEC->( dbCommit() )

                dbUseArea( .T.,"TOPCONN", TcGenQry( ,,cQuery ), cAliasSEC, .F., .T. )

                For nCntFor := 1 To Len(aStruSEC)
                    If ( aStruSEC[nCntFor,2] <> "C" ) .And. ( aStruSEC[nCntFor,2] <> "M" )
                        TcSetField(cAliasSEC,aStruSEC[nCntFor,1],aStruSEC[nCntFor,2],aStruSEC[nCntFor,3],aStruSEC[nCntFor,4])
                    EndIf
                Next nCntFor

            #ELSE

                SEC->(MsSeek(xFilial("SEC")+SE4->E4_CODIGO))

            #ENDIF

            While ( cAliasSEC )->(!Eof()) .And. ( cAliasSEC )->EC_FILIAL == xFilial("SEC") .And.;
                    ( cAliasSEC )->EC_CODIGO == SE4->E4_CODIGO
                nValRat  := NoRound(nValTot   * ( ( cAliasSEC )->EC_RATEIO / 100 ),TamSX3("EC_RATEIO")[2])
                nIpiRat  := NoRound(nValIpi   * ( ( cAliasSEC )->EC_RATEIO / 100 ),TamSX3("EC_RATEIO")[2])
                nSolRat  := NoRound(nValSolid * ( ( cAliasSEC )->EC_RATEIO / 100 ),TamSX3("EC_RATEIO")[2])

                //Ŀ
                // Acumula para calcular diferenca de rateio            
                //
                nParcRat += nValRat
                nParcIpi += nIpiRat
                nParcSol += nSolRat

                Aadd(aDados, { nValRat,nIpiRat,nSolRat, {  ( cAliasSEC )->EC_CODIGO,;
                    ( cAliasSEC )->EC_COND,;
                    ( cAliasSEC )->EC_TIPO,;
                    ( cAliasSEC )->EC_DDD,;
                    ( cAliasSEC )->EC_IPI,;
                    ( cAliasSEC )->EC_SOLID } })
                ( cAliasSEC )->(dbSkip())
            Enddo

            #IFDEF TOP
                //Ŀ
                // Fecha a area de trabalho da query                    
                //
                ( cAliasSEC )->( dbCloseArea() )
                dbSelectArea( "SEC" )
            #ENDIF


            //Ŀ
            // Ajusta a diferenca                                   
            //
            aDados[Len(aDados)][1] += nValTot   - nParcRat
            aDados[Len(aDados)][2] += nValIpi   - nParcIpi
            aDados[Len(aDados)][3] += nValSolid - nParcSol


        Else
            Aadd(aDados, { nValTot,nValIpi,nValSolid,{ SE4->E4_CODIGO,;
                SE4->E4_COND,;
                SE4->E4_TIPO,;
                SE4->E4_DDD,;
                SE4->E4_IPI,;
                SE4->E4_SOLID}})
        Endif
        For nX := 1 to Len(aDados)
            aVencTmp := AvalCond(aDados[nX][1],SE4->E4_CODIGO,aDados[nX][2],dData0,aDados[nX][3],aImpVar,aE4,nAcrescimo,aDados[nX][4],nInicio3,aDias3)
            If Len(aVencTmp) > 0
                For nY := 1 to Len(aVencTmp)
                    //Ŀ
                    // Verifica se o parametro aglutina por data            
                    //
                    nPosScan := If(lAgltDup .AND. ! lCondVenda , Ascan(aVenc,{|x| x[1] == aVencTmp[nY][1]}), 0 )
                    If nPosScan > 0
                        aVenc[nPosScan][2] += aVencTmp[nY][2]
                    ElseIf aVencTmp[nY][2] > 0 .Or. ( cPaisLoc $ 'COL|VEN' .And. aVencTmp[nY][2] >= 0 )
                        Aadd(aVenc,{aVencTmp[nY][1],aVencTmp[nY][2]})
                    Endif
                Next nY
                //Ŀ
                // Verifica se o parametro da data inicial              
                //
                If lDataRef
                    dData0 := aVencTmp[Len(aVencTmp),1]
                Endif
            Endif

        Next nX
    Endif

Return(aVenc)


Function DiaExtenso(dExRef,cExTipo)
    Local aExSemana := {STR0012,STR0013,STR0014,STR0015,STR0016,STR0017,STR0018}
Return( If ( Dow(dExRef) == 0, "", If (cExTipo == "N", aExSemana [Dow(dExRef)], aExSemana [Dow(dExRef)]) ))

Function Ano_Mes(lAno)
    If lAno
        Return STR0019
    Else
        Return STR0020
    EndIf


				/*/
    
    
    Ŀ
    Funo	  CONAOK	 Autor  Pilar S. Albaladejo    Data  01.12.95 
    Ĵ
    Descrio  Mensagem e confirmacao do processamento						  
    Ĵ
    Sintaxe	  CONA0K(void)															  
    ٱ
    
    
				/*/
Function ConaOk()
Return (MsgYesNo(OemToAnsi(STR0042),OemToAnsi(STR0001)))

				/*/
    
    Ŀ
    Funo	  ReadMotBx Autor  Andreia dos Santos	   Data  02/12/98 
    Ĵ
    Descrio Leitura do arquivo SIGAADV.MOT para carregar array aMotBx c/
    			 o Motivo da baixa, se movimenta banco e se gera comissao	  
    Ĵ
    Sintaxe	  ReadMotBx																  
    Ĵ
    Retorno	  Array aMotBx															  
    Ĵ
     Uso		  Generico 																  
    ٱ
    
    
				/*/
Function ReadMotBx()
    Local nHdlMot := 0
    Local nBytes:=0,nTamArq
    Local xBuffer
    Local aMotRead:={}
    Local cFile := "SIGAADV.MOT"

    If __aMotRead == Nil .Or. Empty(__aMotRead)
        __aMotRead := {}

        If ExistBlock("FILEMOT")
            cFile := ExecBlock("FILEMOT",.F.,.F.,{cFile})
        Endif

        If !FILE(cFile)
            nHdlMot := fCreate(cFile)
            If nHdlMot == -1
                HELP(" ",1,"MOT_ERROR")
                Final("Erro F_"+str(ferror(),2)+" em SIGAADV.MOT")
            EndIf
            if __Language == "ENGLISH"
                fWrite(nHdlMot,"NORNORMAL    ASSS"+chr(13)+chr(10))
                fWrite(nHdlMot,"DACEXCHANGE  ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEVDEVOLUTIONANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEBDEBIT CC  PSNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"VENVENDOR    PNNN"+chr(13)+chr(10))
            elseif __Language == "SPANISH"
                fWrite(nHdlMot,"NORNORMAL    ASSS"+chr(13)+chr(10))
                fWrite(nHdlMot,"DACPERMUTA   ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEVDEVOLUCIONANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEBDEBITO CC PSNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"VENTIT.BANCO PNNN"+chr(13)+chr(10))
            else
                fWrite(nHdlMot,"NORNORMAL    ASSS"+chr(13)+chr(10))
                fWrite(nHdlMot,"DACDACAO     ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEVDEVOLUCAO ANNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"DEBDEBITO CC PSNN"+chr(13)+chr(10))
                fWrite(nHdlMot,"VENVENDOR    PNNN"+chr(13)+chr(10))
            endif
            fClose(nHdlMot)
        EndIf

        nHdlMot := FOPEN(cFile,64)

        If nHdlMot <0
            HELP(" ",1,"SIGAADV.MOT")
            Final("SIGAADV.MOT")
        EndIf
        nTamArq:=FSEEK(nHdlMot,0,2)	// VerIfica tamanho do arquivo
        FSEEK(nHdlMot,0,0)			// Volta para inicio do arquivo

        While nBytes<nTamArq

            xBuffer:=Space(19)
            FREAD(nHdlMot,@xBuffer,19)

            AADD(aMotRead,Upper(SubStr(xBuffer,1,03)+"  "+SubStr(xBuffer,04,10)+" "+SubStr(xBuffer,15,01);
                +Space(4)+" "+SubStr(xBuffer,16,01);
                +Space(5)+" "+Substr(xBuffer,14,1);
                +Space(4)+" "+Substr(xBuffer,17,1)))
            nBytes+=19
        EndDo

        __aMotRead := aClone(aMotRead)

        Fclose(nHdlMot)
    Else
        aMotRead := aClone(__aMotRead)
    EndIf
Return aMotRead


				/*
				
				
				Ŀ
				Funo    AgentLock  Autor  Fbio F. Pessoa        Data  06/10/99 
				Ĵ
				Descrio  Loca um arquivo para Leitura e gravaao do AutComm.<caixa> 
				Ĵ
				 Uso       Sigaloja                                                   
				ٱ
				
				
				*/
Function AgentLock(nHandle, cImpressora, lWinFrame, cDirAgent)
    Local lRet      := !(((cImpressora == "BEMATECH") .Or. (cImpressora == "VERIfONE SC552")) .And. lWinFrame)
    Local cLockFile := "AGENTE.LOC"

    While !lRet

        nHandle := FOpen(cDirAgent + cLockFile, 16)
        lRet    := !(nHandle < 0)
        SysRefresh()           // Similar ao ProcessMessage do Delphi

    End

Return lRet

				/*
				
				
				Ŀ
				Funo    AgentUnLock Autor  Fbio F. Pessoa        Data  06/10/99 
				Ĵ
				Descrio  Loca um arquivo para Leitura e gravaao do AutComm.<caixa>  
				Ĵ
				 Uso       Sigaloja                                                    
				ٱ
				
				
				*/
Function AgentUnlock(nHandle)

    FClose(nHandle)

Return .T.

				/*
				
				Ŀ
				Funo     LerLinha  Autor  Jlio Wittwer          Data  20.12.99 
				Ĵ
				Descrio  Le mais uma linha do Arquivo de Retorno CNAB               
				Ĵ
				Sintaxe    cRet := LerLinha(nHandleRet)                               
				Ĵ
				Uso        ReadCnab2()                                                
				ٱ
				
				*/
Static Function LerLinha(nHandle,nMaxLn)
    Local cString := ""
    Local nTotLidos :=0
    Local lCRLF := .T.

    Default nMaxLn := 1000

    cString := Space(nMaxLn)
    FReadLn(nHandle, @cString, nMaxLn, @lCRLF) // Le uma linha ate CR+LF.

    //Se a linha possuir CRLF no seu final
    If lCRLF
        nTotLidos := Len(cString)+2
        //Se a linha NAO possuir CRLF no seu final
    Else
        nTotLidos := Len(cString)
    Endif

Return {cString,nTotLidos}

				/*
				
				
				ͻ
				Funcao    MSCodVei  Autor  Sandro               Data  18/09/2000  
				͹
				Descricao Faz consistencias do cod. auxiliar quando veiculos          
				͹
				Uso        AP5                                                        
				ͼ
				
				
				*/
Function MSCodVei()
    Local nPosAux:= 0, nPosProd:= 0, nX , nY
    Local aItemH:={},aItemA:= {}
    Local cProduto, cCodAux
    nPosAux := ascan(aHeader,{|x| Upper(Subs(x[2],3,7)) == '_CODGRP'})
    If nPosAux > 0
        For nX := len(aHeader) to 1 step -1
            If (Upper(Subs(aHeader[nX,2],3,8)) == '_PRODUTO') .OR. ;
                    (Upper(Subs(aHeader[nX,2],3,8)) == '_COD    ')
                nPosProd := nX
                exit
            EndIf
        Next
        If nPosProd > 0
            aItemH := aClone(aHeader[nPosProd])
            aItemA := aClone(aHeader[nPosAux])
            aHeader[nPosAux] := aClone(aItemH)
            aHeader[nPosProd]:= aClone(aItemA)
            For nY := 1 to len(aCols)
                cProduto := aCols[nY,nPosProd]
                cCodAux  := aCols[nY,nPosAux]
                aCols[nY,nPosAux] := cProduto
                acols[nY,nPosProd]:= cCodAux
            Next
        EndIf
    EndIF
Return

				/*
				
				Ŀ
				Funo    MatGraph   Autor  Rodrigo de A. Sartorio Data  16.05.01 
				Ĵ
				Descrio  Funcao generica para montagem de dialog com grafico        
				Ĵ
				Parametros                                                            
				        01 ExpC1 = Titulo da Janela                                   
				        02 ExpL1 = Flag indicando se inicializa grafico em 3 dimensoes
				        03 ExpL2 = Flag indicando se mostra menu para mudar caracteris
				           ticas do grafico como tipo e numero de dimensoes (2 ou 3)  
				        04 ExpL3 = Indica se muda a cor em cada barra ou faixa de vlr 
				        05 ExpN1 = Indica o tipo inicial do grafico                   
				        06 ExpN2 = Indica a cor inicial dos valores apresentados      
				        07 ExpA1 = Array com os dados a serem apresentados. Dimensoes:
				           [1] Nome a ser colocado no eixo x (Caracter)               
				           [2] Valor do eixo y (Numerico)                             
				        08 ExpC2 = Alias do arquivo de trabalho que contem os dados   
				        09 ExpA2 = Array com os campos que devem ter o conteudo lido  
				           [1] Nome do campo que tem os dados do eixo x (Caracter)    
				           [2] Nome do campo que tem os valores do eixo y (Caracter)  
				Ĵ
				 Uso       Generico                                                   
				ٱ
				
				
				*/
Function MatGraph(cTitle,lGraph3D,lMenuGraph,lMudaCor,nTipoGraph,nCorDefault,aDados,cAliasTrb,aCamposTrb)
    LOCAL oDlgGraph,oGraph
    Local aSize     := MsAdvSize( .T. )
    Local aPosObj   := {}
    Local aObjects  := {}
    Local lSoBarra  := .F.

    DEFAULT lGraph3D   :=.F.
    DEFAULT lMenuGraph :=.T.
    DEFAULT lMudaCor   :=.F.
    DEFAULT nTipoGraph :=2
    DEFAULT nCorDefault:=6
    DEFAULT cAliasTrb  :=""

    //Ŀ
    // Efetua os calculos de Auto Size                                        
    //
    aObjects := {}
    AAdd( aObjects, { 100, 100, .T., .T. } )

    aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ]-5, 3, 3 }
    aPosObj := MsObjSize( aInfo, aObjects, , .T. )

    //Ŀ
    // Multiplica por 2 para compatibilizar as dimensoes deste objeto         
    //
    aPosObj[1,1] *= 2
    aPosObj[1,2] *= 2
    aPosObj[1,3] *= 2
    aPosObj[1,4] *= 2

    DEFINE MSDIALOG oDlgGraph TITLE cTitle FROM aSize[7],0 TO aSize[6],aSize[5] PIXEL OF oMainWnd
    oGraph:= GRF_CreateNew(oDlgGraph)
    MontGraph(@oDlgGraph,@oGraph,aDados,cAliasTrb,aCamposTrb,nTipoGraph,nCorDefault,lGraph3D,lMudaCor,@lSoBarra)
    GRF_WinSet(	oGraph,aPosObj[1,1],;	// nTop
    aPosObj[1,2],;              	// nLeft
    aPosObj[1,3],;              	// nBottom
    aPosObj[1,4],0,0,0)         	// nRight
    @ aSize[4]-6,010 SAY STR0057 SIZE 250,6 OF oDlgGraph PIXEL	// "Pressionando o botao da direita do mouse pode-se arrastar o grafico horizontalmente"
    ACTIVATE MSDIALOG oDlgGraph	CENTERED ON INIT MatGTools(@oDlgGraph,@oGraph,lMenuGraph,lSoBarra)
RETURN NIL

				/*
				
				Ŀ
				Funo    MatGTools  Autor  Rodrigo de A. Sartorio Data  16.05.01 
				Ĵ
				Descrio  Funcao generica para montagem de EnchoiceBar dos graficos  
				Ĵ
				Parametros                                                            
				        01 ExpO1 = Objeto da Dialog                                   
				        02 ExpO2 = Objeto do Grafico                                  
				        03 ExpL1 = Flag indicando se mostra menu para mudar caracteris
				        04 ExpL2 = Indica se o grafico so podera ser de barra         
				Ĵ
				 Uso       Generico                                                   
				ٱ
				
				
				*/
Static Function MatGTools(oDlgGraph,oGraph,lMenuGraph,lSoBarra)
    Local oBar
    DEFINE BUTTONBAR oBar SIZE 25,25 3D OF oDlgGraph
    DEFINE BUTTON RESOURCE "FINAL" OF oBar GROUP ACTION oDlgGraph:End() TOOLTIP OemToAnsi(STR0051) //"Abandona"
    If lMenuGraph
        If !lSoBarra
            DEFINE BUTTON RESOURCE "LINE"  OF oBar GROUP ;
                ACTION 	GRF_ChartType(oGraph,1),;
                GRF_FixedGap(oGraph,36) ;
                TOOLTIP STR0052; //"Grfico de Linha"
            PROMPT STR0062
        EndIf
        DEFINE BUTTON RESOURCE "BAR" OF oBar ;
            ACTION 	GRF_ChartType(oGraph,2),;
            GRF_FixedGap(oGraph,20) ;
            TOOLTIP STR0053;  //"Grfico de Barras"
        PROMPT STR0063
        If !lSoBarra
            DEFINE BUTTON RESOURCE "AREA"        OF oBar ;
                ACTION 	GRF_ChartType(oGraph,6),;
                GRF_FixedGap(oGraph,36) ;
                TOOLTIP STR0054; //"Grfico de Area"
            PROMPT STR0064
        EndIf
        DEFINE BUTTON RESOURCE "GRAF2D"      OF oBar GROUP ;
            ACTION 	GRF_Chart3D(oGraph,.f.) ;
            TOOLTIP STR0055; //"Grficos Bidimensionais"
        PROMPT STR0065
        DEFINE BUTTON RESOURCE "GRAF3D"      OF oBar ;
            ACTION 	GRF_Chart3D(oGraph,.t.) ;
            TOOLTIP STR0056;  //"Grficos Tridimensionais"
        PROMPT STR0066
    EndIf
RETURN NIL

				/*
				
				Ŀ
				Funo    MontGraph  Autor  Rodrigo de A. Sartorio Data  16.05.01 
				Ĵ
				Descrio  Funcao que monta o obejto do grafico                       
				Ĵ
				Parametros                                                            
				        01 ExpO1 = Objeto da Dialog                                   
				        02 ExpO2 = Objeto do Grafico                                  
				        03 ExpA1 = Array com os dados a serem apresentados. Dimensoes:
				           [1] Nome a ser colocado no eixo x (Caracter)               
				           [2] Valor do eixo y (Numerico)                             
				        04 ExpC1 = Alias do arquivo de trabalho que contem os dados   
				        05 ExpA2 = Array com os campos que devem ter o conteudo lido  
				           [1] Nome do campo que tem os dados do eixo x (Caracter)    
				           [2] Nome do campo que tem os valores do eixo y (Caracter)  
				        06 ExpN1 = Indica o tipo do grafico                           
				        07 ExpN2 = Indica a cor inicial dos valores apresentados      
				        08 ExpL1 = Flag indicando se inicializa grafico em 3 dimensoes
				        09 ExpL2 = Indica se muda a cor em cada barra ou faixa de vlr 
				        10 ExpL3 = Indica se o grafico so podera ser de barra         
				Ĵ
				 Uso       Generico                                                   
				ٱ
				
				
				*/
Static Function MontGraph(oDlgGraph,oGraph,aDados,cAliasTrb,aCamposTrb,nTipoGraph,nCorDefault,lGraph3D,lMudaCor,lSoBarra)
    Local aArea:=GetArea()
    Local aAreaTrb:={}

    Local nLoop   := 0
    Local lEndData:=.F.

    DEFAULT lSoBarra := .F.

    //Ŀ
    //Zera os dados do grafico                                                
    //
    GRF_InitData( oGraph )
    GRF_Chart3D(oGraph, lGraph3D )
    GRF_FixedGap(oGraph,36)

    If ValType(aDados) == "A" .And. Len(aDados) > 0
        //Ŀ
        // Seta o modelo de grafico lendo as informacoes de um array              
        //
        If Len( aDados ) < 2 .And. nTipoGraph <> 2
            //Ŀ
            // Nao e possivel utilizar area ou linha com 1 coluna                     
            //
            Help( " ", 1, "ATC010BAR" )
            lSoBarra:=.T.
            GRF_ChartType(oGraph, 2 )
        Else
            GRF_ChartType(oGraph, nTipoGraph )
        EndIf
        //Ŀ
        // Percorre o array de colunas                                            
        //
        For nLoop := 1 To Len( aDados )
            nValor := aDados[ nLoop, 2 ]
            //Ŀ
            // Cria a coluna do grafico                                               
            //
            GRF_SetData(oGraph,0,2,nValor,aDados[nLoop,1],nCorDefault)
            lEndData:=.T.
            //Ŀ
            // Muda a Cor Caso Necessario                                             
            //
            If lMudaCor
                nCorDefault++
                If nCorDefault > 18
                    nCorDefault:=0
                EndIf
            EndIf
        Next nLoop
        If lEndData
            GRF_EndData(oGraph,0)
        Endif
    ElseIf Valtype(cAliasTrb) == "C" .And. Select(cAliasTrb) > 0
        GRF_ChartType(oGraph, nTipoGraph )
        //Ŀ
        // Percorre o arquivo de colunas                                          
        //
        dbSelectArea(cAliasTrb)
        aAreaTrb:=GetArea()
        dbGotop()
        While !Eof()
            nValor := FieldGet(FieldPos(aCamposTrb[2]))
            //Ŀ
            // Cria a coluna do grafico                                               
            //
            GRF_SetData(oGraph,0,2,nValor,FieldGet(FieldPos(aCamposTrb[1])),nCorDefault)
            lEndData:=.T.
            //Ŀ
            // Muda a Cor Caso Necessario                                             
            //
            If lMudaCor
                nCorDefault++
                If nCorDefault > 18
                    nCorDefault:=0
                EndIf
            EndIf
            dbSkip()
        End
        RestArea(aAreaTrb)
        If lEndData
            GRF_EndData(oGraph,0)
        Endif

    EndIf
    RestArea(aArea)
RETURN NIL

				/*/
    
    
    Ŀ
    Program   ValidaCont Autor  Pilar S. Albaladejo    Data  24.07.00 
    Ĵ
    Descrio  Valida Conta Contabil no Lcto Contabil                     
    Ĵ
    Retorno    .T. / .F.                                                  
    Ĵ
    Parametros ExpC1 = Conta contabil                                     
               ExpC2 = Tipo do Lancamento                                 
               ExpO1 = Objeto Descricao da conta debito                   
               ExpO2 = Objeto Descricao da conta credito                  
               ExpL1 = Indicador se esta validacao partira da Getdados    
    ٱ
    
    
				/*/
Function ValidaConta(cConta,cTipo,oDescDeb,oDescCrd,lGetDados,lHelp)

    Local aSaveArea		:= GetArea()
    Local lRet			:= .T.
    Local nPosCta
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCT1
    Local cFilCT1		:= xFilial('CT1')
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(1)

    Local bConta 		:= {|x| 	x[2,1] == cConta .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }
    DEFAULT	lHelp		:= .T.

    If CtbInUse()
        //procura no cache das contas ja pesquisada
        If lCache .And. ! Empty(__aCTBConta) .And. ( nPosCta := Ascan( __aCTBConta, bConta) ) > 0
            lRet 		:= __aCTBConta[nPosCta, 1]
            lAchou 		:= __aCTBConta[nPosCta, 3, 1]
            lSintetica 	:= __aCTBConta[nPosCta, 3, 2]
            nRecCT1		:= __aCTBConta[nPosCta, 3, 3]
            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help("  ", 1, "NOCONTAC")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CT1->(dbGoto(nRecCT1))  //posiciona por causa da descricao.

                If cTipo == "1"
                    CtbExibe(cConta,"1",@oDescDeb,,lRet)
                ElseIf cTipo == "2"
                    CtbExibe(cConta,"2",,@oDescCrd,lRet)
                EndIf
            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            dbSelectArea("CT1")
            dbSetOrder(1)

            If !Empty(cConta)
                dbSelectArea("CT1")
                dbSetOrder(1)
                If !dbSeek(xFilial()+cConta)
                    If lHelp
                        Help("  ", 1, "NOCONTAC")
                    EndIf
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf
                If lRet
                    If CT1->CT1_CLASSE != "2"				// Analitica
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf
            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibe(cConta,"1",@oDescDeb,,lRet)
                ElseIf cTipo == "2"
                    CtbExibe(cConta,"2",,@oDescCrd,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBConta, {lRet, {cConta,cTipo,lHelp,cEmpAnt,cFilCT1}, {lAchou,lSintetica,CT1->(Recno())} } )
            Endif
        Endif

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    
    
    Ŀ
    Program   ValidaCust Autor  Pilar S. Albaladejo    Data  24.07.00 
    Ĵ
    Descrio  Valida Centro de Custo no Lcto Contabil                    
    Ĵ
    Retorno    .T. / .F.                                                  
    Ĵ
    Parametros ExpC1 = Centro de Custo Extra Contabil                     
    ٱ
    
    
				/*/
Function ValidaCusto(cCusto,cTipo,oDescCCD,oDescCCC,lGetDados,lHelp)

    Local aSaveArea 	:= GetArea()
    Local lRet			:= .T.
    Local nPosCC
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCTT
    Local cFilCTT		:= xFilial('CTT')
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(2)
    Local bCusto 		:= {|x| 	x[2,1] == cCusto .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }
    DEFAULT lHelp		:= .T.

    If CtbInUse()
        //procura no cache dos Centros de Custo ja pesquisados
        If lCache .And. ! Empty(__aCTBCusto) .And. ( nPosCC := Ascan( __aCTBCusto, bCusto) ) > 0
            lRet 		:= __aCTBCusto[nPosCC, 1]
            lAchou 		:= __aCTBCusto[nPosCC, 3, 1]
            lSintetica 	:= __aCTBCusto[nPosCC, 3, 2]
            nRecCTT 	:= __aCTBCusto[nPosCC, 3, 3]
            lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help("  ", 1, "NOCUSTO")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CTT->(dbGoto(nRecCTT))     // posiciona por causa da descricao

                If cTipo == "1"
                    CtbExibeCC(cCusto,"1",@oDescCCD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCC(cCusto,"2",,@oDescCCC,lRet)
                EndIf
            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !Empty(cCusto)
                dbSelectArea("CTT")
                dbSetOrder(1)
                If __CtbFilVld = Nil
                    __CtbFilVld := ExistBlock("CtbFilVld")
                Endif

                If __CtbFilVld
                    cFilCtt := ExecBlock("CtbFilVld", .F., .F., "CTT")
                Else
                    cFilCtt := xFilial()
                Endif

                If !dbSeek(cFilCtt+cCusto)
                    If lHelp
                        Help("  ", 1, "NOCUSTO")
                    Endif
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf
                If lRet
                    If CTT->CTT_CLASSE != "2"				// Centro de Custo Sintetico
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf
            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibeCC(cCusto,"1",@oDescCCD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCC(cCusto,"2",,@oDescCCC,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBCusto, {lRet, {cCusto,cTipo,lHelp,cEmpAnt,cFilCTT}, {lAchou,lSintetica,CTT->(Recno())} } )
            EndIf
        EndIf

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    
    
    Ŀ
    Program   ValidItem  Autor  Pilar S. Albaladejo    Data  24.07.00 
    Ĵ
    Descrio  Valida Item Contabil  no Lcto Contabil                     
    Ĵ
    Retorno    .T. / .F.                                                  
    Ĵ
    Parametros ExpC1 = Item  contabil                                     
    ٱ
    
    
				/*/
Function ValidItem(cItem,cTipo,oDescItD,oDescItC,lGetDados,lHelp)

    Local aSaveArea 	:= GetArea()
    Local lRet			:= .T.
    Local nPosItem
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCTD
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(3)
    Local cFilCTD		:= xFilial('CTD')
    Local bItem 		:= {|x| 	x[2,1] == cItem .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }
    DEFAULT lHelp		:= .T.

    If CtbInUse()
        //procura no cache dos Itens Contabeis ja pesquisados
        If lCache .And. ! Empty(__aCTBItem) .And. ( nPosItem := Ascan( __aCTBItem, bItem) ) > 0
            lRet 		:= __aCTBItem[nPosItem, 1]
            lAchou 		:= __aCTBItem[nPosItem, 3, 1]
            lSintetica 	:= __aCTBItem[nPosItem, 3, 2]
            nRecCTD 	:= __aCTBItem[nPosItem, 3, 3]
            lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help(" ", 1, "NOITEM")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CTD->(dbGoto(nRecCTD))     // posiciona por causa da descricao

                If cTipo == "1"
                    CtbExibeIt(cItem,"1",@oDescItD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeIt(cItem,"2",,@oDescItC,lRet)
                EndIf

            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !Empty(cItem)
                dbSelectArea("CTD")
                dbSetOrder(1)
                If !dbSeek(xFilial()+cItem)
                    If lHelp
                        Help(" ", 1, "NOITEM")
                    EndIf
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf
                If lRet
                    If CTD->CTD_CLASSE != "2"				// Item Sintetico
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf
            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibeIt(cItem,"1",@oDescItD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeIt(cItem,"2",,@oDescItC,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBItem, {lRet, {cItem,cTipo,lHelp,cEmpAnt,cFilCTD}, {lAchou,lSintetica,CTD->(Recno())} } )
            EndIf
        EndIf

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    
    
    Ŀ
    Program   ValidaCLVL Autor  Pilar S. Albaladejo    Data  24.07.00 
    Ĵ
    Descrio  Valida Classe de Valor no Lcto Contabil                    
    Ĵ
    Retorno    .T. / .F.                                                  
    Ĵ
    Parametros ExpC1 = Classe de Valor                                    
    ٱ
    
    
				/*/
Function ValidaCLVL(cCLVL,cTipo,oDescCVD,oDescCVC,lGetDados,lHelp)

    Local aSaveArea 	:= GetArea()
    Local lRet			:= .T.
    Local nPosClasse
    Local lAchou 		:= .F.
    Local lSintetica 	:= .F.
    Local nRecCTH
    Local cFilCTH		:= xFilial('CTH')
    Local lCache 		:= Findfunction("Ctb_IsCache") .And. Ctb_IsCache(4)
    Local bClasse 		:= {|x| 	x[2,1] == cCLVL .and. ;
        x[2,2] == cTipo .and.;
        x[2,3] == lHelp }

    DEFAULT lHelp  		:= .T.

    If CtbInUse()
        //procura no cache dos Itens Contabeis ja pesquisados
        If lCache .And. ! Empty(__aCTBClVlr) .And. ( nPosClasse := Ascan( __aCTBClVlr, bClasse) ) > 0
            lRet 		:= __aCTBClVlr[nPosClasse, 1]
            lAchou 		:= __aCTBClVlr[nPosClasse, 3, 1]
            lSintetica 	:= __aCTBClVlr[nPosClasse, 3, 2]
            nRecCTH 	:= __aCTBClVlr[nPosClasse, 3, 3]
            lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !lRet .And. !lAchou .And. lHelp
                Help(" ", 1, "NOCLVL")
            EndIf

            If !lRet .And. lAchou .And. lSintetica .And. lHelp
                Help(" ",1,"NOCLASSE")
            EndIf

            If !lGetDados .And. lRet

                CTH->(dbGoto(nRecCTH))     // posiciona por causa da descricao

                If cTipo == "1"
                    CtbExibeCV(cCLVL,"1",@oDescCVD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCV(cCLVL,"2",,@oDescCVC,lRet)
                EndIf

            EndIf

        Else

            lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

            If !Empty(cCLVL)
                dbSelectArea("CTH")
                dbSetOrder(1)
                If !dbSeek(xFilial()+cCLVL)
                    If lHelp
                        Help(" ", 1, "NOCLVL")
                    EndIf
                    lRet := .F.
                Else
                    lAchou := .T.
                EndIf

                If lRet
                    If CTH->CTH_CLASSE != "2"				// Classe de Valor Sintetico
                        If lHelp
                            Help(" ",1,"NOCLASSE")
                        EndIf
                        lRet := .F.
                        lSintetica := .T.
                    EndIf
                EndIf

            EndIf

            If !lGetDados
                If cTipo == "1"
                    CtbExibeCV(cCLVL,"1",@oDescCVD,,lRet)
                ElseIf cTipo == "2"
                    CtbExibeCV(cCLVL,"2",,@oDescCVC,lRet)
                EndIf
            EndIf
            If lCache
                aAdd(__aCTBClVlr, {lRet, {cCLVL,cTipo,lHelp,cEmpAnt,cFilCTH}, {lAchou,lSintetica,CTH->(Recno())} } )
            EndIf
        EndIf

    Endif

    RestArea(aSaveArea)

Return lRet

				/*/
    
    
    Ŀ
    Programa   NGSD1100I Autor  Nilton Pereira         Data 13/07/2001
    Ĵ
    Descrio  Inclusao de insumo no registro da NFE                      
    Ĵ
    Uso        Integracao de entrada das NF com SIGAMNT                   
    Ĵ
    Obs.                                                                  
    ٱ
    
    
				/*/
Function NGSd1100i(cAliasTPZ)
    Local cOrdem,lFound
    Local lQTDCON     := .F.

    Private lTEMSEQR  := NgVerify("STL")
    Private lSEQTPZ   := NgVerify("TPZ")

    DEFAULT cAliasTPZ := "TRBTPZ"

    dbSelectArea("SX3")
    dbSetOrder(2)
    If dbSeek("TPZ_QTDCON")
        lQTDCON := .T.
    EndIf

    dbSelectArea("SD1")
    If !Empty(SD1->D1_ORDEM)
        cOrdem := SD1->D1_ORDEM
        dbSelectArea("STJ")
        dbSetorder(1)
        If DbSeek(xFilial("STJ") + cOrdem)
            lFOUND   := .F.

            //Lana insumo para OS ja terminada
            lTermino := If(STJ->TJ_TERMINO == "S",.T.,.F.)

            dbSelectArea("STL")
            dbSetorder(7)  // ORDEM DE NUMSEQ
            dbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
            While !Eof() .and. STL->TL_FILIAL == xFilial("STL") .and. ;
                    STL->TL_NUMSEQ == SD1->D1_NUMSEQ

                If Trim(STL->TL_CODIGO) == Trim(SD1->D1_COD) .and. ;
                        Trim(STL->TL_ORDEM)  == cOrdem
                    lFound := .T.
                    Exit
                Endif
                DbSkip()
            End

            If !lFOUND .AND. SD1->D1_TIPO != 'D'
                // Verifica se a OS e uma OS em Lote e se j possui insumo aplicado
                dbSelectArea("TR8")
                dbSetOrder(02)
                If dbSeek(xFilial("TR8")+CORDEM)
                    dbSelectArea("STL")
                    dbSetOrder(01)
                    dbSeek(xFilial("STL")+CORDEM)
                    While STL->(!Eof()) .and.  STL->TL_ORDEM == CORDEM
                        If cValToChar(STL->TL_SEQRELA) > "0" .and. Empty(STL->TL_NUMSEQ)
                            RecLock("STL",.F.)
                            dbDelete()
                            MsUnLock("STL")
                        EndIf
                        dbSelectArea("STL")
                        STL->(dbSkip())
                    End
                EndIf
                NGSD1GESTL(CORDEM,SD1->D1_COD)//Grava Insumo realizado

                NGSD1STLSCOM()

                dbSelectArea("STJ")
                Reclock("STJ",.F.)
                STJ->TJ_TIPORET := "S"
                MsUnlock("STJ")
                If lTermino
                    NGFINAL(STJ->TJ_ORDEM,STJ->TJ_PLANO,STJ->TJ_DTPRINI,STJ->TJ_HOPRINI,STJ->TJ_DTPRFIM,STJ->TJ_HOPRFIM)
                EndIf

                //Grava a garantia do insumo
                dbSelectArea("SD1")
                If FieldPos("D1_GARANTI") > 0
                    If SD1->D1_GARANTI == "S"
                        dbSelectArea(cAliasTPZ)
                        If dbSeek(SD1->D1_ITEM)
                            dbSelectArea("TPZ")
                            RecLock("TPZ",.T.)
                            TPZ->TPZ_FILIAL := xFilial("TPZ")
                            TPZ->TPZ_CODBEM := STJ->TJ_CODBEM
                            TPZ->TPZ_TIPORE := STL->TL_TIPOREG
                            TPZ->TPZ_CODIGO := (cAliasTPZ)->TPZ_CODIGO
                            TPZ->TPZ_LOCGAR := (cAliasTPZ)->TPZ_LOCGAR
                            TPZ->TPZ_ORDEM  := (cAliasTPZ)->TPZ_ORDEM
                            TPZ->TPZ_PLANO  := STJ->TJ_PLANO
                            If lSEQTPZ
                                TPZ->TPZ_SEQREL := STL->TL_SEQRELA
                            EndIf
                            TPZ->TPZ_SEQUEN := STL->TL_SEQUENC
                            If Empty(STL->TL_DTFIM)
                                TPZ->TPZ_DTGARA := STL->TL_DTINICI
                            Else
                                TPZ->TPZ_DTGARA := STL->TL_DTFIM
                            EndIf
                            TPZ->TPZ_QTDGAR := (cAliasTPZ)->TPZ_QTDGAR
                            TPZ->TPZ_UNIGAR := (cAliasTPZ)->TPZ_UNIGAR
                            TPZ->TPZ_CONGAR := (cAliasTPZ)->TPZ_CONGAR
                            If lQTDCON
                                TPZ->TPZ_QTDCON := (cAliasTPZ)->TPZ_QTDCON
                            Endif
                            MsUnlock("TPZ")
                        EndIf
                    EndIf
                EndIf
            ElseIf SD1->D1_TIPO == 'D'
                nQtdeDevol := SD1->D1_QUANT
                aOldArea := GetArea()
                dbSelectArea("SD1")
                dbSetOrder(01)
                If dbSeek(xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
                    dbSelectArea("STL")
                    dbSetOrder(07)
                    dbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
                    While !Eof() .AND. STL->TL_FILIAL == xFilial("STL") .AND. STL->TL_NUMSEQ == SD1->D1_NUMSEQ
                        If STL->TL_TIPOREG == "P" .AND. STL->TL_ORIGNFE == "SD1" .AND. STL->TL_ORDEM == SD1->D1_ORDEM
                            RecLock("STL",.f.)
                            If nQtdeDevol >= STL->TL_QUANTID
                                dbDelete()
                            Else
                                nCustoNovo := (STL->TL_CUSTO/STL->TL_QUANTID)
                                STL->TL_QUANTID -= nQtdeDevol
                                STL->TL_CUSTO := nCustoNovo * STL->TL_QUANTID
                            Endif
                            STL->(MsUnlock())
                        Endif
                        dbSkip()
                    End
                Endif
                dbSelectArea("STL")
                dbSetorder(1)
                If !dbSeek(xFilial("STL")+SD1->D1_ORDEM)
                    dbSelectArea("STJ")
                    dbSetorder(1)
                    If dbSeek(xFilial("STJ")+SD1->D1_ORDEM)
                        RecLock("STJ",.F.)
                        STJ->TJ_TIPORET := " "
                        MsUnlock("STJ")
                    Endif
                Else
                    dbSelectArea("STJ")
                    dbSetorder(1)
                    If dbSeek(xFilial("STJ")+SD1->D1_ORDEM)
                        RecLock("STJ",.F.)
                        STJ->TJ_TIPORET := "S"
                        MsUnlock("STJ")
                    Endif
                Endif
                RestArea(aOldArea)
            Endif
        Endif
    Endif
    DbSelectArea("SD1")

Return

				/*/
    
    
    Ŀ
    Funcao    NGGARANSD1 Autor  Elisangela Costa       Data 03/12/2007
    Ĵ
    Descrio Inclusao de garantia do produto utilizado na manutencao     
    Ĵ
    Uso       Integracao de entrada das NF com SIGAMNT                    
    Ĵ
    Obs.                                                                  
    ٱ
    
    
				/*/
Function NGGARANSD1(cAliasTPZ)
    Local nOPGA2 := 0, lQTDCON := .F.
    Local nORDEM  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_ORDEM" })
    Local nCODIDO := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_COD" })
    Local nITEM   := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_ITEM" })
    Private  nQtde  := 0, nQtdeC := 0,cUni   := " ",cCont := " "
    DEFAULT cAliasTPZ := "TRBTPZ"

    If ExistBlock("NGGARESSD1")
        ExecBlock("NGGARESSD1",.F.,.F.)
    Else
        If M->D1_GARANTI = "S" .And. (Empty(acols[n][nORDEM]) .Or. Empty(acols[n][nCODIDO]))
            MsgInfo(STR0067,STR0068) //"Para informar a garantia  necessrio informar a ordem de servio e cdigo do produto."  # "NO CONFORMIDADE"
            Return .F.
        EndIf

        dbSelectArea("SX3")
        dbSetOrder(2)
        If dbSeek("TPZ_QTDCON")
            lQTDCON := .T.
        EndIf

        aUni     := {" ",STR0069,STR0070,STR0020}  //"Dia"#"Semana"#"Mes"
        aCont    := {" ",STR0071,STR0072}  //"Contador 1" # "Contador 2"
        cLocaliz := Space(Len(TPS->TPS_CODLOC))
        cNomLoc  := Space(20)

        If M->D1_GARANTI = "S"

            NGIFDBSEEK("STJ",aCols[n,nORDEM],1)
            lTemCG1 := If(NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_TEMCONT") <> "N",.T.,.F.)
            lTemCG2 := If(NGIFDBSEEK("TPE",STJ->TJ_CODBEM,1,.F.),.t.,.f.)

            dbSelectArea(cAliasTPZ)
            If dbSeek(acols[n][nITEM])

                If !Empty((cAliasTPZ)->TPZ_LOCGAR)
                    cLocaliz := (cAliasTPZ)->TPZ_LOCGAR
                    NGDESLOC((cAliasTPZ)->TPZ_LOCGAR)
                EndIf
                cUni := " "
                nQtde := (cAliasTPZ)->TPZ_QTDGAR
                If (cAliasTPZ)->TPZ_UNIGAR == "D"
                    cUni := STR0069 //"Dia"
                ElseIf (cAliasTPZ)->TPZ_UNIGAR == "S"
                    cUni := STR0070 //"Semana"
                ElseIf (cAliasTPZ)->TPZ_UNIGAR == "M"
                    cUni := STR0020 //"Mes"
                EndIf

                If !Empty((cAliasTPZ)->TPZ_CONGAR)
                    cCont := If((cAliasTPZ)->TPZ_CONGAR == "1",STR0071,STR0072) //"Contador 1" # "Contador 2"
                EndIf
                If lQTDCON
                    nQtdeC := (cAliasTPZ)->TPZ_QTDCON
                EndIf
            EndIf

            If !lQTDCON

                Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0073 Pixel  //"Garantia"

                @ 30,008 Say Oemtoansi(STR0074) Size 47,07 Of oDlg1 Pixel  //"Local"
                @ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGDESLOC(cLocaliz)
                @ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

                @ 45,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
                @ 45,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'
                @ 45,100 Say Oemtoansi(STR0076) Size 47,07 Of oDlg1 Pixel  //"Unidade"
                @ 45,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NGVALINGA(cUni,cCont,1)

                @ 60,008 say OemtoAnSi(STR0077) Size 47,07 Of oDlg1 Pixel  //"Tp Contador"
                @ 60,040 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NGVALINGA(cUni,cCont,2)

                Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA2:=2,If(!NGVALCAMGA(nQtde,cUni,cCont),nOPGA2 := 1,oDlg1:End())},{||nOPGA2:=1,oDlg1:End()}) Centered

            Else
                Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0073 Pixel  //"Garantia"

                @ 1.5,.5 To 3.5,34 LABEL STR0078 OF oDlg1 //"Localizacao"
                @ 30,008 Say Oemtoansi(STR0074) Size 47,07 Of oDlg1 Pixel  //"Local"
                @ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGDESLOC(cLocaliz)
                @ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

                @ 4.0,.5 To 6.0,34 LABEL STR0073+" "+STR0079+" "+STR0080 OF oDlg1 //"Garantia"#"por"#"Tempo"
                @ 65,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
                @ 65,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'
                @ 65,100 Say Oemtoansi(STR0076) Size 47,07 Of oDlg1 Pixel  //"Unidade"
                @ 65,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NGVALINGA(cUni,cCont,1,nQtde)

                @ 6.5,.5 To 8.5,34 LABEL STR0073+" "+STR0079+" "+STR0081 OF oDlg1  //"Garantia"# "por"# "Contador"
                @ 100,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
                @ 100,040 MsGet nQtdeC Size 38,08 Of oDlg1 Pixel  Valid positivo(nQtdeC) Picture '@E 999,999,999' When lTemCG1 .Or. lTemCG2
                @ 100,100 say OemtoAnSi(STR0077) Size 47,07 Of oDlg1 Pixel  //"Tp Contador"
                @ 100,132 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NGVALINGA(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2

                Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA2:=2,If(!NGVALCAMGA(nQtde,cUni,cCont,nQtdeC),nOPGA2 := 1,oDlg1:End())},{||nOPGA2:=1,oDlg1:End()}) Centered
            Endif

            If nOPGA2 == 2

                //Grava informacoes de garantia no arquivo temporario
                dbSelectArea(cAliasTPZ)
                If dbSeek(acols[n][nITEM])
                    RecLock(cAliasTPZ,.F.)
                Else
                    RecLock(cAliasTPZ,.T.)
                    (cAliasTPZ)->TPZ_ITEM := acols[n][nITEM]
                EndIf
                (cAliasTPZ)->TPZ_CODIGO := acols[n][nCODIDO]
                (cAliasTPZ)->TPZ_LOCGAR := cLocaliz
                (cAliasTPZ)->TPZ_ORDEM  := acols[n][nORDEM]
                (cAliasTPZ)->TPZ_QTDGAR := nQtde
                (cAliasTPZ)->TPZ_UNIGAR := cUni
                If cCont == STR0071 //"Contador 1"
                    (cAliasTPZ)->TPZ_CONGAR := "1"
                ElseIf cCont == STR0072 //"Contador 2"
                    (cAliasTPZ)->TPZ_CONGAR := "2"
                Else
                    (cAliasTPZ)->TPZ_CONGAR := ""
                EndIf

                If lQTDCON
                    (cAliasTPZ)->TPZ_QTDCON := nQtdeC
                EndIf
                MsUnLock(cAliasTPZ)
            EndIf
        EndIf
    EndIf

Return .t.

				/*/
    
    
    Ŀ
    Funcao    NGDESLOC   Autor  Elisangela Costa       Data 03/12/2007
    Ĵ
    Descrio Consistencia para mostrar a descricao da Localizacao        
    Ĵ
    Retorno                                                               
    ٱ
    
    
				/*/
Static Function NGDESLOC(cLocaliz)

    dbSelectArea("TPS")
    dbSetOrder(1)
    If dbSeek(xFilial("TPS")+cLocaliz)
        cNomLoc := TPS->TPS_NOME
    EndIf

Return .t.

				/*/
    
    
    Ŀ
    Funcao    NGVALINGA  Autor  Elisangela Costa       Data 03/12/2007
    Ĵ
    Descrio Validacao dos campos de garantia                            
    Ĵ
    Retorno                                                               
    ٱ
    
    
				/*/
Static Function NGVALINGA(cUni,cCont,nTipo,nQtd)

    dbSelectArea("SX3")
    dbSetOrder(2)
    If dbSeek("TPZ_QTDCON")
        If nTipo =2
            If Empty(cCont) .And. !Empty(nQtd)
                MsgStop(STR0082,STR0068) //"Informe qual o tipo do contador." # "NO CONFORMIDADE"
                Return .f.
            EndIf
        Else
            If Empty(cUni) .And. !Empty(nQtd)
                MsgStop(STR0083,STR0068) //"Informe a unidade." #"NO CONFORMIDADE"
                Return .f.
            EndIf
        EndIf
    Else
        If nTipo =2
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0084,STR0068) //"Nao pode ter unidade a garantia controlada por contador." # "NO CONFORMIDADE"
                Return .f.
            EndIf
        Else
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0085,STR0068) // "Nao pode ter contador a garantia controlada por tempo." # "NO CONFORMIDADE"
                Return .f.
            EndIf
        EndIf
    Endif
Return .T.

				/*/
    
    
    Ŀ
    Funcao    NGVALCAMGA Autor  Elisangela Costa       Data 03/12/2007
    Ĵ
    Descrio Valida todos os campos de garantia que foram informados     
              no botao de OK                                              
    Ĵ
    Retorno                                                               
    ٱ
    
    
				/*/
Static Function NGVALCAMGA(nQtde,cUni,cCont,nQtdeC)

    dbSelectArea("SX3")
    dbSetOrder(2)
    If dbSeek("TPZ_QTDCON")

        If Empty(cCont) .And. nQtdeC == 0 .And. Empty(cUni) .And. nQtde == 0
            MsgStop(STR0086,STR0068) //"Entre com as informaes necessrias para gravar a garantia do insumo." # "NO CONFORMIDADE"
            Return .f.
        EndIf

        If Empty(cCont) .And. nQtdeC > 0
            MsgStop(STR0082,STR0068) //"Informe qual o tipo do contador." # "NO CONFORMIDADE"
            Return .f.
        EndIf

        If !Empty(cCont) .And. nQtdeC == 0
            MsgStop(STR0087,STR0068) //"Informe a quantidade para a garantia controlada por contador." # "NO CONFORMIDADE"
            Return .f.
        EndIf

        If Empty(cUni) .And. nQtde > 0
            MsgStop(STR0088,STR0068) // "Informe a unidade para a garantia controlada por tempo." # "NO CONFORMIDADE"
            Return .f.
        EndIf

        If !Empty(cUni) .And. nQtde == 0
            MsgStop(STR0089,STR0068) // "Informe a quantidade para a garantia controlada por tempo." # "NO CONFORMIDADE"
            Return .f.
        EndIf

    Else

        If Empty(cCont) .And. Empty(cUni) .And. nQtde == 0
            MsgStop(STR0086,STR0068) // "Entre com as informaes necessrias para gravar a garantia do insumo." # "NO CONFORMIDADE"
            Return .f.
        EndIf

        If nTipo =2
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0084,STR0068) //"Nao pode ter unidade a garantia controlada por contador."# "NO CONFORMIDADE"
                Return .f.
            EndIf
        Else
            If !Empty(cUni) .And. !Empty(cCont)
                MsgStop(STR0085,STR0068) //"Nao pode ter contador a garantia controlada por tempo." # "NO CONFORMIDADE"
                Return .f.
            EndIf
        EndIf

        If nQtde == 0 .And. (!Empty(cCont) .Or. !Empty(cUni))
            MsgStop(STR0090,STR0068) //""Informe a quantidade." # NO CONFORMIDADE"
            Return .f.
        EndIf

    Endif

    If  !MNT400GF(lTemCG1,lTemCG2)
        Return .f.
    EndIf

Return .t.

				/*
				
				
				Ŀ
				Funo    NGSD1STLSCOM Autor Incio Luiz Kolling   Data 14/07/2005
				Ĵ
				Descrio Grava os campos complementares do SD1 para STL              
				Ĵ
				 Uso      GENERICO                                                    
				ٱ
				
				
				*/
Static Function NGSD1STLSCOM()
    Local nVP      := 0
    Local vVETCAMN := {"_FILIAL","_NUMSEQ","_ORDEM"}
    Local aESTRUT  := {}

    DbSelectArea("STL")
    aESTRUT := DbStruct()

    RecLock("STL",.F.)
    DbSelectArea("SD1")
    For nVP := 1 To Fcount()
        ny := Fieldname(nVP)
        nc := "STL->TL"+Alltrim(Substr(ny,3,Len(ny)))
        cCAMPP := Alltrim(Substr(ny,3,Len(ny)))
        If Ascan(vVETCAMN, {|x| x == Alltrim(Substr(ny,3,Len(ny)))}) = 0
            If Ascan(aESTRUT, {|x| Alltrim(Substr(x[1],3,Len(x[1]))) == cCAMPP}) > 0
                nx   := "SD1->"+Fieldname(nVP)
                &nc. := &nx.
            Endif
        Endif
    Next
    MsUnlock("STL")
Return .t.

				/*
				
				
				Ŀ
				Funo    NGSTLSD3SCOM Autor Incio Luiz Kolling   Data 14/07/2005
				Ĵ
				Descrio Grava os campos complementares do STL para SD3 e vice versa 
				Ĵ
				ParamentrovALIAP  - Alias do arquivo com os valores - Obrigatorio     
				Ĵ
				 Uso      GENERICO                                                    
				ٱ
				
				
				*/
Static Function NGSTLSD3SCOM(vALIAP)
    Local nVP      := 0
    Local cPRER    := If(vALIAP = "STL","D3","TL")
    Local cALIVAL  := If(vALIAP = "STL","STL","SD3")
    Local cALIREC  := If(vALIAP = "STL","SD3","STL")
    Local vVETCAMN := {"_FILIAL","_NUMSEQ","_ORDEM"}
    Local aESTRUT  := {}

    DbSelectArea(cALIREC)
    aESTRUT := DbStruct()

    RecLock(cALIREC,.F.)
    DbSelectArea(cALIVAL)
    For nVP := 1 To Fcount()
        ny := Fieldname(nVP)
        nc := cALIREC+"->"+cPRER+Alltrim(Substr(ny,3,Len(ny)))
        cCAMPP := Alltrim(Substr(ny,3,Len(ny)))
        If Ascan(vVETCAMN, {|x| x == Alltrim(Substr(ny,3,Len(ny)))}) = 0
            If Ascan(aESTRUT, {|x| Alltrim(Substr(x[1],3,Len(x[1]))) == cCAMPP}) > 0
                nx   := cALIVAL+"->"+Fieldname(nVP)
                &nc. := &nx.
            Endif
        Endif
    Next
    MsUnlock(cALIREC)
Return .t.

				/*/
    
    
    Ŀ
    Programa   ULTSEQ1   Autor  Nilton Pereira         Data 13/07/2001
    Ĵ
    Descrio  Incrementa a sequencia do insumo (proxima sequencia)       
    Ĵ
    Uso        Integracao de entrada das NF com SIGAMNT                   
    Ĵ
    Obs.                                                                  
    ٱ
    
    
				/*/
Static Function UltSeq1()
    Local cSEQ := "0  ",lPRIMLO := .T.
    Local nSEQ := 0
    OLDKEY := INDEXORD()
    DbSelectArea("STL")
    DbSetOrder(3)
    DbSeek(xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO)

    While !Eof() .And. STL->TL_FILIAL == xFILIAL('STL') .And. STL->TL_ORDEM == STJ->TJ_ORDEM;
            .And. STL->TL_PLANO == STJ->TJ_PLANO
        If lTEMSEQR
            If Val(stl->tl_seqrela) > 0
                If Val(STL->TL_SEQRELA) > Val(cSEQ)
                    cSEQ := STL->TL_SEQRELA
                Endif
            Else
                If isDigit(Substr(stl->tl_seqrela,1,1))
                Else
                    cSEQ := If(lPRIMLO,stl->tl_seqrela,If(stl->tl_seqrela > cSEQ,stl->tl_seqrela,cSEQ))
                    lPRIMLO := .F.
                Endif
            Endif
        Endif
        nSEQ := MAX(nSEQ,STL->TL_SEQUENC)
        DbSkip()
    End
    DbSetOrder(1)
    If lTEMSEQR
        If !lPRIMLO
            //cSEQR := PADL(Soma1(cSEQ),3)
            cSEQR := PADL(Soma1Old(cSEQ),3)
        Else
            //cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1(cSEQ),3))
            cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1Old(cSEQ),3))
        Endif
    Else
        cSEQR := If(nSEQ == 0,1,nSEQ+1)
    Endif
Return cSEQR

				/*/
    
    
    Ŀ
    Funo     NGSD1100E Autor  Nilton Pereira         Data 13/07/2001
    Ĵ
    Descrio  Exclusao de insumo no registro da NFE ( ESTORNO )          
    Ĵ
    Uso        Integracao de entrada das NF com SIGAMNT                   
    Ĵ
    OBS                                                                   
    ٱ
    
    
				/*/
Function NGSd1100e()
    Local OLDALI,CORDEM, nQuant := 0
    OldAli := Alias()

    If !Empty(SD1->D1_ORDEM)
        cORDEM := SD1->D1_ORDEM
        DbSelectArea("STJ")
        DbSetorder(1)

        IF DbSeek(xFilial("STJ") + cORDEM) .and. stj->tj_situaca == 'L' .and.;
                stj->tj_termino == 'N'
            DbSelectArea("STL")
            DbSetorder(7)

            IF DbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
                DbSelectArea("STN")
                DbSetorder(1)
                If DbSeek(xFilial("STN")+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA)
                    While !Eof() .And. STN->TN_FILIAL = Xfilial("STN") .And.;
                            STN->TN_ORDEM = STL->TL_ORDEM .And. STN->TN_TAREFA = STL->TL_TAREFA;
                            .And. STN->TN_SEQRELA = STL->TL_SEQRELA
                        RecLock("STN",.F.)
                        dbDelete()
                        MSUNLOCK("STN")
                        DbSkip()
                    End
                EndIf
                DbSelectArea("SD1")
                If FieldPos("D1_GARANTI") > 0 .And. SD1->D1_GARANTI == "S"
                    DbSelectArea("TPZ")
                    DbSetOrder(2)
                    cChaTPZ := STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
                    If DbSeek(xfilial("TPZ")+cChaTPZ)
                        While !Eof() .And. TPZ->TPZ_FILIAL = Xfilial("TPZ") .And.;
                                TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO+TPZ->TPZ_SEQREL = cChaTPZ
                            RecLock("TPZ",.F.)
                            dbDelete()
                            MSUNLOCK("TPZ")
                            DbSkip()
                        End
                    EndIf
                EndIf
                DbSelectArea("STL")
                RecLock("STL",.F.)
                dbDelete()
                MSUNLOCK("STL")
            Endif

            If NGCADICBASE("TL_NOTFIS","A","STL",.F.) .And. NGCADICBASE("TL_SERIE","A","STL",.F.)
                dbSelectArea("STL")
                dbSetOrder(4)
                If dbSeek(xFilial("STL")+SD1->D1_ORDEM)
                    aOldArea := GetArea()
                    While !Eof() .AND. STL->TL_FILIAL == xFilial("STL") .AND. STL->TL_ORDEM == SD1->D1_ORDEM
                        If STL->TL_TIPOREG == "P" .AND. STL->TL_ORIGNFE == "SD1" .AND. STL->TL_ORDEM == SD1->D1_ORDEM .AND.;
                                STL->TL_NOTFIS == SD1->D1_NFORI .AND. STL->TL_SERIE == SD1->D1_SERIORI
                            If SD1->D1_TIPO == 'D'
                                nQuant := STL->TL_QUANTID + SD1->D1_QUANT
                            Else
                                nQuant := STL->TL_QUANTID - SD1->D1_QUANT
                            Endif

                            RecLock("STL",.f.)
                            If nQuant <= 0
                                dbDelete()
                            Else
                                nCustoNovo := (STL->TL_CUSTO/STL->TL_QUANTID)
                                STL->TL_QUANTID -= nQtdeDevol
                                STL->TL_CUSTO := nCustoNovo * STL->TL_QUANTID
                            Endif
                            MsUnlock("STL")
                        Endif
                        dbSelectArea("STL")
                        dbSkip()
                    End
                    RestArea(aOldArea)
                Else
                    dbSelectArea("SD1")
                    aOldArea := GetArea()
                    dbSetOrder(01)
                    If	dbSeek(xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
                        NGSD1GESTL(SD1->D1_ORDEM,SD1->D1_COD)
                    Endif
                    RestArea(aOldArea)
                Endif
            Endif

            DbSelectArea("STL")
            DbSetorder(1)

            If !DbSeek( xFilial("STJ") + cORDEM)
                DbSelectArea("STJ")
                RecLock("STJ",.F.)
                STJ->TJ_TIPORET := " "
                MsUnlock("STJ")
            Else
                RecLock("STJ",.F.)
                STJ->TJ_TIPORET := "S"
                MsUnlock("STJ")
            Endif
        Endif
    Endif

    DbSelectArea(OldAli)
Return NIL

				/*/
    
    
    Ŀ
    Programa   NGSD3240I Autor  Nilton Pereira         Data  30/07/99 
    Ĵ
    Descrio  Atualizacao apos a gravacao de movto. interno              
    Ĵ
    Uso        Generico                                                   
                                                                          
               Objetivo: Gravar a Requisicao no SIGAMNT                   
    ٱ
    
    
				/*/

Function NGsd3240i(nLinha)
    Local CORDEM,LFOUND,CTIPOREG,vVDATFIM,nLinSD3 := If(nLinha = Nil .Or. nLinha = 0,1,nLinha)
    Local aTercProd := {}
    Local lTercProd := .F.
    Private lTEMSEQR := NgVerify("STL")
    Private dDtMDO   := Ctod("  /  /  "),cHoMDO := Space(5)

    If !Empty(SD3->D3_ORDEM) .and. SubStr(SD3->D3_CF,1,2) == "RE"
        cORDEM := SD3->D3_ORDEM
        DbSelectArea("STJ")
        DbSetorder(1)

        If DbSeek(xFilial("STJ") + cORDEM)
            lFOUND   := .F.

            //Recebe os Produtos de Terceiros do parametro
            If FindFunction("NGProdMNT")
                aTercProd := aClone(NGProdMNT("T"))
                lTercProd := ( aScan(aTercProd, {|x| AllTrim(x) == AllTrim(SD3->D3_COD) }) > 0)
            Else
                lTercProd := ( AllTrim(GetMV("MV_PRODTER")) == AllTrim(SD3->D3_COD) )
            EndIf

            cTIPOREG := If(lTercProd, "T", "P")

            If cTIPOREG = "P"
                If NGIFFILSEEK("STL",xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
                    While !Eof() .And. STL->TL_FILIAL = Xfilial("STL") .And.;
                            STL->TL_ORDEM = STJ->TJ_ORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO
                        If Alltrim(STL->TL_SEQRELA) <> "0" .And. STL->TL_TIPOREG = "M"
                            dDtMDO := STL->TL_DTINICI
                            cHoMDO := STL->TL_HOINICI
                            Exit
                        Endif
                        Dbskip()
                    End
                Endif
            Endif

            DbSelectArea("STL")
            DbSetorder(7)
            DbSeek(xFilial("STL")+SD3->D3_NUMSEQ)
            While !Eof() .and. STL->TL_FILIAL == xFilial("STL") .and. ;
                    STL->TL_NUMSEQ == SD3->D3_NUMSEQ

                If Trim(STL->TL_CODIGO) == Trim(SD3->D3_COD) .and. ;
                        Trim(STL->TL_ORDEM)  == cORDEM
                    lFound := .T.
                    Exit
                Endif
                DbSkip()
            End

            If !lFOUND
                nSEQSTL := ULTSEQ1()
                DbSelectArea("STL")
                Reclock("STL",.T.)
                STL->TL_FILIAL  := xfilial('STL')
                STL->TL_ORDEM   := cORDEM
                STL->TL_PLANO   := STJ->TJ_PLANO
                STL->TL_CODIGO  := SD3->D3_COD
                STL->TL_TIPOREG := cTIPOREG
                STL->TL_TAREFA  := '0'
                STL->TL_USACALE := 'N'
                STL->TL_GARANTI := 'N'
                If lTEMSEQR
                    STL->TL_SEQRELA := nSEQSTL
                Else
                    STL->TL_SEQUENC := nSEQSTL
                Endif
                STL->TL_UNIDADE := If(cTIPOREG = "T","H",SD3->D3_UM)
                STL->TL_QUANTID := SD3->D3_QUANT
                STL->TL_NUMSEQ  := SD3->D3_NUMSEQ
                STL->TL_DTINICI := SD3->D3_EMISSAO
                STL->TL_HOINICI := '08:00'

                If cTIPOREG = "T"
                    vVDATFIM := NGDTHORFIM(SD3->D3_EMISSAO,'08:00',SD3->D3_QUANT)
                    STL->TL_DTFIM := vVDATFIM[1]
                    STL->TL_HOFIM := vVDATFIM[2]
                Else
                    STL->TL_DTFIM := SD3->D3_EMISSAO
                    STL->TL_HOFIM := '08:00'
                EndIf
                STL->TL_DESTINO := If(cTIPOREG = 'T',' ','A')
                STL->TL_REPFIM  := 'S'
                STL->TL_CUSTO   := SD3->D3_CUSTO1
                STL->TL_TIPOHOR := ALLTrim(GETMV("MV_NGUNIDT"))

                If cTIPOREG = "P" .And. !Empty(dDtMDO) .And. !Empty(cHoMDO)
                    STL->TL_DTINICI := dDtMDO
                    STL->TL_HOINICI := cHoMDO
                    STL->TL_DTFIM   := dDtMDO
                    STL->TL_HOFIM   := cHoMDO
                Endif

                If FieldPos("TL_ORIGNFE") > 0
                    STL->TL_ORIGNFE := 'SD3'
                Endif

                If FieldPos("TL_NOTFIS") > 0
                    STL->TL_NOTFIS := SD3->D3_DOC
                Endif

                MSUNLOCK("STL")

                NGSTLSD3SCOM("SD3")

                DbSelectArea("STJ")
                Reclock("STJ",.F.)
                STJ->TJ_TIPORET := "S"
                MsUnlock("STJ")
            Endif
        Endif
        If  FindFunction("NGD3GARANT") .And. NGD3GARANT()  .And. SD3->D3_GARANTI = "S"
            If Type("aMntGarant") == "A"
                nLSD3 := Ascan(aMntGarant,{|x| x[11] = nLinSD3 })
                If nLSD3  > 0
                    NGGRVGARAN(aMntGarant,nLSD3,STL->TL_SEQRELA)
                EndIf
            EndIf
        EndIf
    Endif
    DbSelectArea("SD3")

Return(.T.)

				/*/
    
    
    Ŀ
    Funo     NGSD3240E Autor  Nilton Pereira         Data  04/11/99 
    Ĵ
    Descrio  Atualizacao apos a gravacao de movto. interno ( ESTORNO )  
    Ĵ
     Uso       Generico                                                   
    Ĵ
     OBS.:                                                                
    ٱ
    
    
				/*/

Function NGSd3240e()
    Local OLDALI,CPLANO,CORDEM
    Private lRegVir := .f.,nDifVir := 0, nACUMFIF := 0
    OldAli := Alias()
    If !Empty(SD3->D3_ORDEM)
        cPLANO := SUBSTR(SC2->C2_OBS,7,6)
        cORDEM := SD3->D3_ORDEM
        DbSelectArea("STJ")
        DbSetorder(1)

        IF DbSeek(xFilial("STJ") + cORDEM) .and. stj->tj_situaca == 'L' .and.;
                stj->tj_termino == 'N'
            DbSelectArea("SF5")
            DbSetorder(1)
            DbSeek(xFilial("SF5") + M->D3_TM)

            If sf5->f5_tipo == "R"
                DbSelectArea("STL")
                DbSetorder(7)

                IF DbSeek(xFilial("STL")+SD3->D3_NUMSEQ)
                    DbSelectArea("STN")
                    DbSetorder(1)
                    If DbSeek(xFilial("STN")+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA)
                        While !Eof() .And. STN->TN_FILIAL = Xfilial("STN") .And.;
                                STN->TN_ORDEM = STL->TL_ORDEM .And. STN->TN_TAREFA = STL->TL_TAREFA;
                                .And. STN->TN_SEQRELA = STL->TL_SEQRELA
                            RecLock("STN",.F.)
                            dbDelete()
                            MSUNLOCK("STN")
                            DbSkip()
                        End
                    EndIf
                    DbSelectArea("SD3")
                    If NGCADICBASE("D3_GARANTI","A","SD3",.F.)  .And.   SD3->D3_GARANTI == "S
                        DbSelectArea("TPZ")
                        DbSetOrder(2)
                        cChaTPZ := STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
                        If DbSeek(xfilial("TPZ")+cChaTPZ)
                            While !Eof() .And. TPZ->TPZ_FILIAL = Xfilial("TPZ") .And.;
                                    TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO+TPZ->TPZ_SEQREL = cChaTPZ

                                RecLock("TPZ",.F.)
                                dbDelete()
                                MSUNLOCK("TPZ")
                                DbSkip()
                            End
                        EndIf
                    EndIf
                    DbSelectArea("STL")
                    RecLock("STL",.F.)
                    dbDelete()
                    MSUNLOCK("STL")
                Endif

                DbSelectArea("STL")
                DbSetorder(1)

                If !DbSeek( xFilial("STJ") + cORDEM)
                    DbSelectArea("STJ")
                    RecLock("STJ",.F.)
                    STJ->TJ_TIPORET := " "
                    MsUnlock("STJ")
                Else
                    DbSelectArea("STJ")
                    RecLock("STJ",.F.)
                    STJ->TJ_TIPORET := "S"
                    MsUnlock("STJ")
                Endif
            Endif
        Endif
    Endif

    If nModulo != 19
        DbSelectArea("SX6")
        DbSetorder(1)
        If GetNewPar("MV_NGMNTFR","N") = "S"
            nOrdId := NGRETORDEM("TQN","TQN_FILIAL+TQN_NUMSEQ")
            If nOrdId > 0
                DbSelectArea("TQN")
                DbSetorder(nOrdId)

                If DbSeek(xFilial("TQN")+SD3->D3_NUMSEQ)
                    // PROCESSO COPIADO DO MNTA655

                    DbSelectArea("ST9")
                    DbSetOrder(16)
                    If DbSeek(TQN->TQN_FROTA)
                        cFilBem	:= ST9->T9_FILIAL
                    EndIf
                    aRetTPN := NgFilTPN(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS)
                    cFilTPN := aRetTPN[1]
                    If cFilTPN = " "
                        cFilTPN := TQN->TQN_FILIAL
                    EndIf

                    lSegCont := NGCADICBASE("TQN_POSCO2","A","TQN",.F.)

                    //Referentes ao primeiro contador
                    aARALTC := {'STP','stp->tp_filial','stp->tp_codbem',;
                        'stp->tp_dtleitu','stp->tp_hora','stp->tp_poscont',;
                        'stp->tp_acumcon','stp->tp_vardia','stp->tp_viracon'}
                    aARABEM := {'ST9','st9->t9_poscont','st9->t9_contacu',;
                        'st9->t9_dtultac','st9->t9_vardia'}

                    DbSelectArea(aARALTC[1])
                    Dbsetorder(5)
                    If Dbseek(xFilial(aARALTC[1],cFilTPN)+TQN->TQN_FROTA+Dtos(TQN->TQN_DTABAS)+TQN->TQN_HRABAS)
                        nRECNSTP := Recno()
                        nRECASTP := 0
                        lULTIMOP := .T.
                        nACUMFIP := 0
                        nCONTAFP := 0
                        nVARDIFP := 0
                        dDTACUFP := Ctod('  /  /  ')
                        DbSkip(-1)
                        If !Eof() .And. !Bof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                &(aARALTC[3]) = TQN->TQN_FROTA
                            nACUMFIP := &(aARALTC[7])
                            dDTACUFP := &(aARALTC[4])
                            nCONTAFP := &(aARALTC[6])
                            nVARDIFP := &(aARALTC[8])
                            nRECASTP := Recno()
                        Endif
                        Dbgoto(nRECNSTP)

                        nACUMDEL := stp->tp_acumcon

                        DbSelectArea(aARALTC[1])
                        RecLock(aARALTC[1],.F.)
                        Dbdelete()
                        MsUnlock(aARALTC[1])
                        MNTA875ADEL(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,2,cFilTPN,cFilTPN)
                        DbSelectArea(aARALTC[1])
                        If nRECASTP > 0
                            Dbgoto(nRECASTP)
                            DbSkip()
                            If !Eof() &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                    &(aARALTC[3]) = TQN->TQN_FROTA
                            Else
                                NGATUCONT(STP->TP_CODBEM,STP->TP_DTLEITU,STP->TP_POSCONT,;
                                    STP->TP_ACUMCON,STP->TP_VARDIA,1,.f.,.f.)
                            Endif
                        Endif
                    Endif

                    //Referentes ao segundo contador
                    If lSegCont
                        dbSelectArea("TPE")
                        dbSetOrder(1)
                        If DbSeek(If(NGSX2MODO("TPE")="E",cFilBem,xFilial("TPE"))+TQN->TQN_FROTA)
                            aARALTC := {'TPP','tpp->tpp_filial','tpp->tpp_codbem',;
                                'tpp->tpp_dtleit','tpp->tpp_hora','tpp->tpp_poscon',;
                                'tpp->tpp_acumco','tpp->tpp_vardia','tpp->tpp_viraco'}
                            aARABEM := {'TPE','tpe->tpe_poscon','tpe->tpe_contac',;
                                'tpe->tpe_dtulta','tpe->tpe_vardia'}
                            DbSelectArea(aARALTC[1])
                            Dbsetorder(5)
                            If Dbseek(xFilial(aARALTC[1],cFilTPN)+TQN->TQN_FROTA+Dtos(TQN->TQN_DTABAS)+TQN->TQN_HRABAS)
                                nRECNSTP := Recno()
                                nRECATPP := 0
                                lULTIMOP := .T.
                                nACUMFIP := 0
                                nCONTAFP := 0
                                nVARDIFP := 0
                                dDTACUFP := Ctod('  /  /  ')
                                DbSkip(-1)
                                If !Eof() .And. !Bof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                        &(aARALTC[3]) = TQN->TQN_FROTA
                                    nACUMFIP := &(aARALTC[7])
                                    dDTACUFP := &(aARALTC[4])
                                    nCONTAFP := &(aARALTC[6])
                                    nVARDIFP := &(aARALTC[8])
                                Endif
                                Dbgoto(nRECNSTP)

                                nACUMDEL := TPP->TPP_ACUMCO

                                DbSelectArea(aARALTC[1])
                                RecLock(aARALTC[1],.F.)
                                Dbdelete()
                                MsUnlock(aARALTC[1])

                                MNTA875ADEL(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,2,cFilTPN,cFilTPN)

                                DbSelectArea(aARALTC[1])
                                If nRECATPP > 0
                                    Dbgoto(nRECATPP)
                                    DbSkip()
                                    If !Eof() &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
                                            &(aARALTC[3]) = cCodfrot
                                    Else
                                        NGATUCONT(TPP->TPP_CODBEM,TPP->TPP_DTLEIT,TPP->TPP_POSCON,;
                                            TPP->TPP_ACUMCO,TPP->TPP_VARDIA,"2",.f.,.f.)
                                    Endif
                                Endif
                            Endif
                        EndIf
                    EndIf
                    NGDelTTVAba(TQN->TQN_NABAST)

                    DbSelectArea("TQN")
                    RecLock("TQN",.F.)
                    Dbdelete()
                    MsUnlock("TQN")

                Endif
            Endif
        Endif
    Endif

    DbSelectArea(OldAli)
return nil

				/*/
    
    Ŀ
    Funo    NGDTHORFIM Autor Inacio Luiz Kolling     Data 04/08/2005
    Ĵ
    Descrio Calcula a data e hora fim a partir de uma data e hora       
    Ĵ
     Uso      GENERICA                                                    
    ٱ
    
    
				/*/
Static Function NGDTHORFIM(dVDATI,cVHORI,nQTDHO)
    Local cINI  := HTOM(cVHORI),cDAT := dVDATI
    Local nHINT := Int(nQTDHO)
    Local nREST := (nQTDHO-nHINT) * 100
    Local cFIM  := If(GetMv("MV_NGUNIDT") = "D",cINI+(nQTDHO * 60),cINI+((nHINT * 60)+nREST))
    Local nSOMA := 0

    While cFIM > 1440
        nSOMA++
        cFIM -= 1440
    End
    dDATF  := cDAT+nSOMA
    cHORAF := MTOH(cFIM)
Return {dDATF,cHORAF}

				/*/
    
    
    Ŀ
    Funo      HTOM     Autor  NG INFORMATICA         Data           
    Ĵ
    Descrio  Converte horas em minutos                                  
    Ĵ
    Parametros Parametros -> cTime -> Horas em 99:99                      
    Ĵ
     Uso       Generico                                                   
    ٱ
    
    
				/*/
Static Function HTOM(cTIME)
    Local nHORA,nMINUTO,POS

    POS := At(":",cTIME)
    If POS == 0;Return 0;End
        nHORA   := Val(Substr(cTIME,1,(POS-1)))
        nMINUTO := Val(Substr(cTIME,(POS+1)))
        Return (nHORA*60)+nMINUTO

					/*/
        
        
        Ŀ
        Funo      MTOH     Autor  NG INFORMATICA         Data           
        Ĵ
        Descrio  Converte minutos em horas                                  
        Ĵ
        Parametros Parametros -> nMINUTO                                      
        Ĵ
         Uso       Generico                                                   
        ٱ
        
        
					/*/
Static Function MTOH(nMINUTO)
    Local nHoras,nRest,cRet,cHoraC := Alltrim(Str(nMINUTO))
    Local nPonVi := At(".",cHoraC)
    If nPonVi = 0
        nPonVi := At(",",cHoraC)
    EndIf

    nHoras := INT(nMINUTO / 60)
    nRest  := INT(nMINUTO % 60)

    If nPonVi = 0
        nPonVi := At(",",cHoraC)
    EndIf
    If nPonVi > 0
        nMinuM := Val(Substr(cHoraC,nPonVi+1,1))
        If nMinuM > 5
            nRest += 1
        Endif
    EndIf

    cRet   := StrZero(nHoras,2) + ":" + StrZero(nRest,2)

    If nHORAS > 99
        cRET := StrZero(nHoras,3) + ":" + StrZero(nRest,2)
    EndIf
    If nHORAS > 999
        cRet := StrZero(nHoras,4) + ":" + StrZero(nRest,2)
    EndIf
    If nHORAS > 9999
        cRet := StrZero(nHoras,5) + ":" + StrZero(nRest,2)
    EndIf
    If nHORAS > 99999
        cRet := StrZero(nHoras,6) + ":" + StrZero(nRest,2)
    EndIf
Return cRET

					/*
					
					
					Ŀ
					Funo	 GetAutoPar   Autor  Eduardo Motta   		   Data  26/02/02 
					Ĵ
					Descrio  Funcao para retornar parametros em array de rotina Automatica 
					Ĵ
					Sintaxe	  GetAutoPar(cPar,aRotAuto,uDef)								 
					Ĵ
					ParametroscPar     - Nome do parametro          						 
					          aRotAuto - Array da rotina automatica						     
					          uDef     - Valor default do parametro, caso nao exista     	 
					Ĵ
					
					
					*/
Function GetAutoPar(cPar,aArray,uDef)
    Local nPos := aScan(aArray,{|x|Upper(AllTrim(x[1]))==AllTrim(Upper(cPar))})
    Local uRet
    If nPos == 0
        uRet := uDef
    Else
        uRet := aArray[nPos,2]
    EndIf
Return uRet

					/*/
    
    Ŀ
    Funo	  AvalCond  Autor  Henry Fila             Data  14.11.03  
    Ĵ
    Descrio  Rotina para avaliar condicao de pagamento 				   
    Ĵ
    Sintaxe	  ExpA1 := AvalCond(ExpN1,ExpC1,ExpN2,ExpD1,ExpN3,ExpA2)	   
    Ĵ
    Parametros ExpA1 = Array contEndo os valores e os vencimentos de cada  
    			  		  parcela.											   
    			  ExpN1 = Valor total a ser parcelado.                        
    			  ExpC1 = Codigo da condicao de pagamento a ser considerada.  
    			  ExpN2 = Valor do IPI destacado para condicao que obrigue o  
    			  		  IPI a entrar na 1a parcela.                          
    			  ExpD1 = Data inicial para considerar desdobramento 		   
    			  ExpN3 = Valor do ICMS Solidario                             
    			  ExpA2 = Array contEndo a sigla e valor dos impostos calcula-
    			  		  dos para os paises Internacionais (MercoSul...)	   
    			  ExpA3 = Array contendo dados semelhantes ao que teria no    
    			  		  SE4 												   
    Ĵ
    Uso		  Generico                                                    
    Ĵ
     ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      
    Ĵ
     PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO                    
    Ĵ
     Rogerio F.G. 18/11/97B.HUR Alt Cond Pagto Tipo 9                    
     Rogerio F.G. 24/11/97B.HUR Ajuste Valor Cond Pagto tipo 8           
     Lucas        29.06.9816770AAdaptacao para os impostos MercoSul...   
     Aline C.Vale 13.09.99xxxxxxConsistencia do ultimo dia da cond. 3    
     Aline C.Vale 20.09.9918368AAcerto na Cond.Pgto.Tipo 7               
     Aline C.Vale 25.10.9924332ATratar Junta IPI na Cond.Pgto.Tipo 8     
     Sandro       02.03.00xxxxxx|funcionamento sem a existencia da codicao
                                |cadastrada no SE4                        
    Bruna Zechetti30.12.09      Ajustada a validao nos campos FB_JNS e 
                                |E4_SOMSUB, para poder definir a regra de 
                                |gerao (se E4_SOMSUB = 2, dever        
                                subtrair do valor da(s) parcelas ate     
                                |finalizar o valor de reteno do IVA).   
    Ivan Haponczuk15.07.10      Adicionado tratamento para localizacao   
                                |fiscal Venezuela, ajusta parcelas de     
                                |acordo com a natureza.                   
    Felipe Seolin 28.07.10      Adicionado tratamento para localizacao   
                                |fiscal Venezuela, pesquisa natureza com  
                                |pedido para entrada.                     
    Felipe Seolin 06.08.10      Adicionado tratamento para localizacao   
                                |fiscal Venezuela, ajusta valor retencao  
    Felipe Seolin 09.08.10      Ajuste no tratamento para localizacao    
                                |fiscal Venezuela, ajusta parcelas de     
                                |acordo com a natureza.                   
    Ivan Haponczuk08.04.11      Ajuste no tratamento para localizacao    
                                |fiscal Republica dominicana, ajusta      
                                |parcelas de acordo com a natureza.       
    ٱ
    
    
					/*/
FUNCTION AvalCond(nValTot,cCond,nValIpi,dData0,nValSolid,aImpVar,aE4,nAcrescimo,aDados,nInicio3,aDias3)

    Local cAlias := Alias()
    Local nRegSE4:=SE4->(Recno())
    Local lPorcent
    Local aArr
    Local aElem
    Local cString
    Local dProx
    Local nWeek
    Local nDIfDay
    Local i
    Local j
    Local x      := 0
    Local nC     := 0
    Local bData
    Local bValor
    Local aVenc  := { }
    Local nDup   := 0
    Local nValor := 0
    Local nReg   := 0
    Local cChave := ""
    Local cChave1:= ""
    Local nParcelas
    Local cParcela
    Local nValPed
    Local nDias
    Local n
    Local nValor9    := 0
    Local nX         := 0
    Local lVista     := .f.
    Local lEntrada   := .f.
    Local lCndTipo3  := SuperGetMv("MV_CNDTP3",.F.,.F.)
    Local nDIf:=0
    Local aTipo3     := {}
    Local nAux3
    Local lIPI       := (GetMV("MV_IPITP9") == "S")
    Local lDiaCont   := (SuperGetMv("MV_DIACONT",.F.,"1") == "1") //Considera o dia atual no calculo
    Local lPVista    := .F.
    Local aTP8       := {}
    Local aCondEsp3  := {}
    Local nValTp8    := 0
    Local cCalcImpV  := GetMV("MV_GERIMPV")
    Local cE4_CODIGO := aDados[1] //SE4->E4_CODIGO
    Local cE4_COND	 := aDados[2] //SE4->E4_COND
    Local cE4_TIPO	 := aDados[3] //SE4->E4_TIPO
    Local cE4_DDD	 := aDados[4] //SE4->E4_DDD
    Local cE4_IPI	 := aDados[5] //SE4->E4_IPI
    Local cE4_SOLID	 := aDados[6] //SE4->E4_SOLID
    Local cE4_ACRES  := IIf(SE4->(FieldPos("E4_ACRES"))<>0,SE4->E4_ACRES,"N")
    Local nMaxTipo9  := 26
    Local cMv1Dup    := ""
    Local aVencTlp   := {}
    Local nDecE1Vlr  := TamSX3( "E1_VALOR"  )[2]
    Local nVlrParc   := 0
    Local nVlrAcum1  := 0
    Local nLoop      := 0
    Local nValDup    := nValTot
    Local nSomaTp9   := 0
    Local nAuxC
    Local aTipoC     := {}
    LOCAL nDia       := 0
    LOCAL nMes       := 0
    LOCAL nAno       := 0
    LOCAL dVenc      := CTOD('  /  /  ')
    LOCAL nContA     := 0
    LOCAL nContB     := 0
    LOCAL nDtVenc
    Local dDiaAnt	 := CTOD('  /  /  ')	// Armazena o dia que foi utilizado anteriormente
    Local nDiaValid	 := 0					// Guarda o ultimo dia valido do mes
    Local nlRetIVA	:= 0
    Local nlRIVA	:= 0
    Local clTpCF	 := ""
    Local llAgRet	 := .F.
    Local nlVlrIVA	:= 0
    Local nlBaseIVA	:= 0
    Local nlAlqIVA	:= 0
    Local cAux
    Local clAgen	:= GetMV("MV_AGENTE")
    Local clNaturez := ""
    local ccdnat    := ""
    Local cImpRet	 := ""
    Local nValImp    := 0
    Local nValRetImp := 0
    Local nlRImp	 := 0
    Local nTotRet	 := 0
    Local nlPosImp	 := 0
    Local nlValAux	 := 0
    Local lXFis:=(MaFisFound() .And. ProcName(1)<>"EXECBLOCK")
    Local clCodTes   := ""
    Local clPedido   := ""
    DEFAULT nAcrescimo := 0
    DEFAULT aDias3     := {}

    If cPaisLoc == 'COL'
        If !lXFis
            clCodTes := SF4->F4_CODIGO
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") + SF4->F4_CODIGO + "RV0") //Reteno IVA
                cImpRet		:= SFC->FC_IMPOSTO
                nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RV0"})
                If nlPosImp	> 0
                    nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                EndIf

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                EndIf

            Elseif dbSeek(xFilial("SFC") + SF4->F4_CODIGO +  "RF0" )//Reteno TIMBRE
                cImpRet		:= SFC->FC_IMPOSTO
                nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RF0"})
                If nlPosImp	> 0
                    nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                EndIf

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_RETFUEN == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),3,1) == 'S',.T.,.F.)
                EndIf

            Elseif dbSeek(xFilial("SFC") + SF4->F4_CODIGO +  "RC0" )//Reteno ICA
                cImpRet		:= SFC->FC_IMPOSTO
                nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RC0"})
                If nlPosImp	> 0
                    nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                EndIf

                If cModulo $ "FAT"
                    clTpCF	:= Iif(SA1->A1_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SA1->A1_RETICA == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= Iif(SA2->A2_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),2,1) == 'S',.T.,.F.)
                EndIf
            EndIf

        Else
            clCodTes := MaFisRet(N,"IT_TES")
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") + MaFisRet(N,"IT_TES") + "RV0") //Reteno IVA
                cImpRet		:= SFC->FC_IMPOSTO
                nValRetImp 	:= Round(MaFisRet(,"NF_VALIV2"),2)

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                EndIf

            Elseif dbSeek(xFilial("SFC") + MaFisRet(N,"IT_TES") +  "RF0" )//Reteno TIMBRE
                cImpRet		:= SFC->FC_IMPOSTO
                nValRetImp 	:= Round(MaFisRet(,"NF_VALIV4"),2)

                If cModulo $ "FAT"
                    clTpCF	:= SA1->A1_TPESSOA
                    llAgRet	:= Iif(SA1->A1_RETFUEN == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= SA2->A2_TPESSOA
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),3,1) == 'S',.T.,.F.)
                EndIf

            Elseif dbSeek(xFilial("SFC") + MaFisRet(N,"IT_TES") +  "RC0" )//Reteno ICA
                cImpRet		:= SFC->FC_IMPOSTO
                nValRetImp 	:= Round(MaFisRet(,"NF_VALIV7"),2)

                If cModulo $ "FAT"
                    clTpCF	:= Iif(SA1->A1_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SA1->A1_RETICA == 'S',.T.,.F.)
                ElseIf cModulo $ "COM"
                    clTpCF	:= Iif(SA2->A2_TIPO<>'3','1','0')
                    llAgRet	:= Iif(SubStr(SuperGetMV("MV_AGENTE"),2,1) == 'S',.T.,.F.)
                EndIf
            EndIf
        Endif
    EndIf

    If cPaisLoc == 'EQU'
        If !lXFis
            clCodTes := SF4->F4_CODIGO
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") + SF4->F4_CODIGO + "RV") //Reteno IVA
                cAux:=Substr(FC_IMPOSTO,1,2)
                While FC_FILIAL==xFilial("SFC") .And. FC_TES==SF4->F4_CODIGO .And. cAux=="RV"
                    cImpRet		:= SFC->FC_IMPOSTO
                    nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == SFC->FC_IMPOSTO})
                    If nlPosImp	> 0
                        nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
                    EndIf
                    DbSkip()
                    cAux:=Substr(FC_IMPOSTO,1,2)
                Enddo
                If cModulo $ "FAT"
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                EndIf
                If cModulo $ "FAT"
                    clTpCF := SA1->A1_AGENRET
                ElseIf cModulo $ "COM"
                    clTpCF := iif (SubStr(clAgen,1,1)=="S","1","0")
                EndIf


            EndIf

        Else
            clCodTes := MaFisRet(N,"IT_TES")
            dbSelectArea("SFC")
            dbSetOrder(2)
            If dbSeek(xFilial("SFC") +  clCodTes + "RV") //Reteno IVA
                cAux:=Substr(FC_IMPOSTO,1,2)
                While FC_FILIAL==xFilial("SFC") .And. FC_TES==clCodTes .And. cAux=="RV"
                    cImpRet		:= SFC->FC_IMPOSTO
                    nValRetImp 	:= Round(MaFisRet(,"NF_VALIV"+SFB->FB_CPOLVRO),2)
                    DbSkip()
                    cAux:=Substr(FC_IMPOSTO,1,2)
                Enddo
                If cModulo $ "FAT"
                    llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
                EndIf
                If cModulo $ "FAT"
                    clTpCF := SA1->A1_AGENRET
                ElseIf cModulo $ "COM"
                    clTpCF := iif (SubStr(clAgen,1,1)=="S","1","0")
                EndIf
            EndIf
        Endif
    EndIf

    If cPaisLoc == "DOM"
        dbSelectArea("SFC")
        SFC->(dbSetOrder(2))
        If SFC->(dbSeek(xFilial("SFC")+SF4->F4_CODIGO))
            Do While SFC->FC_FILIAL == xFilial("SFC") .and. SFC->FC_TES == SF4->F4_CODIGO .and. SFC->(!EOF())
                If SFC->FC_INCDUPL <> "3"
                    If !lXFis
                        nlPosImp := aScan(aImpVar,{|x| Alltrim(x[1]) == SFC->FC_IMPOSTO})
                        If nlPosImp	> 0
                            nValImp += Round(aImpVar[nlPosImp,2],2)
                        EndIf
                    Else
                        dbSelectArea("SFB")
                        SFB->(dbSetOrder(1))
                        If SFB->(dbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
                            nValImp += Round(MaFisRet(,"NF_VALIV"+SFB->FB_CPOLVRO),2)
                        EndIf
                    EndIf
                EndIf
                SFC->(dbSkip())
            EndDo
        EndIf
    EndIf

    If aE4 <> NIL
        cE4_CODIGO 	:= aE4[1]
        cE4_COND		:= aE4[2]
        cE4_TIPO		:= aE4[3]
        cE4_DDD 		:= aE4[4]
        cE4_IPI		:= aE4[5]
        cE4_SOLID	:= aE4[6]
        If Len(aE4) >= 7
            cE4_ACRES    := aE4[7]
        EndIf
    Endif
    If dData0 == NIL
        dData0 := dDataBase
    EndIf

    If aImpVar == NIL
        aImpVar := {}
    EndIf

    nValSolid := Iif(nValSolid == Nil,0,nValSolid)
    aElem:=aArr:={ }
    nValIpi:=Iif(nValIpi==NIL,0,nValIpi)

    DbSelectArea("SE4")
    dbSetOrder(1)
    //Ŀ
    // Somente dar o seek se o registro corrente for != do desejado. 	  
    //
    If (cE4_CODIGO != cCond .Or. Empty(cE4_CODIGO)) .and. aE4 == NIL
        DbSeek(cFilial+cCond)
        If !Found() .Or. (cCond == "CN" .and. lLoja)
            nDup := 1
            dProx := dData0
            AADD(aVenc,{ dProx , nValTot })
            DbGoTo(nRegSE4)
            Return(aVenc)
        EndIf


        cE4_CODIGO 	:= SE4->E4_CODIGO
        cE4_COND		:= SE4->E4_COND
        cE4_TIPO		:= SE4->E4_TIPO
        cE4_DDD 		:= SE4->E4_DDD
        cE4_IPI		:= SE4->E4_IPI
        cE4_SOLID	:= SE4->E4_SOLID
        cE4_ACRES   := IIf(SE4->(FieldPos("E4_ACRES"))<>0,SE4->E4_ACRES,"N")
    EndIf

    cString:=cE4_COND

    While Len(cString) > 0
        AADD(aElem,Parse(@cString))
    End

    aArr := aClone( aElem )

    FOR i:=1 TO Len(aArr)
        aArr[i]:=Val(aArr[i])
        If aArr[i] == 0
            lPVista := .T.
        EndIf
    Next

    If cE4_TIPO == "3" .And. Len(aDias3) > 0

        Aadd(aCondEsp3,aArr[1])
        Aadd(aCondEsp3,If(Type("nInicio3") == "U",aArr[2],nInicio3))
        For nX := 1 to Len(aDias3)
            Aadd(aCondEsp3,aDias3[nX])
        Next
        aArr := aCondEsp3

    Endif
    //Ŀ
    // Tratamento para o campo E4_DDD												  
    //	  D = Data do dia 															  
    //	  L = Fora o dia																  
    //	  S = Fora a semana															  
    //	  Z = Fora a dezena															  
    //	  Q = Fora a quinzena														  
    //	  F = Fora o mes																  
    //
    If cE4_TIPO <> "9" .And.;
            cE4_TIPO <> "7"
        If cE4_DDD $ "D "
            dProx := dData0
        ElseIf cE4_DDD == "L"
            dProx   := dData0 + 1
        ElseIf cE4_DDD == "S"
            nDias   := Dow(dData0)
            If nDias == 7						  // Sabado
                dProx := dData0 + 1
            ElseIf nDias == 6 				  // Sexta
                dProx := dData0 + 2
            ElseIf nDias == 5 				  // Quinta
                dProx := dData0 + 3
            ElseIf nDias == 4 				  // Quarta
                dProx := dData0 + 4
            ElseIf nDias == 3 				  // Terca
                dProx := dData0 + 5
            ElseIf nDias == 2 				  // Segunda
                dProx := dData0 + 6
            ElseIf nDias == 1 				  // Domingo
                dProx := dData0 + 7
            EndIf
        ElseIf cE4_DDD == "Z"
            nDia := day(dData0)
            nMes := month(dData0)
            nAno := year(dData0)
            If nDia >= 01 .And. nDia <= 10
                nDia := 11
            ElseIf nDia >= 11 .And. nDia <= 20
                nDia := 21
            Else
                nDia := 01
                nMes := nMes + 1
            EndIf

            If nMes == 13
                nMes := 01
                nAno := nAno + 1
            EndIf
            nDia	  := strzero(nDia,2)
            nMes	  := strzero(nMes,2)
            nAno	  := substr(lTrim(str(nAno)),3,2)
            dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
        ElseIf cE4_DDD == "Q"
            nMes := month(dData0)
            nAno := year (dData0)
            If day(dData0) > 15
                nDia := 01
                nMes		:= nMes + 1
            Else
                nDia := 16
            EndIf
            If nMes == 13
                nMes		:= 01
                nAno := nAno + 1
            EndIf
            nDia	  := strzero(nDia,2)
            nMes	  := strzero(nMes,2)
            nAno	  := substr(lTrim(str(nAno)),3,2)
            dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
        ElseIf cE4_DDD == "F"
            nDia := 01
            nMes := month(dData0) + 1
            nAno := year (dData0)
            If nMes == 13
                nMes		:= 01
                nAno := nAno + 1
            EndIf
            nDia	  := strzero(nDia,2)
            nMes	  := strzero(nMes,2)
            nAno	  := substr(lTrim(str(nAno)),3,2)
            dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
        EndIf
    Else
        dProx := dData0
    EndIf

    If cE4_TIPO == "1"
        For i:= 1 TO Len(aArr)
            If lDiaCont
                If ( aArr[1] > 0 )
                    aArr[i] -= 1
                EndIf
            Endif
            AADD(aVenc,{ dProx + aArr[i], 0 })
        Next i
    ElseIf cE4_TIPO == "2"
        For i:= 1 TO Val(Subs(cCond,2,1))
            If i == 1
                dProx += (Val(cE4_COND) * Val(Subs(cCond,1,1)))
            Else
                dProx += (Val(cE4_COND) * Val(Subs(cCond,3,1)))
            EndIf
            AADD(aVenc,{ dProx , 0 })
        Next i
    ElseIf cE4_TIPO == "3"

        //Ŀ
        // Dados do Array - aArr								
        //	[1] - Numero de duplicatas a gerar					
        //	[2] - Intervalo entre as duplicatas 				
        //	[3]...[n] - Dias possiveis de vencimento no mes     
        //		Obs. : Se o primeiro vencto for 00, a primeira  
        //				 duplicata sera a vista, caso haja 00 nos
        //				 nos outros venctos sera desconsiderado. 
        //

        nDtVenc := aArr[3]

        If aArr[3] == 00				// Primeira parcela a vista
            If lCndTipo3 .And. Len(aDias3) == 0
                aArr[3] := Day(dProx)
                nAux3    := 3
            Else
                nAux3 := 4
                lVista:= .T.
            Endif
        Else
            nAux3 := 3
        EndIf

        For n:=nAux3 To Len(aArr)	// Elimino a parcela 00 e crio array dos possiveis dias vencto
            If aArr[n] != 00
                Aadd(aTipo3,aArr[n])
            EndIf
        Next n

        If Len(aTipo3) != 0
            aTipo3:= aSort(aTipo3)		//  Colocar em ordem crescente de vencimentos
            For i:=1 to aArr[1]
                If !lVista
                    If i == 1
                        dProx+= aArr[2]
                        If cE4_DDD == "L"
                            dProx--
                        Endif
                    Else
                        dDiaAnt	:= dProx
                        dProx ++
                        dProx	:= If(Day(dProx)>30,dProx+1,dProx)
                    EndIf
                    nDia:= Day(dProx)
                    nMes:= Month(dProx)
                    nAno:= Year(dProx)

                    If nDtVenc <> 00 .or. i <> 1
                        For n:= 1 to Len(aTipo3)
                            If nDia <= aTipo3[n]
                                nDia		:= aTipo3[n]
                                nDiaValid 	:= nDia
                                //Ŀ
                                //Caso seja seja zero o dia de vencimento, valida se a diferenca entre a nova data 
                                //e a antiga eh maior que 1 , isso por que no caso de vencimentos iniciado 31/01   
                                //com o intervalo de 30 dias , sera da seguinte forma ( 31/01 , 02/03 , 31/03 )    
                                //
                                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                                    nDiaValid := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                                EndIf
                                If nDtVenc <> 0 .OR. (nDtVenc == 0 .AND.;
                                        CTOD(StrZero(nDiaValid,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy") - dDiaAnt > 1 )
                                    lEntrada:=.T.
                                EndIf
                                Exit
                            EndIf
                        Next n
                        If !lEntrada
                            nDia := aTipo3[1]
                            nMes := Iif((nMes+1) > 12,1 ,nMes+1)
                            nAno := Iif( nMes == 1, (nAno+1), nAno)
                        EndIf
                    Endif
                Else
                    lVista := .F.
                    nDia := Day(dProx)
                    nMes := Month(dProx)
                    nAno := Year(dProx)
                EndIf
                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                EndIf
                dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                AADD(aVenc, { dProx , 0 } )
                lEntrada := .F.
            Next i
        Else
            For i:=1 To aArr[1]
                nDia := Day(dProx)
                nMes := Month(dProx)
                nAno := Year(dProx)
                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                EndIf
                dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                AADD(aVenc, { dProx , 0 } )
                dProx+=aArr[2]
            Next i
        EndIf
    ElseIf cE4_TIPO == "4"
        For i:=1 To aArr[1]
            dProx   += aArr[2]
            For x:=1 to 7
                If Dow(dProx) == aArr[3]
                    Exit
                EndIf
                dProx++
            Next i
            AADD(aVenc,{ (dProx), 0 } )
        Next i
    ElseIf cE4_TIPO == "5"
        If Len(aArr) == 3
            For i:= 1 TO aArr[2] //Val(Subs(cCond,2,1))
                If i == 1
                    dProx += aArr[1]
                Else
                    dProx += aArr[3]
                EndIf
                AADD(aVenc,{ dProx , 0 })
            Next i
        Else
            AADD(aVenc,{ dData0 , 0 })
        EndIf
    ElseIf cE4_TIPO == "6"
        For i:=1 To aArr[1]
            If i==1
                dProx += aArr[2]
            Else
                dProx   += aArr[4]
            EndIf
            For x:=1 to 7
                If DOW(dProx) == aArr[3]
                    Exit
                EndIf
                dProx++
            Next x
            AADD(aVenc,{ (dProx), 0 } )
        Next i
    ElseIf cE4_TIPO == "7"
        // Descricao da Condicao de Pagamento Tipo 7
        // Cadastrar na Condicao 13 parametros separados por virgula onde o sistema
        // ira considerar o 1o parametro como o numero de parcelas e os outros 12
        // como as datas fixas de vencimento referente ao mes, ex.:
        // 10,1,2,3,4,5,6,7,8,9,10,11,12 (serao 10 parcelas com vencimento no dia
        // referente ao mes, ou seja o mes 4 vai vencer no dia 4)
        nDia := Day( dData0 )
        nMes := Month( dData0 )
        nAno := Year( dData0 )
        If cE4_DDD == "F"  //Fora o mes
            nMes ++
            nAno := If(nMes > 12, nAno+1, nAno)
            nMes := If(nMes>12,1,nMes)
        EndIf
        If cE4_DDD == "Q"  //Fora a quinzena
            If day(dData0) > 15
                nDia := 01
                nMes := nMes + 1
            Else
                nDia := 16
            EndIf
            If nMes == 13
                nMes := 01
                nAno := nAno + 1
            EndIf
        EndIf
        While Len(aVenc) < aArr[1]  //Numero de Parcelas
            If (Len( aArr ) # 13)
                aAdd( aVenc,{ dData0,0 } )
                Exit
            EndIf
            nDia := aArr[nMes+1]
            If !Empty(aArr[nMes+1])
                If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                EndIf
                dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                If dProx >= dData0
                    AADD(aVenc, { dProx , 0 } )
                EndIf
            EndIf
            nMes ++
            If (nMes > 12)
                nAno++
                nMes := 1
            EndIf
        End
    ElseIf cE4_TIPO == "8"
        aTP8:=ArrayTP8(cE4_COND)
        If cE4_IPI == "J"
            nValTot -= nValIPI
        EndIf
        For i := 1 to Len(aTP8)
            AAdd(aVenc,{dProx+aTP8[i][1],Round((nValTot/100)*aTP8[i][2],2)})
            nValTp8 += Round((nValTot/100)*aTP8[i][2],2)
        Next i
        If cE4_IPI == "J"
            aVenc[1][2] += nValIPI
            nValTp8 += nValIPI
            nValTot += nValIPI
        EndIf
        If nValTp8 != nValTot
            aVenc[Len(aVenc)][2] += Round(nValTot - nValTp8,2)
        EndIf
    ElseIf cE4_TIPO == "9"
        //Ŀ
        // Verifica se pode estender a tipo 9 ate 36 parcelas                     
        //
        cMv1Dup := GetMV( "MV_1DUP" )
        If Len( cMv1Dup ) > 1 .And. Len( cMv1Dup ) == Len( SE1->E1_PARCELA )
            nMaxTipo9 := 36
        EndIf

        cParcela  := "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0"
        nParcelas := GETMV("MV_NUMPARC")
        cChave := "C5_DATA"+Subs(cParcela,nParcelas,1)
        cChave1:= "C5_PARC"+Subs(cParcela,nParcelas,1)
        DbSelectArea("SX3")
        nReg := Recno()
        DbSetOrder(2)
        If nParcelas > nMaxTipo9
            nParcelas := nMaxTipo9
        EndIf
        If nParcelas > 4
            If !DbSeek(cChave) .or. !DbSeek(cChave1)
                nParcelas := 4
            EndIf
        Else
            nParcelas := 4
        EndIf
        DbSetOrder(1)
        If !Empty (cAlias)
            DbSelectArea(cAlias)
        Endif
        bData := { |x| "C5_DATA"+Subs(cParcela,x,1) }
        bValor:= { |x| "C5_PARC"+Subs(cParcela,x,1) }
        nValPed := 0
        // Valor Total das Parcelas
        For i:= 1 to nParcelas
            nValPed += SC5->&(EVAL(bValor,i))
        Next i

        If Trim(cE4_COND) == "0"
            // VerIfica se IPI ja esta nas parcelas
            If !lIPI ; nValtot-= nValIPI ; EndIf
            EndIf
            For i:= 1 to nParcelas
                If !Empty(SC5->&(EVAL(bData,i))) .And. !Empty(SC5->&(EVAL(bValor,i)))
                    If Trim(cE4_COND) == "%"
                        If i == 1
                            If cE4_IPI == "J"
                                nSomaTp9 := nValIPI
                                nValTot -= nValIPI
                            EndIf
                            If cE4_SOLID == "J"
                                nSomaTp9 += nValSolid
                                nValTot -= nValSolid
                            EndIf
                            If cE4_ACRES == "J"
                                nSomaTp9 += nAcrescimo
                                nValTot  -= nAcrescimo
                            EndIf
                        Else
                            nSomaTp9 := 0
                        EndIf
                        If nValPed > 100
                            nValor := nValTot * (((SC5->&(EVAL(bValor,i))/nValPed)*100) / 100 )
                        Else
                            nValor := nValTot * (SC5->&(EVAL(bValor,i)) / 100 )
                        EndIf
                        nValor += nSomaTp9
                    Else
                        // achar o % referente ao valor
                        nValor := SC5->&(EVAL(bValor,i)) / nValPed
                        nValor := nValTot * nValor
                        // os quant. presentes em C5_PARCn referem-se a valores
                        //nValor := SC5->&(EVAL(bValor,i))
                        nValor := Iif(Abs(nValor - SC5->&(EVAL(bValor,i) ) ) <= 1,SC5->&(EVAL(bValor,i)),nValor)
                    EndIf
                    AADD(aVenc,{ SC5->&(EVAL(bData,i)), nValor } )
                EndIf
            Next i
        ElseIf cE4_TIPO == "C"
            If aArr[1] <> 0				// Primeira parcela a vista
                If Len(aDias3) == 0
                    nAuxC := 1
                Else
                    nAuxC := 2
                    lVista := .T.
                Endif
            Else
                nAuxC := 1
            EndIf

            For n:=nAuxC To Len(aArr)	// Elimino a parcela 00 e crio array dos possiveis dias vencto
                If Day(dDataBase) != 00
                    Aadd(aTipoC,Day(dDataBase))
                EndIf
            Next n

            If Len(aTipoC) != 0
                aTipoC:= aSort(aTipoC)		//  Colocar em ordem crescente de vencimentos
                For i:=1 to aArr[1]
                    If !lVista
                        If i == 1
                            dProx+= 0
                        Else
                            dProx:= If(Day(dProx)>30,dProx+1,dProx)
                        EndIf
                        nDia:= Day(dProx)
                        nMes:= Month(dProx)
                        nAno:= Year(dProx)
                        If !lEntrada
                            If i <> 1
                                nDia := nDia
                                nMes := Iif((nMes+1) > 12,1 ,nMes+1)
                                nAno := Iif( nMes == 1, (nAno+1), nAno)
                                lEntrada:= .F.
                            EndIf
                        EndIf
                    Else
                        lVista := .F.
                        nDia := Day(dProx)
                        nMes := Month(dProx)
                        nAno := Year(dProx)
                    EndIf
                    If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                        nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    EndIf
                    dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                    AADD(aVenc, { dProx , 0 } )
                    lEntrada := .F.
                Next i
            Else
                For i:=1 To aArr[1]
                    nDia := Day(dProx)
                    nMes := Month(dProx)
                    nAno := Year(dProx)
                    If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                        nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
                    EndIf
                    dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
                    AADD(aVenc, { dProx , 0 } )
                    dProx+=0
                Next i
            EndIf
        ELSEIF cE4_TIPO == 'D'
            //Ŀ
            // Os campos do E4_COND, separados por Virgulas, correspondem 
            // aos Meses dos Vencimentos, a partir da Data de Emissao.    
            // Ex.: Na Emissao em 30/05/07 e E4_COND = '0,2,3,4' os Ven-  
            // cimentos serao: 30/05, 30/07, 30/08 e 30/09 de 2007.       
            //
            FOR nContA := 1 TO LEN(aArr)
                nDia := DAY(dProx)
                nMes := MONTH(dProx)
                nAno := YEAR(dProx)
                FOR nContB := 1 TO aArr[nContA]
                    nAno := nAno+IIF(nMes==12,1,0)
                    nMes := IIF(nMes==12,1,nMes+1)
                NEXT nContB
                IF !EMPTY(CTOD(STRZERO(nDia,2)+'/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy'))
                    dVenc := CTOD(STRZERO(nDia,2)+'/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy')
                ELSE
                    dVenc := LASTDAY(CTOD('01/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy'))+1
                ENDIF
                AADD(aVenc,{dVenc,0})
            NEXT nContA
        EndIf
        //Ŀ
        //		Desdobramento dos valores baseado no numero de duplicatas	  
        //
        nDup:=Len(aVenc)

        If !(cE4_TIPO $ "89")

            //Ŀ
            // Desdobrar valores dos impostos variaveis baseando se campo FB_JNS 
            // de cada imposto correspondente. 											 
            //Lucas
            If cCalcImpV == "S" .And. Len(aImpVar) > 0

                nIniLoop := 1

                For nC := 1 To Len(aImpVar)
                    SFB->( DbSetOrder(1) )
                    SFB->( DbSeek( xFilial("SFB")+AllTrim(aImpVar[nC][1])) )

                    If SFB->FB_JNS $ "JS" .And. cPaisLoc <> 'COL'
                        aVenc[1][2] := If( nC==1,aImpVar[nC][2],aVenc[1][2] + aImpVar[nC][2] )
                        nValTot -= aImpVar[nC][2]
                        nIniLoop := 2
                    EndIf
                    If cE4_ACRES $ "JS"
                        aVenc[1][2] := nAcrescimo
                        nValTot     -= nAcrescimo
                        nIniLoop    := 2
                    ElseIf cE4_ACRES $ "V" .And. lPVista
                        nValTot     -= nAcrescimo
                    EndIf

                    If !("S" $ SFB->FB_JNS + cE4_ACRES)
                        nIniLoop := 1
                    EndIf
                Next nC

                If nIniLoop == 2
                    nValor := Round( nValTot / (nDup-1) ,2 )
                Else
                    nValor := Round( nValTot / nDup ,2 )
                EndIf


                If llAgRet
                    nlRImp	:= nValRetImp
                EndIf
                For i := nIniLoop TO nDup

                    If nlRImp > 0 .And. cPaisLoc == 'COL'
                        If SFB->FB_JNS == 'J'
                            dbSelectArea("SFC")
                            dbSetOrder(2)
                            If dbSeek(xFilial("SFC") + clCodTes + cImpRet)
                                Do Case
                                Case FC_INCDUPL == '2'
                                    nValRetImp := nValor - nlRImp
                                    If nValRetImp >= 0
                                        aVenc[i][2] += Round(nValRetImp,2)
                                        nlRImp	:= 0
                                    Else
                                        aVenc[i][2] += 0
                                        nlRImp	:= Round((nValRetImp * (-1)),2)
                                    EndIf
                                Case FC_INCDUPL == '1'
                                    aVenc[i][2] += Round(nValor + nlRImp,2)
                                    nlRImp	:= 0
                                Otherwise
                                    aVenc[i][2] += Round(nValor,2)
                                    nlRImp	:= 0
                                EndCase
                            EndIf
                        EndIf
                    elseIf nlRImp > 0 .And. clTpCF == '1' .And. cPaisLoc == 'EQU'
                        dbselectarea("SED")
                        SED->(Dbsetorder(1))
                        dbSeek(xFilial("SED") + SC5->C5_NATUREZ)
                        dbSelectArea("SFC")
                        dbSetOrder(2)
                        If dbSeek(xFilial("SFC") + clCodTes + cImpRet)
                            Do Case
                            Case SED->ED_RATRET == '1'
                                nValor := Round( (nValTot + nValRetImp) / nDup ,2 )
                                nValRetImp := nValor - nlRImp
                                If nValRetImp >= 0
                                    aVenc[i][2] += Round(nValRetImp,2)
                                    nlRImp	:= 0
                                Else
                                    aVenc[i][2] += 0
                                    nlRImp	:= Round((nValRetImp * (-1)),2)
                                EndIf
                            Otherwise
                                nValor := Round( nValTot / nDup ,2 )
                                aVenc[i][2] += Round(nValor,2)
                                nlRImp	:= 0
                            EndCase
                        EndIf
                    ElseIf nValRetImp > 0 .and. clTpCF == '1' .and. cPaisLoc == 'VEN'
                        If Type("SC5->C5_NATUREZ") <> "U"
                            clNaturez := SC5->C5_NATUREZ
                        EndIf
                        DBSelectArea("SED")
                        SED->(DBSetOrder(1))
                        If DBSeek(xFilial("SED") + clNaturez)
                            Do Case
                            Case SED->ED_RATRET == '1'
                                nValor	:= Round((nValTot + nValRetImp) / nDup,2)
                                nTotRet	:= nValor - nValRetImp
                                If nTotRet >= 0
                                    aVenc[i][2]	+= Round(nTotRet,2)
                                    nValRetImp	:= 0
                                Else
                                    aVenc[i][2]	+= 0
                                    nValRetImp	:= Round((nTotRet * (-1)),2)
                                EndIf
                            OtherWise
                                nValor		:= Round(nValTot / nDup,2)
                                aVenc[i][2]	+= Round(nValor,2)
                                nValRetImp	:= 0
                            EndCase
                        Else
                            nValor	:= Round((nValTot + nValRetImp) / nDup,2)
                            nTotRet	:= nValor - nValRetImp
                            If nTotRet >= 0
                                aVenc[i][2]	+= Round(nTotRet,2)
                                nValRetImp	:= 0
                            Else
                                aVenc[i][2]	+= 0
                                nValRetImp	:= Round((nTotRet * (-1)),2)
                            EndIf
                        EndIf
                    ElseIf nValImp > 0 .and. cPaisLoc == "DOM"

                        If Type("M->C5_NATUREZ") <> "U"
                            clNaturez := M->C5_NATUREZ
                        ElseIf Type("SC5->C5_NATUREZ") <> "U"
                            clNaturez := SC5->C5_NATUREZ
                        Else
                            clNaturez := ""
                        EndIf

                        dbSelectArea("SED")
                        SED->(dbSetOrder(1))
                        If SED->(dbSeek(xFilial("SED")+clNaturez))
                            If SED->ED_RATRET == "1"
                                nValor      := Round((nValTot-nValImp)/nDup,2)
                                aVenc[i][2]	+= Round(nValor+nValImp,2)
                                nValImp := 0
                            Else
                                nValor		:= Round(nValTot / nDup,2)
                                aVenc[i][2]	+= Round(nValor,2)
                                nValImp     := 0
                            EndIf
                        Else
                            nValor		:= Round(nValTot / nDup,2)
                            aVenc[i][2]	+= Round(nValor,2)
                            nValImp     := 0
                        EndIf

                    Else
                        aVenc[i][2] += nValor
                    EndIf
                    If cE4_ACRES $ "V" .And. lPVista
                        nValor += Round( nAcrescimo / (nDup-i) ,2 )
                        lPVista  := .F.
                    EndIf
                Next i

            Else

                nIniLoop := 1

                If cE4_IPI $ "JS"
                    aVenc[1][2] := nValIPI
                    nValTot -= nValIPI
                    nIniLoop := 2
                EndIf

                If cE4_SOLID $ "JS"
                    aVenc[1][2] += nValSolid
                    nValTot -= nValSolid
                    nIniLoop := 2
                EndIf

                If cE4_ACRES $ "JS"
                    aVenc[1][2] += nAcrescimo
                    nValTot     -= nAcrescimo
                    nIniLoop    := 2
                ElseIf cE4_ACRES $ "V" .And. lPVista
                    nValTot     -= nAcrescimo
                EndIf

                If !("S" $ cE4_IPI + cE4_SOLID + cE4_ACRES)
                    nIniLoop := 1
                EndIf

                If nIniLoop == 2
                    nValor := Round( nValTot / (nDup-1) ,2 )
                Else
                    nValor := Round( nValTot / nDup ,2 )
                EndIf

                For i := nIniLoop TO nDup

                    If nValRetImp > 0 .And. cPaisLoc == 'COL'
                        If SFB->FB_JNS $ 'J/S'
                            DbSelectArea("SFC")
                            SFC->(DbSetOrder(2))
                            If DbSeek(xFilial("SFC") + clCodTes + cImpRet )
                                Do Case
                                Case FC_INCDUPL == '2'
                                    nTotRet := nValor - nValRetImp
                                    If nTotRet >= 0
                                        aVenc[i][2] += Round(nTotRet,2)
                                        nValRetImp := 0
                                    Else
                                        aVenc[i][2] += 0
                                        nValRetImp	:= Round((nTotRet * (-1)),2)
                                    Endif
                                Case FC_INCDUPL == '1'
                                    aVenc[i][2] += Round(nValor + nValRetImp,2)
                                OtherWise
                                    aVenc[i][2] += Round(nValor,2)
                                    nValRetImp := 0
                                EndCase
                            Endif
                        Endif
                    elseIf nValRetImp > 0 .And. clTpCF == '1' .And. cPaisLoc == 'EQU'
                        IF SC7->C7_NATUREZ <> " "
                            dbselectarea("SED")
                            SED->(Dbsetorder(1))
                            dbSeek(xFilial("SED") + SC7->C7_NATUREZ)
                        EndIf
                        DbSelectArea("SFC")
                        SFC->(DbSetOrder(2))
                        If DbSeek(xFilial("SFC") + clCodTes + cImpRet )
                            Do Case
                            Case SED->ED_RATRET == '1'
                                nValor := Round( (nValTot + nValRetImp) / nDup ,2 )
                                nTotRet := nValor - nValRetImp
                                If nTotRet >= 0
                                    aVenc[i][2] += Round(nTotRet,2)
                                    nValRetImp := 0
                                Else
                                    aVenc[i][2] += 0
                                    nValRetImp	:= Round((nTotRet * (-1)),2)
                                Endif
                            OtherWise
                                nValor := Round( nValTot / nDup ,2 )
                                aVenc[i][2] += Round(nValor,2)
                                nValRetImp := 0
                            EndCase
                        Endif
                    ElseIf nValImp > 0 .and. cPaisLoc == "DOM"

                        If Type("SC7->C7_NATUREZ") <> "U"
                            clPedido := aCols[1][17]
                            If AllTrim(clPedido) <> ""
                                DBSelectArea("SC7")
                                DBSetOrder(1)
                                If DBSeek(xFilial("SC7") + clPedido)
                                    clNaturez := SC7->C7_NATUREZ
                                EndIf
                            EndIf
                        EndIf

                        If Type("M->C5_NATUREZ") <> "U"
                            clNaturez := M->C5_NATUREZ
                        ElseIf Type("M->F1_NATUREZ") <> "U"
                            clNaturez := M->F1_NATUREZ
                        ElseIf Type("M->F2_NATUREZ") <> "U"
                            clNaturez := M->F2_NATUREZ
                        EndIf

                        dbSelectArea("SED")
                        SED->(dbSetOrder(1))
                        If SED->(dbSeek(xFilial("SED")+clNaturez))
                            If SED->ED_RATRET == "1"
                                nValor      := Round((nValTot-nValImp)/nDup,2)
                                aVenc[i][2]	+= Round(nValor+nValImp,2)
                                nValImp := 0
                            Else
                                nValor		:= Round(nValTot / nDup,2)
                                aVenc[i][2]	+= Round(nValor,2)
                                nValImp     := 0
                            EndIf
                        Else
                            nValor		:= Round(nValTot / nDup,2)
                            aVenc[i][2]	+= Round(nValor,2)
                            nValImp     := 0
                        EndIf

                    Else
                        aVenc[i][2] += nValor
                    EndIf
                    If cE4_ACRES $ "V" .And. lPVista
                        nValor += Round( nAcrescimo / (nDup-i) ,2 )
                        lPVista  := .F.
                    EndIf
                Next i
            EndIf
        Else
            If Trim(cE4_COND) == "0"  .and.  nValPed < nValTot
                If Len(aVenc) > 0
                    nDup:=Len(aVenc)
                    nDIf := nValTot - nValPed
                    If NoRound(nDIf,4) > 0
                        aVenc[nDup][2] += nDIf
                    EndIf
                    nDIf := nValIpi / nDup
                    If !lIPI
                        For i:=1 To nDup
                            aVenc[i][2] += nDIf
                        Next
                    EndIf
                EndIf
            ElseIf Trim(cE4_COND) == "0"  .and.  nValPed >= nValTot
                If Len(aVenc) > 0
                    nDup:=Len(aVenc)
                    aVenc[nDup][2] -= nValIpi
                    nDIf := nValIPI / nDup
                    If nValIPI == 0
                        aVenc[nDup][2] += nDIf
                    Else
                        If !lIPI
                            For i:=1 To nDup
                                aVenc[i][2] += nDIf
                            Next
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf
        //Ŀ
        // Trata diferenca de centavo nas parcelas              
        //
        For nLoop := 1 to Len(aVenc)
            nVlrParc := NoRound( aVenc[nLoop][2], nDecE1Vlr )
            nVlrAcum1 += nVlrParc

            If ( Len(aVenc)==nLoop .And. nValDup <> 0) .And. !cPaisLoc$"COL|VEN"
                nVlrParc += nValDup - nVlrAcum1
            EndIf
            // reatribui com o novo valor da parcela
            aVenc[nLoop][2] := nVlrParc

        Next nLoop
        //
        // Template de GEM - Gestao de Empreendimentos Imobiliarios
        //
        If ExistTemplate("GMCondicao")
            aVencTlp := ExecTemplate("GMCondicao",.F.,.F.,{cE4_CODIGO,dData0,nValDup,.F.})
            If !Empty(aVencTlp)
                aVenc := aClone(aVencTlp)
            EndIf
        EndIf

        SE4->(DbGoTo(nRegSE4))

        Return(aVenc)

						/*
						
						
						ͻ
						Funcao    D3Valido  Autor  Fernando J. Siquini  Data  18/10/2004  
						͹
						Desc.      Avalia se o registro posicionado no SD3 eh valido.         
						           !!!Atencao!!! Deve-se posicionar no SD3 a ser testado      
						͹
						Parametros Void                                                       
						͹
						Retorno    .T. se o registro for valido, .F. se o registro nao for    
						           valido.                                                    
						͹
						Uso        Advanced Protheus                                          
						ͼ
						
						*/
Function D3Valido(cAlias)

						Static lEstornado := Nil
						Static lD3Servico := Nil
						Static lD3Valido  := Nil

						Local lRet       := .T.
						Local lRetPE     := .T.

						Default cAlias     := 'SD3'

						//Ŀ
						// Verifica se considera registros estornados no SD3            
						//
						lEstornado := If(lEstornado==NIL, GetMV('MV_D3ESTOR', .F., 'N')=='S', lEstornado)

						//Ŀ
						// Verifica se considera registros com Servico de WMS no SD3    
						//
						lD3Servico := If(lD3Servico==NIL, GetMV('MV_D3SERVI', .F., 'N')=='S', lD3Servico)

						//Ŀ
						// Verifica se o ponto de Entrada D3Valido existe               
						//
						lD3Valido := If(lD3Valido==NIL, ExistBlock('D3VALIDO'), lD3Valido)

    If lD3Valido
							lRetPE := ExecBlock('D3VALIDO', .F., .F., cAlias)
							lRet   := If(ValType(lRetPE)=='L', lRetPE, lRet)
    EndIf

    Do While lRet
							//Ŀ
							// Nao considera Registros Estornados                           
							//
        If !lEstornado .And. !Empty((cAlias)->D3_ESTORNO)
								lRet := .F.
								Exit
        EndIf

							//Ŀ
							// Nao considera Registros referentes a servicos de WMS Nao Executados 
							//
        If !lD3Servico .And. !Empty((cAlias)->D3_SERVIC) .And. IntDL((cAlias)->D3_COD)
            If (cAlias)->D3_TM > '500' .And. !((cAlias)->D3_LOCAL==SuperGetMV('MV_CQ', .F., '98')) //-- Saidas nao serao consideradas (quando o servico for executado ira gerar outro registro no SD3)
									lRet := .F.
									Exit
            EndIf
        EndIf

							Exit
    EndDo

						Return lRet


						/*/
						
						
						Ŀ
						Funcao    VerIDProc  Autor  Marcelo Pimentel       Data 24.07.2007
						Ĵ
						Descrio Identifica a sequencia de controle do fonte ADVPL com a     
						          stored procedure, qualquer alteracao que envolva diretamente
						          a stored procedure a variavel sera incrementada.            
						          Procedure MAT006                                            
						Ĵ
						   DATA    Programador   Manutencao Efetuada                         
						ٱ
						
						
						/*/
    #IFDEF TOP

Static Function VerIDProc()
							Return '010'

#ENDIF
						/*/
						
						
						Ŀ
						Funcao    VerIDProc2 Autor  Marcelo Pimentel       Data 24.07.2007
						Ĵ
						Descrio Identifica a sequencia de controle do fonte ADVPL com a     
						          stored procedure, qualquer alteracao que envolva diretamente
						          a stored procedure a variavel sera incrementada.            
						          Procedure FIN001                                            
						Ĵ
						   DATA    Programador   Manutencao Efetuada                         
						ٱ
						
						
						/*/
#IFDEF TOP

Static Function VerIDProc2()
							Return '010'

#ENDIF

						/*
						
						
						Ŀ
						Funo     MATXFUNB_V  Autor  Microsiga S/A        Data  12/12/09 
						Ĵ
						Descrio  Funcao utilizada para verificar a ultima versao do fonte   
									  matxfunb aplicado no rpo do cliente, verificando assim a   
									  necessidade de uma atualizacao neste fonte.		    	  
						Ĵ
						 Uso       EST/PCP/FAT/COM	                                          
						ٱ
						
						
						*/
Function MATXFUNB_V
    Local nRet := 20091212 // 12 de Dezembro de 2009
Return nRet


						/*/
    
    
    Ŀ
    Funcao    NGSD3TQN Autor  Marcos Wagner Junior   Data 05.1.2010   
    Ĵ
    Descrio Faz a consistencia da delecao do abastecimento (tqn)        
    Ĵ
    Ĵ
     Uso       MNT         	                                          
    ٱ
       DATA    Programador   Manutencao Efetuada                         
    ٱ
    
    
						/*/
Function NGSD3TQN()
    Local lRet := .t.
    Local aOldArea := GetArea()

    If nModulo != 19
        DbSelectArea("SX6")
        DbSetorder(1)
        If GetNewPar("MV_NGMNTFR","N") = "S"
            nOrdId := NGRETORDEM("TQN","TQN_FILIAL+TQN_NUMSEQ")
            If nOrdId > 0
                DbSelectArea("TQN")
                DbSetorder(nOrdId)

                If DbSeek(xFilial("TQN")+SD3->D3_NUMSEQ)
                    // PROCESSO COPIADO DO MNTA655
                    //Verifica Historico de Contador de Bomba
                    If lRet .AND. !MNT655LOTE() //Se foi pelo Abastecimento em Lote nao podera alterar
                        ApMsgInfo(STR0092) //"Para realizar o estorno utilize a rotina de Abastecimento em Lote do mdulo de Manuteno de Ativos."
                        lRet := .f.
                    Endif

                    If lRet .AND. !MNTA655OK(STR0093) //"Excludo"
                        lRet := .f.
                    Endif

                    If lRet .AND. NGVDHBomba(TQN->TQN_POSTO,TQN->TQN_LOJA,TQN->TQN_TANQUE,TQN->TQN_BOMBA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,"'2'") .Or. ;
                            NGVDHBomba(TQN->TQN_POSTO,TQN->TQN_LOJA,TQN->TQN_TANQUE,TQN->TQN_BOMBA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,,"'3'")
                        ShowHelpDlg(STR0001,{STR0094},3,; //"Ateno"###"Estorno no permitido pois j existe Aferio de Bomba com data/hora superior a este abastecimento."
                        {STR0095},3) //"Exclua as Aferies cadastradas com data/hora superior a este abastecimento pelo mdulo de Manuteno de Ativos."
                        lRet := .F.
                    EndIf

                    If lRet .AND. !Empty(TQN->TQN_DTCON)
                        If !MsgYesNo(STR0096) //"Abastecimento relacionado j foi conciliado! Deseja continuar?"
                            lRet := .f.
                        Endif
                    Endif

                Endif
            Endif
        Endif
    Endif

    RestArea(aOldArea)

Return lRet

						/*
						
						
						Ŀ
						Funo    UsaFilTrf   Autor  Emerson Rony Oliveira  Data  13/04/11 
						Ĵ
						Descricao  Analisa parametro MV_FILTRF, que define se serao utilizados 
						 		 | os novos campos "A1_FILTRF" e "A2_FILTRF" no processo de    
						 		 | transferencia entre filiais. A ausencia do parametro ou     
						 		 | conteudo .F. indica o uso padrao da rotina, ou seja, sera   
						 		 | utilizado o CNPJ para identificar o cliente/fornecedor      
						 		 | durante o processo de transferencia entre filiais. Se o     
						 		 | conteudo for .T. entao serao usados os novos campos das     
						 		 | tabelas SA1 e SA2. (UPDEST39)                               
						Ĵ
						Retorno    Logico (default .F.)                                        
						Ĵ
						Uso        MATA310, MATA103, MATA410, MATR715                          
						ٱ
						
						
						*/
Function UsaFilTrf()
    Local lRet := GetMV("MV_FILTRF",.F.,.F.) // .F. == indica funcionamento padrao da rotina -- atraves do CNPJ do cliente/fornecedor

    If lRet
        If !(SA1->(FieldPos("A1_FILTRF")) > 0 .And. SA2->(FieldPos("A2_FILTRF")) > 0)
            lRet := .F. // os campos devem existir na base
        EndIF
    EndIf

Return lRet

						/*
						
						
						Ŀ
						Funo    MtValidFil  Autor  Emerson Rony Oliveira  Data  13/04/11 
						Ĵ
						Descricao  Verifica a existncia da filial enviada como parametro.     
						Ĵ
						Retorno    Logico (default .F.)                                        
						Ĵ
						Uso        MATA020, MATA030                                            
						ٱ
						
						
						*/
Function MtValidFil(cChave)
    Local aArea := GetArea()
    Local lRet  := .T.

    dbSelectArea("SM0")
    dbSetOrder(1)
    If !MsSeek(cChave)	// Tenta localizar a Empresa+Filial enviadas no parametro cChave
        Help(" ",1,"SAVALFIL")
        lRet := .F.
    EndIf

    MsSeek(cEmpAnt+cFilAnt)
    RestArea(aArea)

Return lRet


						/*
						
						
						ͻ
						Programa   NGSD1GESTL Autor  Marcos Wagner Jr.  Data   30/03/11   
						͹
						Desc.      Geracao do insumo (STL) atraves de inclusao de SC1         
						͹
						Uso        MATXFUNB                                                   
						ͼ
						
						
						*/
Function NGSD1GESTL(_CORDEM,_CCODIGO)
    Local lTermino  := .f.
    Local lTercProd := .f.
    Local aTercProd := {}
    Local cDestino  := "", cCodigo := "", cTipoReg := ""
    Private lTEMSEQR  := NgVerify("STL")
    Private dDtMDO    := Ctod("  /  /  "),cHoMDO := Space(5)

    //Recebe os Produtos de Terceiros do parametro
    If FindFunction("NGProdMNT")
        aTercProd := aClone(NGProdMNT("T"))
        lTercProd := ( aScan(aTercProd, {|x| AllTrim(x) == AllTrim(_CCODIGO) }) > 0)
    Else
        lTercProd := ( AllTrim(GetMV("MV_PRODTER")) == AllTrim(_CCODIGO) )
    EndIf
    cTipoReg := If(lTercProd, "T", "P")
    nSEQSTL := ULTSEQ1()
    If cTipoReg == "T"
        cCodigo  := SD1->D1_FORNECE
    Else
        cCodigo  := SD1->D1_COD
        cDestino := "A"
    EndIf

    If cTIPOREG = "P"
        If NGIFFILSEEK("STL",xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
            While !Eof() .And. STL->TL_FILIAL = Xfilial("STL") .And.;
                    STL->TL_ORDEM = _CORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO
                If Alltrim(STL->TL_SEQRELA) <> "0" .And. STL->TL_TIPOREG = "M"
                    dDtMDO := STL->TL_DTINICI
                    cHoMDO := STL->TL_HOINICI
                    Exit
                Endif
                Dbskip()
            End
        Endif
    Endif

    dbSelectArea("STJ")
    dbSetorder(1)
    If dbSeek(xFilial("STJ")+_CORDEM)
        lTermino := If(STJ->TJ_TERMINO == "S",.T.,.F.)
    Endif

    dbSelectArea("STL")
    dbSetorder(1)  // ORDEM DE NUMSEQ
    Reclock("STL",.T.)
    STL->TL_FILIAL  := xfilial('STL')
    STL->TL_ORDEM   := _CORDEM
    STL->TL_PLANO   := STJ->TJ_PLANO
    STL->TL_CODIGO  := cCodigo
    STL->TL_TIPOREG := cTipoReg
    STL->TL_TAREFA  := '0'
    STL->TL_USACALE := 'N'
    STL->TL_GARANTI := 'N'
    If lTEMSEQR
        STL->TL_SEQRELA := nSEQSTL
    Else
        STL->TL_SEQUENC := nSEQSTL
    Endif
    STL->TL_UNIDADE := If(cTIPOREG = "T","H",SD1->D1_UM)
    STL->TL_QUANTID := SD1->D1_QUANT
    STL->TL_NUMSEQ  := SD1->D1_NUMSEQ
    STL->TL_DTINICI := If(lTermino,STJ->TJ_DTMRFIM,SD1->D1_DTDIGIT)
    STL->TL_HOINICI := If(lTermino,STJ->TJ_HOMRFIM,'08:00')
    If cTIPOREG = "T"
        vVDATFIM := NGDTHORFIM(SD1->D1_DTDIGIT,'08:00',SD1->D1_QUANT)
        STL->TL_DTFIM := If(lTermino,STJ->TJ_DTMRFIM,vVDATFIM[1])
        STL->TL_HOFIM := If(lTermino,STJ->TJ_HOMRFIM,vVDATFIM[2])
    Else
        STL->TL_DTFIM := If(lTermino,STJ->TJ_DTMRFIM,SD1->D1_DTDIGIT)
        STL->TL_HOFIM := If(lTermino,STJ->TJ_HOMRFIM,'08:00')
    EndIf
    STL->TL_DESTINO := cDestino
    STL->TL_REPFIM  := 'S'
    STL->TL_CUSTO   := SD1->D1_CUSTO
    STL->TL_NUMOP   := Substr(SD1->D1_OP,1,6)
    STL->TL_ITEMOP  := Substr(SD1->D1_OP,7,2)
    STL->TL_SEQUEOP := Substr(SD1->D1_OP,9,3)
    STL->TL_TIPOHOR := ALLTrim(GETMV("MV_NGUNIDT"))

    If cTIPOREG = "P" .And. !Empty(dDtMDO) .And. !Empty(cHoMDO)
        STL->TL_DTINICI := dDtMDO
        STL->TL_HOINICI := cHoMDO
        STL->TL_DTFIM   := dDtMDO
        STL->TL_HOFIM   := cHoMDO
    Endif

    If FieldPos("TL_ORIGNFE") > 0
        STL->TL_ORIGNFE := 'SD1'
    Endif

    If FieldPos("TL_FORNEC") > 0
        STL->TL_FORNEC := SD1->D1_FORNECE
    Endif

    If FieldPos("TL_LOJA") > 0
        STL->TL_LOJA := SD1->D1_LOJA
    Endif

    If FieldPos("TL_NOTFIS") > 0
        STL->TL_NOTFIS := SD1->D1_DOC
    Endif

    If FieldPos("TL_SERIE") > 0
        STL->TL_SERIE := SD1->D1_SERIE
    Endif

    If lTermino
        STL->TL_OBSERVA := STR0103+DtoC(STL->TL_DTFIM)+"."+Chr(13)+; //"Insumo lanado aps a finalizao da O.S. em: "
        STR0104+DtoC(SD1->D1_DTDIGIT)+"." //"Data de lanamento: "
    EndIf

    MSUNLOCK("STL")

Return .t.

						/*
						
						
						ͻ
						Programa  Ctb_IsCache Autor  Microsiga          Data   12/06/10   
						͹
						Desc.                                                                 
						                                                                      
						͹
						Uso        AP                                                         
						ͼ
						
						
						*/

Static Function Ctb_IsCache(nCache)
    If __lCacheIs == Nil
        __lCacheIs := ( GetNewPar( "MV_CTBCACH" , "1" ) == "1" )   //"0"=Nao Trabalha com Cache "1"=Trabalha com Cache
    EndIf
Return(__lCacheIs)

						/*
						
						
						ͻ
						Programa  AtuVldEnt Autor  Microsiga            Data   01/07/10   
						͹
						Desc.      Atualizacao do cache de validacao das entidades contabeis. 
						                                                                      
						͹
						Uso        AP                                                         
						ͼ
						
						
						*/
Function AtuVldEnt(cEntid, cCodigo)
    Local nPos 		:= 0
    Local bPesq  	:= {|x| 	x[2,1] == cCodigo }
    Local lChkCache := Findfunction("Ctb_IsCache")

    If lChkCache .And. cEntid == "CT1" .And. Ctb_IsCache(1) .And. !Empty(__aCTBConta) .And. ( nPos := Ascan( __aCTBConta, bPesq) ) > 0
        __aCTBConta[nPos][2][1] := ""
    Endif

    If lChkCache .And. cEntid == "CTT" .And. Ctb_IsCache(2) .And. !Empty(__aCTBCusto) .And. ( nPos := Ascan( __aCTBCusto, bPesq) ) > 0
        __aCTBCusto[nPos][2][1] := ""
    Endif

    If lChkCache .And. cEntid == "CTD" .And. Ctb_IsCache(3) .And. !Empty(__aCTBItem) .And. ( nPos := Ascan( __aCTBItem, bPesq) ) > 0
        __aCTBItem[nPos][2][1] := ""
    Endif

    If lChkCache .And. cEntid == "CTH" .And. Ctb_IsCache(4) .And. !Empty(__aCTBClVlr) .And. ( nPos := Ascan( __aCTBClVlr, bPesq) ) > 0
        __aCTBClVlr[nPos][2][1] := ""
    Endif

Return
